"""Service layer for the Post-Exploitation module."""

import importlib
import os
import random
from contextlib import asynccontextmanager
from typing import Any, AsyncIterator, Dict, List, Optional, Tuple, Type, Union

from sentinelprobe.core.logging import get_logger
from sentinelprobe.exploitation.models import ExploitResult
from sentinelprobe.post_exploitation.models import (
    CleanupResult,
    LateralMovementResult,
    PostExploitationActivity,
    PostExploitationActivityCreate,
    PostExploitationConfig,
    PostExploitationRequest,
    PostExploitationResponse,
    PostExploitationType,
    PrivilegeEscalationResult,
)
from sentinelprobe.post_exploitation.repository import PostExploitationRepository
from sentinelprobe.reconnaissance.models import Target

logger = get_logger(__name__)


class PostExploitationTechnique:
    """Base class for post-exploitation techniques."""

    @property
    def name(self) -> str:
        """Get the name of the technique."""
        return self.__class__.__name__

    @property
    def description(self) -> str:
        """Get the description of the technique."""
        return "Base post-exploitation technique"

    @property
    def type(self) -> PostExploitationType:
        """Get the type of post-exploitation activity."""
        return PostExploitationType.PRIVILEGE_ESCALATION

    async def execute(
        self,
        activity: PostExploitationActivity,
        target: Target,
        exploit_result: ExploitResult,
        config: PostExploitationConfig,
        parameters: Dict[str, Any],
    ) -> Union[PrivilegeEscalationResult, LateralMovementResult, CleanupResult]:
        """Execute the technique.

        Args:
            activity: Post-exploitation activity
            target: Target to execute on
            exploit_result: Result of the exploit
            config: Post-exploitation configuration
            parameters: Technique-specific parameters

        Returns:
            Execution result
        """
        raise NotImplementedError("Subclasses must implement the execute method")

    @staticmethod
    def get_available_techniques(
        activity_type: PostExploitationType,
    ) -> List[Type["PostExploitationTechnique"]]:
        """Get available techniques for a specific activity type.

        Args:
            activity_type: Activity type

        Returns:
            List of technique classes
        """
        techniques = []
        plugins_dir = os.path.join(
            os.path.dirname(os.path.abspath(__file__)), "techniques"
        )

        if not os.path.exists(plugins_dir):
            logger.warning(f"Techniques directory not found: {plugins_dir}")
            return []

        # Special case for cleanup - it's a common operation
        if activity_type == PostExploitationType.CLEANUP:
            from sentinelprobe.post_exploitation.techniques.cleanup import (
                CleanupTechnique,
            )

            return [CleanupTechnique]

        # Load techniques from files
        for filename in os.listdir(plugins_dir):
            if filename.endswith(".py") and not filename.startswith("__"):
                module_name = filename[:-3]
                try:
                    module = importlib.import_module(
                        f"sentinelprobe.post_exploitation.techniques.{module_name}"
                    )
                    for item_name in dir(module):
                        item = getattr(module, item_name)
                        if (
                            isinstance(item, type)
                            and issubclass(item, PostExploitationTechnique)
                            and item != PostExploitationTechnique
                        ):
                            technique_instance = item()
                            if technique_instance.type == activity_type:
                                techniques.append(item)
                except Exception as e:
                    logger.error(f"Error loading technique {module_name}: {e}")

        return techniques

    @staticmethod
    def get_technique_instance(
        technique_name: str,
        activity_type: PostExploitationType,
    ) -> Optional["PostExploitationTechnique"]:
        """Get a technique instance by name.

        Args:
            technique_name: Technique name
            activity_type: Activity type for validation

        Returns:
            Technique instance or None if not found
        """
        techniques = PostExploitationTechnique.get_available_techniques(activity_type)
        for technique_class in techniques:
            technique = technique_class()
            if technique.name == technique_name:
                return technique
        return None


class PostExploitationService:
    """Service for post-exploitation activities."""

    def __init__(self, repository: Optional[PostExploitationRepository] = None) -> None:
        """Initialize the service.

        Args:
            repository: Post-exploitation repository (optional)
        """
        self._repository = repository or PostExploitationRepository()

    async def initialize(self) -> None:
        """Initialize dependencies."""
        await self._repository.initialize()

    @asynccontextmanager
    async def _get_required_data(
        self,
        activity_type: PostExploitationType,
        target_id: str,
        exploit_id: str,
    ) -> AsyncIterator[Tuple[PostExploitationActivity, Target, ExploitResult]]:
        """Get required data for post-exploitation.

        Args:
            activity_type: Type of activity
            target_id: Target ID
            exploit_id: Exploit ID

        Yields:
            Tuple of activity, target, and exploit result
        """
        # Create activity
        activity_create = PostExploitationActivityCreate(
            type=activity_type,
            target_id=target_id,
            exploit_id=exploit_id,
        )

        activity = await self._repository.create_activity(activity_create)
        await self._repository.update_activity_status(activity.id, "in_progress")

        # Get target
        target = await self._repository.get_target(target_id)
        if not target:
            logger.error(f"Target not found: {target_id}")
            await self._repository.update_activity_status(activity.id, "failed")
            raise ValueError(f"Target not found: {target_id}")

        # Get exploit result
        exploit_result = await self._repository.get_result(exploit_id)
        if not exploit_result:
            logger.error(f"Exploit result not found: {exploit_id}")
            await self._repository.update_activity_status(activity.id, "failed")
            raise ValueError(f"Exploit result not found: {exploit_id}")

        try:
            yield activity, target, exploit_result
        except Exception as e:
            logger.error(f"Error during post-exploitation: {e}")
            await self._repository.update_activity_status(activity.id, "failed")
            raise

    async def perform_privilege_escalation(
        self, request: PostExploitationRequest
    ) -> PostExploitationResponse:
        """Perform privilege escalation on a target.

        Args:
            request: Post-exploitation request

        Returns:
            Post-exploitation response
        """
        config = request.config or PostExploitationConfig()
        parameters = request.parameters or {}

        available_techniques = PostExploitationTechnique.get_available_techniques(
            PostExploitationType.PRIVILEGE_ESCALATION
        )

        if not available_techniques:
            return PostExploitationResponse(
                activity_id="",
                success=False,
                result={},
                details="No privilege escalation techniques available",
            )

        technique_name = parameters.get("technique")
        technique = None

        if technique_name:
            technique = PostExploitationTechnique.get_technique_instance(
                technique_name, PostExploitationType.PRIVILEGE_ESCALATION
            )

        if not technique:
            # Get a technique at random that's not excluded
            allowed_techniques = [
                t
                for t in available_techniques
                if (
                    not config.excluded_techniques
                    or t.__name__ not in config.excluded_techniques
                )
                and (
                    not config.allowed_techniques
                    or t.__name__ in config.allowed_techniques
                )
            ]

            if not allowed_techniques:
                return PostExploitationResponse(
                    activity_id="",
                    success=False,
                    result={},
                    details="No usable privilege escalation techniques available",
                )

            technique_class = random.choice(allowed_techniques)
            technique = technique_class()

        async with self._get_required_data(
            PostExploitationType.PRIVILEGE_ESCALATION,
            request.target_id,
            request.exploit_id,
        ) as (activity, target, exploit_result):
            logger.info(
                f"Performing privilege escalation on {target.id} using {technique.name}"
            )

            result = await technique.execute(
                activity, target, exploit_result, config, parameters
            )

            # Type check to ensure we have the right result type
            if not isinstance(result, PrivilegeEscalationResult):
                logger.error(f"Unexpected result type: {type(result)}")
                await self._repository.update_activity_status(activity.id, "failed")
                return PostExploitationResponse(
                    activity_id=activity.id,
                    success=False,
                    result={},
                    details=f"Unexpected result type: {type(result)}",
                )

            # Store the result
            await self._repository.store_privilege_escalation_result(result)

            return PostExploitationResponse(
                activity_id=activity.id,
                success=result.success,
                result=result,
                details=f"Privilege escalation {'succeeded' if result.success else 'failed'}: {result.details}",
            )

    async def perform_lateral_movement(
        self, request: PostExploitationRequest
    ) -> PostExploitationResponse:
        """Perform lateral movement from a compromised target.

        Args:
            request: Post-exploitation request

        Returns:
            Post-exploitation response
        """
        config = request.config or PostExploitationConfig()
        parameters = request.parameters or {}

        available_techniques = PostExploitationTechnique.get_available_techniques(
            PostExploitationType.LATERAL_MOVEMENT
        )

        if not available_techniques:
            return PostExploitationResponse(
                activity_id="",
                success=False,
                result={},
                details="No lateral movement techniques available",
            )

        technique_name = parameters.get("technique")
        technique = None

        if technique_name:
            technique = PostExploitationTechnique.get_technique_instance(
                technique_name, PostExploitationType.LATERAL_MOVEMENT
            )

        if not technique:
            # Get a technique at random that's not excluded
            allowed_techniques = [
                t
                for t in available_techniques
                if (
                    not config.excluded_techniques
                    or t.__name__ not in config.excluded_techniques
                )
                and (
                    not config.allowed_techniques
                    or t.__name__ in config.allowed_techniques
                )
            ]

            if not allowed_techniques:
                return PostExploitationResponse(
                    activity_id="",
                    success=False,
                    result={},
                    details="No usable lateral movement techniques available",
                )

            technique_class = random.choice(allowed_techniques)
            technique = technique_class()

        async with self._get_required_data(
            PostExploitationType.LATERAL_MOVEMENT,
            request.target_id,
            request.exploit_id,
        ) as (activity, target, exploit_result):
            logger.info(
                f"Performing lateral movement from {target.id} using {technique.name}"
            )

            result = await technique.execute(
                activity, target, exploit_result, config, parameters
            )

            # Type check to ensure we have the right result type
            if not isinstance(result, LateralMovementResult):
                logger.error(f"Unexpected result type: {type(result)}")
                await self._repository.update_activity_status(activity.id, "failed")
                return PostExploitationResponse(
                    activity_id=activity.id,
                    success=False,
                    result={},
                    details=f"Unexpected result type: {type(result)}",
                )

            # Store the result
            await self._repository.store_lateral_movement_result(result)

            return PostExploitationResponse(
                activity_id=activity.id,
                success=result.success,
                result=result,
                details=f"Lateral movement {'succeeded' if result.success else 'failed'}: {result.details}",
            )

    async def perform_cleanup(
        self, request: PostExploitationRequest
    ) -> PostExploitationResponse:
        """Perform cleanup after post-exploitation.

        Args:
            request: Post-exploitation request

        Returns:
            Post-exploitation response
        """
        config = request.config or PostExploitationConfig()
        parameters = request.parameters or {}

        technique_class = PostExploitationTechnique.get_available_techniques(
            PostExploitationType.CLEANUP
        )[0]
        technique = technique_class()

        async with self._get_required_data(
            PostExploitationType.CLEANUP,
            request.target_id,
            request.exploit_id,
        ) as (activity, target, exploit_result):
            logger.info(f"Performing cleanup on {target.id}")

            result = await technique.execute(
                activity, target, exploit_result, config, parameters
            )

            # Type check to ensure we have the right result type
            if not isinstance(result, CleanupResult):
                logger.error(f"Unexpected result type: {type(result)}")
                await self._repository.update_activity_status(activity.id, "failed")
                return PostExploitationResponse(
                    activity_id=activity.id,
                    success=False,
                    result={},
                    details=f"Unexpected result type: {type(result)}",
                )

            # Store the result
            await self._repository.store_cleanup_result(result)

            return PostExploitationResponse(
                activity_id=activity.id,
                success=result.success,
                result=result,
                details=f"Cleanup {'succeeded' if result.success else 'failed'}: {result.details}",
            )

    async def execute_post_exploitation(
        self, request: PostExploitationRequest
    ) -> PostExploitationResponse:
        """Execute a post-exploitation activity.

        Args:
            request: Post-exploitation request

        Returns:
            Post-exploitation response
        """
        if request.activity_type == PostExploitationType.PRIVILEGE_ESCALATION:
            return await self.perform_privilege_escalation(request)
        elif request.activity_type == PostExploitationType.LATERAL_MOVEMENT:
            return await self.perform_lateral_movement(request)
        elif request.activity_type == PostExploitationType.CLEANUP:
            return await self.perform_cleanup(request)
        else:
            return PostExploitationResponse(
                activity_id="",
                success=False,
                result={},
                details=f"Unsupported activity type: {request.activity_type}",
            )

    async def auto_cleanup_pending_activities(self) -> List[CleanupResult]:
        """Auto-cleanup pending activities.

        Returns:
            List of cleanup results
        """
        pending_activities = await self._repository.get_pending_cleanup_activities()
        cleanup_results = []

        for activity, result in pending_activities:
            # Create cleanup request
            request = PostExploitationRequest(
                activity_type=PostExploitationType.CLEANUP,
                target_id=activity.target_id,
                exploit_id=activity.exploit_id,
                parameters={"prev_activity_id": activity.id},
            )

            # Perform cleanup
            response = await self.perform_cleanup(request)

            if isinstance(response.result, CleanupResult):
                cleanup_results.append(response.result)

        return cleanup_results

    async def get_activity(
        self, activity_id: str
    ) -> Optional[PostExploitationActivity]:
        """Get an activity by ID.

        Args:
            activity_id: Activity ID

        Returns:
            Activity or None if not found
        """
        return await self._repository.get_activity(activity_id)

    async def get_activities_by_target(
        self, target_id: str, activity_type: Optional[PostExploitationType] = None
    ) -> List[PostExploitationActivity]:
        """Get all activities for a target.

        Args:
            target_id: Target ID
            activity_type: Optional type filter

        Returns:
            List of activities
        """
        return await self._repository.get_activities_by_target(target_id, activity_type)

    async def get_privilege_escalation_result(
        self, result_id: str
    ) -> Optional[PrivilegeEscalationResult]:
        """Get a privilege escalation result by ID.

        Args:
            result_id: Result ID

        Returns:
            Result or None if not found
        """
        return await self._repository.get_privilege_escalation_result(result_id)

    async def get_lateral_movement_result(
        self, result_id: str
    ) -> Optional[LateralMovementResult]:
        """Get a lateral movement result by ID.

        Args:
            result_id: Result ID

        Returns:
            Result or None if not found
        """
        return await self._repository.get_lateral_movement_result(result_id)

    async def get_cleanup_result(self, result_id: str) -> Optional[CleanupResult]:
        """Get a cleanup result by ID.

        Args:
            result_id: Result ID

        Returns:
            Result or None if not found
        """
        return await self._repository.get_cleanup_result(result_id)

    async def get_results_by_activity(
        self, activity_id: str, activity_type: PostExploitationType
    ) -> List[Union[PrivilegeEscalationResult, LateralMovementResult, CleanupResult]]:
        """Get all results for an activity.

        Args:
            activity_id: Activity ID
            activity_type: Activity type

        Returns:
            List of results
        """
        return await self._repository.get_results_by_activity(
            activity_id, activity_type
        )


_service_instance = None


async def get_post_exploitation_service() -> PostExploitationService:
    """Get the post-exploitation service singleton.

    Returns:
        Post-exploitation service instance
    """
    global _service_instance
    if _service_instance is None:
        _service_instance = PostExploitationService()
        await _service_instance.initialize()
    return _service_instance
