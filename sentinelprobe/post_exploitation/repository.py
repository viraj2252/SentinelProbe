"""Repository layer for the Post-Exploitation module."""

import asyncio
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple, Union, cast

from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorCollection
from pymongo import ReturnDocument

from sentinelprobe.core.logging import get_logger
from sentinelprobe.core.mongodb import get_collection
from sentinelprobe.exploitation.models import ExploitResult
from sentinelprobe.post_exploitation.models import (
    CleanupResult,
    LateralMovementResult,
    PostExploitationActivity,
    PostExploitationActivityCreate,
    PostExploitationType,
    PrivilegeEscalationResult,
)
from sentinelprobe.reconnaissance.models import Target

logger = get_logger(__name__)


class PostExploitationRepository:
    """Repository for post-exploitation activities and results."""

    def __init__(self, db: Optional[AsyncIOMotorClient] = None) -> None:
        """Initialize the repository.

        Args:
            db: MongoDB database client (optional)
        """
        self.db = db
        self._activities_collection: Optional[AsyncIOMotorCollection] = None
        self._privilege_escalation_collection: Optional[AsyncIOMotorCollection] = None
        self._lateral_movement_collection: Optional[AsyncIOMotorCollection] = None
        self._cleanup_collection: Optional[AsyncIOMotorCollection] = None
        self._initialized = False

    async def initialize(self) -> None:
        """Initialize the repository collections."""
        if self._initialized:
            return

        if self.db is None:
            # Instead of using get_database, we'll use get_collection directly
            self._activities_collection = await get_collection(
                "post_exploitation_activities"
            )
            self._privilege_escalation_collection = await get_collection(
                "privilege_escalation_results"
            )
            self._lateral_movement_collection = await get_collection(
                "lateral_movement_results"
            )
            self._cleanup_collection = await get_collection("cleanup_results")
        else:
            # If db is explicitly provided, use it directly
            self._activities_collection = cast(
                AsyncIOMotorCollection, self.db.post_exploitation_activities
            )
            self._privilege_escalation_collection = cast(
                AsyncIOMotorCollection, self.db.privilege_escalation_results
            )
            self._lateral_movement_collection = cast(
                AsyncIOMotorCollection, self.db.lateral_movement_results
            )
            self._cleanup_collection = cast(
                AsyncIOMotorCollection, self.db.cleanup_results
            )

        # Create indexes
        activities_collection = self._get_activities_collection()
        privilege_escalation_collection = self._get_privilege_escalation_collection()
        lateral_movement_collection = self._get_lateral_movement_collection()
        cleanup_collection = self._get_cleanup_collection()

        await asyncio.gather(
            activities_collection.create_index("target_id"),
            activities_collection.create_index("exploit_id"),
            activities_collection.create_index("type"),
            activities_collection.create_index("status"),
            privilege_escalation_collection.create_index("activity_id"),
            lateral_movement_collection.create_index("activity_id"),
            lateral_movement_collection.create_index("source_target_id"),
            lateral_movement_collection.create_index("destination_target_id"),
            cleanup_collection.create_index("activity_id"),
            cleanup_collection.create_index("target_id"),
        )

        self._initialized = True

    async def _ensure_initialized(self) -> None:
        """Ensure the repository is initialized."""
        if not self._initialized:
            await self.initialize()

    def _get_activities_collection(self) -> AsyncIOMotorCollection:
        """Get the activities collection with proper type casting."""
        if self._activities_collection is None:
            raise RuntimeError("Repository not initialized")
        return cast(AsyncIOMotorCollection, self._activities_collection)

    def _get_privilege_escalation_collection(self) -> AsyncIOMotorCollection:
        """Get the privilege escalation collection with proper type casting."""
        if self._privilege_escalation_collection is None:
            raise RuntimeError("Repository not initialized")
        return cast(AsyncIOMotorCollection, self._privilege_escalation_collection)

    def _get_lateral_movement_collection(self) -> AsyncIOMotorCollection:
        """Get the lateral movement collection with proper type casting."""
        if self._lateral_movement_collection is None:
            raise RuntimeError("Repository not initialized")
        return cast(AsyncIOMotorCollection, self._lateral_movement_collection)

    def _get_cleanup_collection(self) -> AsyncIOMotorCollection:
        """Get the cleanup collection with proper type casting."""
        if self._cleanup_collection is None:
            raise RuntimeError("Repository not initialized")
        return cast(AsyncIOMotorCollection, self._cleanup_collection)

    async def create_activity(
        self, activity_create: PostExploitationActivityCreate
    ) -> PostExploitationActivity:
        """Create a new post-exploitation activity.

        Args:
            activity_create: Activity creation data

        Returns:
            Created activity
        """
        await self._ensure_initialized()

        activity = PostExploitationActivity(
            type=activity_create.type,
            target_id=activity_create.target_id,
            exploit_id=activity_create.exploit_id,
            metadata=activity_create.metadata or {},
        )

        await self._get_activities_collection().insert_one(activity.model_dump())
        logger.info(f"Created post-exploitation activity: {activity.id}")
        return activity

    async def update_activity_status(
        self, activity_id: str, status: str
    ) -> Optional[PostExploitationActivity]:
        """Update the status of an activity.

        Args:
            activity_id: Activity ID
            status: New status

        Returns:
            Updated activity or None if not found
        """
        await self._ensure_initialized()

        result = await self._get_activities_collection().find_one_and_update(
            {"id": activity_id},
            {"$set": {"status": status, "timestamp": datetime.utcnow()}},
            return_document=ReturnDocument.AFTER,
        )

        if result:
            return PostExploitationActivity(**result)
        return None

    async def get_activity(
        self, activity_id: str
    ) -> Optional[PostExploitationActivity]:
        """Get an activity by ID.

        Args:
            activity_id: Activity ID

        Returns:
            Activity or None if not found
        """
        await self._ensure_initialized()

        result = await self._get_activities_collection().find_one({"id": activity_id})
        if result:
            return PostExploitationActivity(**result)
        return None

    async def get_activities_by_target(
        self, target_id: str, activity_type: Optional[PostExploitationType] = None
    ) -> List[PostExploitationActivity]:
        """Get all activities for a target.

        Args:
            target_id: Target ID
            activity_type: Optional type filter

        Returns:
            List of activities
        """
        await self._ensure_initialized()

        query: Dict[str, Any] = {"target_id": target_id}
        if activity_type:
            query["type"] = activity_type.value

        cursor = self._get_activities_collection().find(query)
        results = await cursor.to_list(length=100)
        return [PostExploitationActivity(**result) for result in results]

    async def store_privilege_escalation_result(
        self, result: PrivilegeEscalationResult
    ) -> PrivilegeEscalationResult:
        """Store a privilege escalation result.

        Args:
            result: Privilege escalation result

        Returns:
            Stored result
        """
        await self._ensure_initialized()

        # Update the activity status
        await self.update_activity_status(
            result.activity_id, "completed" if result.success else "failed"
        )

        await self._get_privilege_escalation_collection().insert_one(
            result.model_dump()
        )
        logger.info(f"Stored privilege escalation result: {result.id}")
        return result

    async def store_lateral_movement_result(
        self, result: LateralMovementResult
    ) -> LateralMovementResult:
        """Store a lateral movement result.

        Args:
            result: Lateral movement result

        Returns:
            Stored result
        """
        await self._ensure_initialized()

        # Update the activity status
        await self.update_activity_status(
            result.activity_id, "completed" if result.success else "failed"
        )

        await self._get_lateral_movement_collection().insert_one(result.model_dump())
        logger.info(f"Stored lateral movement result: {result.id}")
        return result

    async def store_cleanup_result(self, result: CleanupResult) -> CleanupResult:
        """Store a cleanup result.

        Args:
            result: Cleanup result

        Returns:
            Stored result
        """
        await self._ensure_initialized()

        # Update the activity status
        await self.update_activity_status(
            result.activity_id, "cleaned" if result.success else "cleanup_failed"
        )

        await self._get_cleanup_collection().insert_one(result.model_dump())
        logger.info(f"Stored cleanup result: {result.id}")
        return result

    async def get_privilege_escalation_result(
        self, result_id: str
    ) -> Optional[PrivilegeEscalationResult]:
        """Get a privilege escalation result by ID.

        Args:
            result_id: Result ID

        Returns:
            Result or None if not found
        """
        await self._ensure_initialized()

        result = await self._get_privilege_escalation_collection().find_one(
            {"id": result_id}
        )
        if result:
            return PrivilegeEscalationResult(**result)
        return None

    async def get_lateral_movement_result(
        self, result_id: str
    ) -> Optional[LateralMovementResult]:
        """Get a lateral movement result by ID.

        Args:
            result_id: Result ID

        Returns:
            Result or None if not found
        """
        await self._ensure_initialized()

        result = await self._get_lateral_movement_collection().find_one(
            {"id": result_id}
        )
        if result:
            return LateralMovementResult(**result)
        return None

    async def get_cleanup_result(self, result_id: str) -> Optional[CleanupResult]:
        """Get a cleanup result by ID.

        Args:
            result_id: Result ID

        Returns:
            Result or None if not found
        """
        await self._ensure_initialized()

        result = await self._get_cleanup_collection().find_one({"id": result_id})
        if result:
            return CleanupResult(**result)
        return None

    async def get_results_by_activity(
        self, activity_id: str, activity_type: PostExploitationType
    ) -> List[Union[PrivilegeEscalationResult, LateralMovementResult, CleanupResult]]:
        """Get all results for an activity.

        Args:
            activity_id: Activity ID
            activity_type: Activity type

        Returns:
            List of results
        """
        await self._ensure_initialized()

        if activity_type == PostExploitationType.PRIVILEGE_ESCALATION:
            cursor = self._get_privilege_escalation_collection().find(
                {"activity_id": activity_id}
            )
            results = await cursor.to_list(length=100)
            return [PrivilegeEscalationResult(**result) for result in results]
        elif activity_type == PostExploitationType.LATERAL_MOVEMENT:
            cursor = self._get_lateral_movement_collection().find(
                {"activity_id": activity_id}
            )
            results = await cursor.to_list(length=100)
            return [LateralMovementResult(**result) for result in results]
        elif activity_type == PostExploitationType.CLEANUP:
            cursor = self._get_cleanup_collection().find({"activity_id": activity_id})
            results = await cursor.to_list(length=100)
            return [CleanupResult(**result) for result in results]
        else:
            logger.warning(f"Unsupported activity type for results: {activity_type}")
            return []

    async def get_pending_cleanup_activities(
        self,
    ) -> List[
        Tuple[
            PostExploitationActivity,
            Union[PrivilegeEscalationResult, LateralMovementResult],
        ]
    ]:
        """Get activities that require cleanup.

        Returns:
            List of tuples with activities and their result data
        """
        await self._ensure_initialized()

        # Find completed activities that need cleanup
        cursor = self._get_activities_collection().find(
            {
                "status": "completed",
                "$or": [
                    {"type": PostExploitationType.PRIVILEGE_ESCALATION.value},
                    {"type": PostExploitationType.LATERAL_MOVEMENT.value},
                ],
            }
        )

        activities = await cursor.to_list(length=100)
        activities = [PostExploitationActivity(**activity) for activity in activities]

        result_pairs: List[
            Tuple[
                PostExploitationActivity,
                Union[PrivilegeEscalationResult, LateralMovementResult],
            ]
        ] = []
        for activity in activities:
            if activity.type == PostExploitationType.PRIVILEGE_ESCALATION:
                cursor = self._get_privilege_escalation_collection().find(
                    {"activity_id": activity.id, "cleanup_required": True}
                )
                results = await cursor.to_list(length=100)
                for result in results:
                    result_pairs.append((activity, PrivilegeEscalationResult(**result)))
            elif activity.type == PostExploitationType.LATERAL_MOVEMENT:
                cursor = self._get_lateral_movement_collection().find(
                    {"activity_id": activity.id, "cleanup_required": True}
                )
                results = await cursor.to_list(length=100)
                for result in results:
                    result_pairs.append((activity, LateralMovementResult(**result)))

        return result_pairs

    # Mock methods to support the service layer without dependencies
    async def get_target(self, target_id: str) -> Optional[Target]:
        """Get a target by ID (mock implementation).

        In a real implementation, this would call the reconnaissance service.

        Args:
            target_id: Target ID

        Returns:
            Target or None if not found
        """
        # Return a mock target for testing
        return Target(
            id=target_id,
            name=f"Target-{target_id}",
            hostname=f"host-{target_id}",
            ip_address="192.168.1.100",
            status="active",
            scan_id=1,
            metadata={"os": "Linux"},
        )

    async def get_result(self, exploit_id: str) -> Optional[ExploitResult]:
        """Get an exploit result by ID (mock implementation).

        In a real implementation, this would call the exploitation service.

        Args:
            exploit_id: Exploit ID

        Returns:
            ExploitResult or None if not found
        """
        # Return a mock result for testing
        return ExploitResult(
            success=True,
            message=f"Exploit {exploit_id} executed successfully",
            raw_output="Command executed with output: success",
            extracted_data={"user": "root", "privileges": "elevated"},
        )
