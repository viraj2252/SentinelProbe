"""Lateral movement techniques for post-exploitation."""

import asyncio
import ipaddress
import random
from typing import Any, Dict, List

from sentinelprobe.core.logging import get_logger
from sentinelprobe.exploitation.models import ExploitResult
from sentinelprobe.post_exploitation.models import (
    LateralMovementResult,
    LateralMovementTarget,
    PostExploitationActivity,
    PostExploitationConfig,
    PostExploitationType,
    PrivilegeLevel,
)
from sentinelprobe.post_exploitation.service import PostExploitationTechnique
from sentinelprobe.reconnaissance.models import Target

logger = get_logger(__name__)


class SSHKeyBasedLateralMovement(PostExploitationTechnique):
    """SSH key-based lateral movement technique."""

    @property
    def name(self) -> str:
        """Get the name of the technique."""
        return "SSHKeyBasedLateralMovement"

    @property
    def description(self) -> str:
        """Get the description of the technique."""
        return "Attempts to move laterally using discovered SSH keys."

    @property
    def type(self) -> PostExploitationType:
        """Get the type of post-exploitation activity."""
        return PostExploitationType.LATERAL_MOVEMENT

    async def execute(
        self,
        activity: PostExploitationActivity,
        target: Target,
        exploit_result: ExploitResult,
        config: PostExploitationConfig,
        parameters: Dict[str, Any],
    ) -> LateralMovementResult:
        """Execute the lateral movement.

        Args:
            activity: Post-exploitation activity
            target: Target to execute on
            exploit_result: Result of the exploit
            config: Post-exploitation configuration
            parameters: Technique-specific parameters

        Returns:
            Lateral movement result
        """
        # In a real implementation, we would search for SSH keys and attempt to use
        # them to access other systems. For now, we'll simulate the process.

        # Add a slight delay to simulate the execution time
        await asyncio.sleep(1.2)

        # Generate realistic potential targets based on the current target's IP
        potential_targets = self._generate_potential_targets(target)
        discovered_targets = []

        # For demonstration purposes, we'll simulate success based on severity
        success_probability = 0.6  # Default: 60% chance of success

        # Success more likely on vulnerable systems with higher severity exploits
        if exploit_result.vulnerability and getattr(
            exploit_result.vulnerability, "severity", None
        ):
            severity_factor = {
                "critical": 0.9,
                "high": 0.7,
                "medium": 0.5,
                "low": 0.3,
                "info": 0.1,
            }.get(exploit_result.vulnerability.severity.lower(), 0.6)
            success_probability = severity_factor

        # Simulate success based on probability
        success = random.random() < success_probability

        # Commands that would be executed on a real system
        commands_executed = [
            "find / -name id_rsa 2>/dev/null",  # Find SSH private keys
            "cat ~/.ssh/id_rsa",  # Read private key
            "cat ~/.ssh/known_hosts",  # Get known hosts
            "grep -r 'Host ' ~/.ssh/config",  # Find SSH config entries
            f"ssh -i ~/.ssh/id_rsa user@{potential_targets[0].ip_address}",  # Attempt SSH connection
        ]

        # Cleanup commands that would be needed after exploitation
        cleanup_commands = ["rm -f ~/.ssh/lateral_movement_log"]

        if success:
            # Simulate finding 1-3 new targets that are accessible
            num_discovered = random.randint(1, min(3, len(potential_targets)))
            discovered_targets = potential_targets[:num_discovered]

            details = f"Successfully moved laterally to {num_discovered} new target(s) using SSH key"
            output = f"""
[*] Searching for SSH keys...
[+] Found private key at /home/user/.ssh/id_rsa
[*] Analyzing SSH config and known hosts...
[+] Found {len(potential_targets)} potential targets
[*] Attempting connections...
"""

            for discovered_target in discovered_targets:
                output += f"[+] Successfully connected to {discovered_target.hostname} ({discovered_target.ip_address})\n"

            output += """
[*] Running post-connection checks...
[+] Established persistence on discovered targets
"""
        else:
            details = "Failed to move laterally using SSH key-based technique"
            output = """
[*] Searching for SSH keys...
[+] Found private key at /home/user/.ssh/id_rsa
[*] Analyzing SSH config and known hosts...
[+] Found potential targets
[*] Attempting connections...
[-] Connection failed: Permission denied (publickey)
[*] Trying alternative credentials...
[-] All connection attempts failed
"""

        # Create and return the result
        result = LateralMovementResult(
            activity_id=activity.id,
            success=success,
            source_target_id=str(target.id),
            destination_target_id=(
                discovered_targets[0].target_id if discovered_targets else ""
            ),
            technique_used="SSH key-based lateral movement",
            details=details,
            commands_executed=commands_executed,
            output=output,
            new_targets_discovered=discovered_targets,
            cleanup_required=True,
            cleanup_commands=cleanup_commands,
        )

        return result

    def _generate_potential_targets(
        self, source_target: Target
    ) -> List[LateralMovementTarget]:
        """Generate potential targets for lateral movement.

        Args:
            source_target: Source target

        Returns:
            List of potential targets
        """
        potential_targets: List[LateralMovementTarget] = []

        # Parse the source target's IP address
        try:
            if not source_target.ip_address:
                return potential_targets

            ip = ipaddress.IPv4Address(source_target.ip_address)
            network = ipaddress.IPv4Network(f"{ip}/24", strict=False)

            # Generate a few targets in the same subnet
            for i in range(1, 6):
                # Skip the source target
                new_ip = network.network_address + (int(ip) % 256 + i) % 254 + 1
                if str(new_ip) == source_target.ip_address:
                    continue

                hostname = f"host-{new_ip}"

                # Create a target in the same network
                potential_targets.append(
                    LateralMovementTarget(
                        target_id=f"lm-target-{i}",
                        hostname=hostname,
                        ip_address=str(new_ip),
                        access_method="ssh",
                        privilege_level=PrivilegeLevel.USER,
                    )
                )
        except (ValueError, TypeError) as e:
            logger.warning(f"Error generating potential targets: {e}")

        return potential_targets


class WindowsWmiLateralMovement(PostExploitationTechnique):
    """Windows WMI-based lateral movement technique."""

    @property
    def name(self) -> str:
        """Get the name of the technique."""
        return "WindowsWmiLateralMovement"

    @property
    def description(self) -> str:
        """Get the description of the technique."""
        return "Attempts to move laterally using Windows WMI."

    @property
    def type(self) -> PostExploitationType:
        """Get the type of post-exploitation activity."""
        return PostExploitationType.LATERAL_MOVEMENT

    async def execute(
        self,
        activity: PostExploitationActivity,
        target: Target,
        exploit_result: ExploitResult,
        config: PostExploitationConfig,
        parameters: Dict[str, Any],
    ) -> LateralMovementResult:
        """Execute the lateral movement.

        Args:
            activity: Post-exploitation activity
            target: Target to execute on
            exploit_result: Result of the exploit
            config: Post-exploitation configuration
            parameters: Technique-specific parameters

        Returns:
            Lateral movement result
        """
        # In a real implementation, we would attempt to use WMI to execute commands
        # on remote Windows systems. For now, we'll simulate the process.

        # Add a slight delay to simulate the execution time
        await asyncio.sleep(1.5)

        # Generate realistic potential targets based on the current target's IP
        potential_targets = self._generate_potential_targets(target)
        discovered_targets = []

        # For demonstration purposes, we'll simulate success based on severity
        success_probability = 0.5  # Default: 50% chance of success

        # Success more likely on vulnerable systems with higher severity exploits
        if exploit_result.vulnerability and getattr(
            exploit_result.vulnerability, "severity", None
        ):
            severity_factor = {
                "critical": 0.8,
                "high": 0.6,
                "medium": 0.4,
                "low": 0.2,
                "info": 0.1,
            }.get(exploit_result.vulnerability.severity.lower(), 0.5)
            success_probability = severity_factor

        # Simulate success based on probability
        success = random.random() < success_probability

        # Commands that would be executed on a real system
        target_ip = (
            potential_targets[0].ip_address if potential_targets else "192.168.1.5"
        )
        commands_executed = [
            "net view",  # View available network shares
            "net user",  # List users
            f'wmic /node:"{target_ip}" process call create "cmd.exe /c whoami > C:\\\\Users\\\\Public\\\\result.txt"',
            f"dir \\\\{target_ip}\\C$",  # List files on remote system
            f"copy exfil.txt \\\\{target_ip}\\C$\\Users\\Public\\",  # Copy file to remote system
        ]

        # Cleanup commands that would be needed after exploitation
        cleanup_commands = [
            f'wmic /node:"{target_ip}" process call create "cmd.exe /c del C:\\\\Users\\\\Public\\\\result.txt"',
            f"del \\\\{target_ip}\\C$\\Users\\Public\\exfil.txt",
        ]

        if success:
            # Simulate finding 1-2 new targets that are accessible
            num_discovered = random.randint(1, min(2, len(potential_targets)))
            discovered_targets = potential_targets[:num_discovered]

            details = f"Successfully moved laterally to {num_discovered} new target(s) using WMI"
            output = f"""
[*] Enumerating network resources...
[+] Found {len(potential_targets)} potential targets
[*] Checking WMI access...
[+] WMI access available on {num_discovered} target(s)
[*] Executing commands via WMI...
Process id 1234 created.
[*] Verifying command execution...
Directory of \\\\{target_ip}\\C$\\Users\\Public\\

04/10/2023  10:15 AM    <DIR>          .
04/10/2023  10:15 AM    <DIR>          ..
04/10/2023  10:15 AM                23 result.txt
               1 File(s)             23 bytes

[*] Accessing command output...
[+] Command executed successfully as SYSTEM
[*] Establishing persistence...
[+] Persistence established
"""
        else:
            details = "Failed to move laterally using WMI technique"
            output = f"""
[*] Enumerating network resources...
[+] Found {len(potential_targets)} potential targets
[*] Checking WMI access...
[-] Access denied: The RPC server is unavailable
[*] Trying alternative credentials...
[-] Access denied: Username or password is incorrect
[*] Trying DCOM instead of WMI...
[-] Access denied: The network path was not found
"""

        # Create and return the result
        result = LateralMovementResult(
            activity_id=activity.id,
            success=success,
            source_target_id=str(target.id),
            destination_target_id=(
                discovered_targets[0].target_id if discovered_targets else ""
            ),
            technique_used="Windows WMI lateral movement",
            details=details,
            commands_executed=commands_executed,
            output=output,
            new_targets_discovered=discovered_targets,
            cleanup_required=True,
            cleanup_commands=cleanup_commands,
        )

        return result

    def _generate_potential_targets(
        self, source_target: Target
    ) -> List[LateralMovementTarget]:
        """Generate potential targets for lateral movement.

        Args:
            source_target: Source target

        Returns:
            List of potential targets
        """
        potential_targets: List[LateralMovementTarget] = []

        # Parse the source target's IP address
        try:
            if not source_target.ip_address:
                return potential_targets

            ip = ipaddress.IPv4Address(source_target.ip_address)
            network = ipaddress.IPv4Network(f"{ip}/24", strict=False)

            # Generate a few targets in the same subnet
            for i in range(1, 4):
                # Skip the source target
                new_ip = network.network_address + (int(ip) % 256 + i) % 254 + 1
                if str(new_ip) == source_target.ip_address:
                    continue

                hostname = f"WINHOST-{i}"

                # Create a target in the same network
                potential_targets.append(
                    LateralMovementTarget(
                        target_id=f"lm-win-target-{i}",
                        hostname=hostname,
                        ip_address=str(new_ip),
                        access_method="wmi",
                        privilege_level=PrivilegeLevel.SYSTEM,
                    )
                )
        except (ValueError, TypeError) as e:
            logger.warning(f"Error generating potential targets: {e}")

        return potential_targets
