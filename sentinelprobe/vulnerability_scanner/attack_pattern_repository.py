"""Repository for attack pattern database operations."""

import datetime
from typing import List, Optional, Tuple

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.vulnerability_scanner.attack_patterns import (
    AttackPattern,
    AttackPatternCreate,
    AttackPatternUpdate,
    AttackType,
    VulnerabilityAttackPatternMapping,
    VulnerabilityAttackPatternMappingCreate,
)
from sentinelprobe.vulnerability_scanner.models import Vulnerability


class AttackPatternRepository:
    """Repository for attack patterns."""

    def __init__(self, session: AsyncSession):
        """Initialize with database session.

        Args:
            session: SQLAlchemy async session
        """
        self.session = session

    async def create_attack_pattern(
        self, attack_pattern_data: AttackPatternCreate
    ) -> AttackPattern:
        """Create a new attack pattern.

        Args:
            attack_pattern_data: Attack pattern data

        Returns:
            Created attack pattern
        """
        db_attack_pattern = AttackPattern(
            name=attack_pattern_data.name,
            description=attack_pattern_data.description,
            attack_type=attack_pattern_data.attack_type,
            attack_vector=attack_pattern_data.attack_vector,
            typical_severity=attack_pattern_data.typical_severity,
            mitre_id=attack_pattern_data.mitre_id,
            capec_id=attack_pattern_data.capec_id,
            cwe_ids=attack_pattern_data.cwe_ids,
            pattern_details=attack_pattern_data.pattern_details,
            pattern_indicators=attack_pattern_data.pattern_indicators,
            detection_guidance=attack_pattern_data.detection_guidance,
            remediation_guidance=attack_pattern_data.remediation_guidance,
        )
        self.session.add(db_attack_pattern)
        await self.session.flush()
        await self.session.refresh(db_attack_pattern)
        return db_attack_pattern

    async def get_attack_pattern(
        self, attack_pattern_id: int
    ) -> Optional[AttackPattern]:
        """Get an attack pattern by ID.

        Args:
            attack_pattern_id: Attack pattern ID

        Returns:
            AttackPattern or None if not found
        """
        result = await self.session.execute(
            select(AttackPattern).where(AttackPattern.id == attack_pattern_id)
        )
        attack_pattern: Optional[AttackPattern] = result.scalars().first()
        return attack_pattern

    async def get_attack_pattern_by_name(self, name: str) -> Optional[AttackPattern]:
        """Get an attack pattern by name.

        Args:
            name: Attack pattern name

        Returns:
            AttackPattern or None if not found
        """
        result = await self.session.execute(
            select(AttackPattern).where(AttackPattern.name == name)
        )
        attack_pattern: Optional[AttackPattern] = result.scalars().first()
        return attack_pattern

    async def get_attack_pattern_by_mitre_id(
        self, mitre_id: str
    ) -> Optional[AttackPattern]:
        """Get an attack pattern by MITRE ID.

        Args:
            mitre_id: MITRE ATT&CK ID

        Returns:
            AttackPattern or None if not found
        """
        result = await self.session.execute(
            select(AttackPattern).where(AttackPattern.mitre_id == mitre_id)
        )
        attack_pattern: Optional[AttackPattern] = result.scalars().first()
        return attack_pattern

    async def get_attack_pattern_by_capec_id(
        self, capec_id: str
    ) -> Optional[AttackPattern]:
        """Get an attack pattern by CAPEC ID.

        Args:
            capec_id: CAPEC ID

        Returns:
            AttackPattern or None if not found
        """
        result = await self.session.execute(
            select(AttackPattern).where(AttackPattern.capec_id == capec_id)
        )
        attack_pattern: Optional[AttackPattern] = result.scalars().first()
        return attack_pattern

    async def get_all_attack_patterns(self) -> List[AttackPattern]:
        """Get all attack patterns.

        Returns:
            List of all attack patterns
        """
        result = await self.session.execute(select(AttackPattern))
        return list(result.scalars().all())

    async def get_attack_patterns_by_type(
        self, attack_type: AttackType
    ) -> List[AttackPattern]:
        """Get attack patterns by type.

        Args:
            attack_type: Attack type

        Returns:
            List of attack patterns matching the specified type
        """
        result = await self.session.execute(
            select(AttackPattern).where(AttackPattern.attack_type == attack_type)
        )
        return list(result.scalars().all())

    async def get_attack_patterns_by_cwe(self, cwe_id: str) -> List[AttackPattern]:
        """Get attack patterns by CWE ID.

        Args:
            cwe_id: Common Weakness Enumeration ID

        Returns:
            List of attack patterns related to the specified CWE
        """
        # Note: This is a simplistic approach; in a real-world scenario,
        # we'd need a more sophisticated JSON query
        result = await self.session.execute(
            select(AttackPattern).where(AttackPattern.cwe_ids.contains([cwe_id]))
        )
        return list(result.scalars().all())

    async def update_attack_pattern(
        self, attack_pattern_id: int, attack_pattern_data: AttackPatternUpdate
    ) -> Optional[AttackPattern]:
        """Update an attack pattern.

        Args:
            attack_pattern_id: Attack pattern ID
            attack_pattern_data: Attack pattern update data

        Returns:
            Updated attack pattern or None if not found
        """
        db_attack_pattern = await self.get_attack_pattern(attack_pattern_id)
        if not db_attack_pattern:
            return None

        # Update fields if provided
        update_data = attack_pattern_data.dict(exclude_unset=True)
        for key, value in update_data.items():
            setattr(db_attack_pattern, key, value)

        db_attack_pattern.updated_at = datetime.datetime.utcnow()
        self.session.add(db_attack_pattern)
        await self.session.flush()
        await self.session.refresh(db_attack_pattern)
        return db_attack_pattern

    async def delete_attack_pattern(self, attack_pattern_id: int) -> bool:
        """Delete an attack pattern.

        Args:
            attack_pattern_id: Attack pattern ID

        Returns:
            True if deleted, False if not found
        """
        db_attack_pattern = await self.get_attack_pattern(attack_pattern_id)
        if not db_attack_pattern:
            return False

        await self.session.delete(db_attack_pattern)
        await self.session.flush()
        return True

    async def create_vulnerability_attack_pattern_mapping(
        self, mapping_data: VulnerabilityAttackPatternMappingCreate
    ) -> VulnerabilityAttackPatternMapping:
        """Create a mapping between a vulnerability and an attack pattern.

        Args:
            mapping_data: Mapping data

        Returns:
            Created mapping
        """
        db_mapping = VulnerabilityAttackPatternMapping(
            vulnerability_id=mapping_data.vulnerability_id,
            attack_pattern_id=mapping_data.attack_pattern_id,
            match_confidence=mapping_data.match_confidence,
            match_details=mapping_data.match_details,
        )
        self.session.add(db_mapping)
        await self.session.flush()
        await self.session.refresh(db_mapping)
        return db_mapping

    async def get_vulnerability_attack_patterns(
        self, vulnerability_id: int
    ) -> List[Tuple[AttackPattern, float]]:
        """Get attack patterns associated with a vulnerability.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            List of tuples containing (attack_pattern, confidence)
        """
        query = (
            select(VulnerabilityAttackPatternMapping, AttackPattern)
            .join(
                AttackPattern,
                VulnerabilityAttackPatternMapping.attack_pattern_id == AttackPattern.id,
            )
            .where(
                VulnerabilityAttackPatternMapping.vulnerability_id == vulnerability_id
            )
        )

        result = await self.session.execute(query)
        mappings = result.fetchall()

        return [
            (row.AttackPattern, row.VulnerabilityAttackPatternMapping.match_confidence)
            for row in mappings
        ]

    async def get_attack_pattern_vulnerabilities(
        self, attack_pattern_id: int
    ) -> List[Tuple[Vulnerability, float]]:
        """Get vulnerabilities associated with an attack pattern.

        Args:
            attack_pattern_id: Attack pattern ID

        Returns:
            List of tuples containing (vulnerability, confidence)
        """
        query = (
            select(VulnerabilityAttackPatternMapping, Vulnerability)
            .join(
                Vulnerability,
                VulnerabilityAttackPatternMapping.vulnerability_id == Vulnerability.id,
            )
            .where(
                VulnerabilityAttackPatternMapping.attack_pattern_id == attack_pattern_id
            )
        )

        result = await self.session.execute(query)
        mappings = result.fetchall()

        return [
            (row.Vulnerability, row.VulnerabilityAttackPatternMapping.match_confidence)
            for row in mappings
        ]

    async def match_vulnerability_to_attack_patterns(
        self, vulnerability: Vulnerability
    ) -> List[Tuple[AttackPattern, float]]:
        """Match a vulnerability to attack patterns based on its characteristics.

        Args:
            vulnerability: Vulnerability to match

        Returns:
            List of tuples containing (attack_pattern, confidence_score)
        """
        # Get all attack patterns
        attack_patterns = await self.get_all_attack_patterns()

        # Match vulnerability to attack patterns
        matches: List[Tuple[AttackPattern, float]] = []
        for pattern in attack_patterns:
            # Calculate confidence score based on various factors
            confidence = self._calculate_pattern_match_confidence(
                vulnerability, pattern
            )
            if confidence > 0.5:  # Only include matches with confidence > 50%
                matches.append((pattern, confidence))

        # Sort by confidence score in descending order
        matches.sort(key=lambda x: x[1], reverse=True)

        return matches

    def _calculate_pattern_match_confidence(
        self, vulnerability: Vulnerability, pattern: AttackPattern
    ) -> float:
        """Calculate confidence level for a vulnerability matching an attack pattern.

        This is a simple implementation. In a real-world scenario, this would be more
        sophisticated, possibly using ML/NLP techniques.

        Args:
            vulnerability: The vulnerability
            pattern: The attack pattern

        Returns:
            Confidence level (0-100)
        """
        confidence = 0.0

        # Match by CWE IDs
        if vulnerability.details.get("cwe_id") in pattern.cwe_ids:
            confidence += 40

        # Match by severity
        if vulnerability.severity == pattern.typical_severity:
            confidence += 10

        # Simple name/description text matching
        if pattern.name.lower() in vulnerability.name.lower():
            confidence += 20

        if pattern.name.lower() in vulnerability.description.lower():
            confidence += 15

        # Pattern-specific indicators
        for indicator_key, indicator_value in pattern.pattern_indicators.items():
            if (
                isinstance(indicator_value, str)
                and vulnerability.details.get(indicator_key, "").lower()
                == indicator_value.lower()
            ):
                confidence += 15

        # Cap at 100%
        return min(confidence, 100.0)
