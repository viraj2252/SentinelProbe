"""Data synchronization module for the vulnerability scanner."""

import logging
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.core.mongodb import find_many, find_one, insert_one, update_one
from sentinelprobe.vulnerability_scanner.attack_pattern_repository import (
    AttackPatternRepository,
)
from sentinelprobe.vulnerability_scanner.repository import (
    VulnerabilityRepository,
    VulnerabilityScanRepository,
)

logger = logging.getLogger(__name__)


class VulnerabilityDataSynchronizer:
    """Synchronizes vulnerability data between PostgreSQL and MongoDB."""

    def __init__(self, session: AsyncSession):
        """Initialize with database session.

        Args:
            session: SQLAlchemy async session
        """
        self.session = session
        self.scan_repo = VulnerabilityScanRepository(session)
        self.vulnerability_repo = VulnerabilityRepository(session)
        self.attack_pattern_repo = AttackPatternRepository(session)

    async def sync_vulnerability_to_mongodb(
        self, vulnerability_id: int
    ) -> Tuple[bool, Optional[str]]:
        """Synchronize a vulnerability from PostgreSQL to MongoDB.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            Tuple containing success status and MongoDB document ID if successful
        """
        # Get vulnerability from PostgreSQL
        vulnerability = await self.vulnerability_repo.get_vulnerability(
            vulnerability_id
        )
        if not vulnerability:
            logger.error(f"Vulnerability with ID {vulnerability_id} not found")
            return False, None

        # Get associated attack patterns
        attack_patterns = (
            await self.attack_pattern_repo.get_vulnerability_attack_patterns(
                vulnerability_id
            )
        )

        # Prepare document for MongoDB
        document: Dict[str, Any] = {
            "vulnerability_id": vulnerability.id,
            "scan_id": vulnerability.scan_id,
            "target_id": vulnerability.target_id,
            "name": vulnerability.name,
            "description": vulnerability.description,
            "severity": vulnerability.severity.value,
            "status": vulnerability.status.value,
            "cve_id": vulnerability.cve_id,
            "cvss_score": vulnerability.cvss_score,
            "affected_component": vulnerability.affected_component,
            "port_number": vulnerability.port_number,
            "protocol": vulnerability.protocol,
            "details": vulnerability.details,
            "remediation": vulnerability.remediation,
            "created_at": vulnerability.created_at.isoformat(),
            "updated_at": vulnerability.updated_at.isoformat(),
            "attack_patterns": [
                {
                    "id": pattern.id,
                    "name": pattern.name,
                    "attack_type": pattern.attack_type.value,
                    "confidence": confidence,
                    "mitre_id": pattern.mitre_id,
                    "capec_id": pattern.capec_id,
                }
                for pattern, confidence in attack_patterns
            ],
        }

        # Check if document already exists in MongoDB
        existing_doc = await find_one(
            "vulnerabilities", {"vulnerability_id": vulnerability.id}
        )

        if existing_doc:
            # Update existing document
            await update_one(
                "vulnerabilities", {"vulnerability_id": vulnerability.id}, document
            )
            return True, str(existing_doc["_id"])
        else:
            # Insert new document
            doc_id = await insert_one("vulnerabilities", document)
            return True, doc_id

    async def sync_all_vulnerabilities_to_mongodb(
        self,
    ) -> List[Tuple[int, bool, Optional[str]]]:
        """Synchronize all vulnerabilities from PostgreSQL to MongoDB.

        Returns:
            List of tuples containing (vulnerability_id, success, mongodb_id)
        """
        # Get all vulnerabilities from PostgreSQL
        all_vulnerabilities = []
        all_scans = await self.scan_repo.get_all_scans()

        for scan in all_scans:
            vulnerabilities = await self.vulnerability_repo.get_vulnerabilities_by_scan(
                scan.id
            )
            all_vulnerabilities.extend(vulnerabilities)

        # Sync each vulnerability
        results = []
        for vulnerability in all_vulnerabilities:
            success, mongo_id = await self.sync_vulnerability_to_mongodb(
                vulnerability.id
            )
            results.append((vulnerability.id, success, mongo_id))

        return results

    async def sync_attack_pattern_to_mongodb(
        self, attack_pattern_id: int
    ) -> Tuple[bool, Optional[str]]:
        """Synchronize an attack pattern from PostgreSQL to MongoDB.

        Args:
            attack_pattern_id: Attack pattern ID

        Returns:
            Tuple containing success status and MongoDB document ID if successful
        """
        # Get attack pattern from PostgreSQL
        attack_pattern = await self.attack_pattern_repo.get_attack_pattern(
            attack_pattern_id
        )
        if not attack_pattern:
            logger.error(f"Attack pattern with ID {attack_pattern_id} not found")
            return False, None

        # Prepare document for MongoDB
        document: Dict[str, Any] = {
            "attack_pattern_id": attack_pattern.id,
            "name": attack_pattern.name,
            "description": attack_pattern.description,
            "attack_type": attack_pattern.attack_type.value,
            "attack_vector": attack_pattern.attack_vector.value,
            "typical_severity": attack_pattern.typical_severity.value,
            "mitre_id": attack_pattern.mitre_id,
            "capec_id": attack_pattern.capec_id,
            "cwe_ids": attack_pattern.cwe_ids,
            "pattern_details": attack_pattern.pattern_details,
            "pattern_indicators": attack_pattern.pattern_indicators,
            "detection_guidance": attack_pattern.detection_guidance,
            "remediation_guidance": attack_pattern.remediation_guidance,
            "created_at": attack_pattern.created_at.isoformat(),
            "updated_at": attack_pattern.updated_at.isoformat(),
        }

        # Check if document already exists in MongoDB
        existing_doc = await find_one(
            "attack_patterns", {"attack_pattern_id": attack_pattern.id}
        )

        if existing_doc:
            # Update existing document
            await update_one(
                "attack_patterns", {"attack_pattern_id": attack_pattern.id}, document
            )
            return True, str(existing_doc["_id"])
        else:
            # Insert new document
            doc_id = await insert_one("attack_patterns", document)
            return True, doc_id

    async def sync_all_attack_patterns_to_mongodb(
        self,
    ) -> List[Tuple[int, bool, Optional[str]]]:
        """Synchronize all attack patterns from PostgreSQL to MongoDB.

        Returns:
            List of tuples containing (attack_pattern_id, success, mongodb_id)
        """
        # Get all attack patterns from PostgreSQL
        attack_patterns = await self.attack_pattern_repo.get_all_attack_patterns()

        # Sync each attack pattern
        results = []
        for pattern in attack_patterns:
            success, mongo_id = await self.sync_attack_pattern_to_mongodb(pattern.id)
            results.append((pattern.id, success, mongo_id))

        return results

    async def get_mongodb_vulnerability(
        self, vulnerability_id: int
    ) -> Optional[Dict[str, Any]]:
        """Get a vulnerability from MongoDB.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            MongoDB document or None if not found
        """
        return await find_one("vulnerabilities", {"vulnerability_id": vulnerability_id})

    async def get_mongodb_attack_pattern(
        self, attack_pattern_id: int
    ) -> Optional[Dict[str, Any]]:
        """Get an attack pattern from MongoDB.

        Args:
            attack_pattern_id: Attack pattern ID

        Returns:
            MongoDB document or None if not found
        """
        return await find_one(
            "attack_patterns", {"attack_pattern_id": attack_pattern_id}
        )

    async def get_mongodb_vulnerabilities_by_severity(
        self, severity: str, limit: int = 100
    ) -> List[Dict[str, Any]]:
        """Get vulnerabilities from MongoDB by severity.

        Args:
            severity: Vulnerability severity
            limit: Maximum number of documents to return

        Returns:
            List of MongoDB documents
        """
        return await find_many("vulnerabilities", {"severity": severity}, limit)

    async def get_mongodb_attack_patterns_by_type(
        self, attack_type: str, limit: int = 100
    ) -> List[Dict[str, Any]]:
        """Get attack patterns from MongoDB by type.

        Args:
            attack_type: Attack type
            limit: Maximum number of documents to return

        Returns:
            List of MongoDB documents
        """
        return await find_many("attack_patterns", {"attack_type": attack_type}, limit)

    async def get_full_vulnerability_data(
        self, vulnerability_id: int
    ) -> Optional[Dict[str, Any]]:
        """Get comprehensive vulnerability data from both PostgreSQL and MongoDB.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            Dictionary containing combined data or None if not found
        """
        # Get vulnerability from PostgreSQL
        vulnerability = await self.vulnerability_repo.get_vulnerability(
            vulnerability_id
        )
        if not vulnerability:
            return None

        # Get MongoDB data for enrichment
        mongo_data = await self.get_mongodb_vulnerability(vulnerability_id)

        # Combine data
        result = {
            "id": vulnerability.id,
            "scan_id": vulnerability.scan_id,
            "target_id": vulnerability.target_id,
            "name": vulnerability.name,
            "description": vulnerability.description,
            "severity": vulnerability.severity.value,
            "status": vulnerability.status.value,
            "cve_id": vulnerability.cve_id,
            "cvss_score": vulnerability.cvss_score,
            "affected_component": vulnerability.affected_component,
            "details": vulnerability.details,
            "remediation": vulnerability.remediation,
            "created_at": vulnerability.created_at.isoformat(),
            "updated_at": vulnerability.updated_at.isoformat(),
            "attack_patterns": [],
        }

        # Add attack patterns if available
        attack_patterns = (
            await self.attack_pattern_repo.get_vulnerability_attack_patterns(
                vulnerability_id
            )
        )
        result["attack_patterns"] = [
            {
                "id": pattern.id,
                "name": pattern.name,
                "attack_type": pattern.attack_type.value,
                "confidence": confidence,
                "mitre_id": pattern.mitre_id,
                "capec_id": pattern.capec_id,
            }
            for pattern, confidence in attack_patterns
        ]

        # Add MongoDB enrichment data if available
        if mongo_data:
            result["mongodb_id"] = str(mongo_data["_id"])

            # Add any additional fields from MongoDB not in PostgreSQL
            for key, value in mongo_data.items():
                if key not in ["_id", "vulnerability_id"] and key not in result:
                    result[f"enriched_{key}"] = value

        return result
