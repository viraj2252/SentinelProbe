"""Repository classes for the Vulnerability Scanner module."""

from datetime import datetime
from typing import Any, Dict, List, Optional

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.vulnerability_scanner.models import (
    ScanStatus,
    Vulnerability,
    VulnerabilityCreate,
    VulnerabilityScan,
    VulnerabilityScanCreate,
    VulnerabilityScanUpdate,
    VulnerabilityUpdate,
)


class VulnerabilityScanRepository:
    """Repository for vulnerability scans."""

    def __init__(self, session: AsyncSession):
        """Initialize with database session.

        Args:
            session: SQLAlchemy async session
        """
        self.session = session

    async def create_scan(
        self, scan_data: VulnerabilityScanCreate
    ) -> VulnerabilityScan:
        """Create a new vulnerability scan.

        Args:
            scan_data: Vulnerability scan data

        Returns:
            Created vulnerability scan
        """
        db_scan = VulnerabilityScan(
            job_id=scan_data.job_id,
            target_id=scan_data.target_id,
            strategy_id=scan_data.strategy_id,
            name=scan_data.name,
            description=scan_data.description,
            scan_type=scan_data.scan_type,
            status=ScanStatus.PENDING,
            scanner_module=scan_data.scanner_module,
            parameters=scan_data.parameters,
            scan_metadata=scan_data.scan_metadata,
        )
        self.session.add(db_scan)
        await self.session.flush()
        await self.session.refresh(db_scan)
        return db_scan

    async def get_scan(self, scan_id: int) -> Optional[VulnerabilityScan]:
        """Get a vulnerability scan by ID.

        Args:
            scan_id: Vulnerability scan ID

        Returns:
            Vulnerability scan or None if not found
        """
        result = await self.session.execute(
            select(VulnerabilityScan).where(VulnerabilityScan.id == scan_id)
        )
        scan: Optional[VulnerabilityScan] = result.scalars().first()
        return scan

    async def get_scan_by_name(self, name: str) -> Optional[VulnerabilityScan]:
        """Get a scan by name.

        Args:
            name: Scan name

        Returns:
            VulnerabilityScan or None if not found
        """
        result = await self.session.execute(
            select(VulnerabilityScan).where(VulnerabilityScan.name == name)
        )
        scan: Optional[VulnerabilityScan] = result.scalars().first()
        return scan

    async def get_all_scans(self) -> List[VulnerabilityScan]:
        """Get all vulnerability scans.

        Returns:
            List of all vulnerability scans
        """
        result = await self.session.execute(select(VulnerabilityScan))
        return list(result.scalars().all())

    async def get_scans_by_job(self, job_id: int) -> List[VulnerabilityScan]:
        """Get vulnerability scans by job ID.

        Args:
            job_id: Job ID

        Returns:
            List of vulnerability scans for the job
        """
        result = await self.session.execute(
            select(VulnerabilityScan).where(VulnerabilityScan.job_id == job_id)
        )
        return list(result.scalars().all())

    async def get_scans_by_target(self, target_id: int) -> List[VulnerabilityScan]:
        """Get vulnerability scans by target ID.

        Args:
            target_id: Target ID

        Returns:
            List of vulnerability scans for the target
        """
        result = await self.session.execute(
            select(VulnerabilityScan).where(VulnerabilityScan.target_id == target_id)
        )
        return list(result.scalars().all())

    async def get_scans_by_status(
        self, status: ScanStatus, job_id: Optional[int] = None
    ) -> List[VulnerabilityScan]:
        """Get vulnerability scans by status.

        Args:
            status: Scan status
            job_id: Optional job ID to filter by

        Returns:
            List of vulnerability scans
        """
        query = select(VulnerabilityScan).where(VulnerabilityScan.status == status)
        if job_id is not None:
            query = query.where(VulnerabilityScan.job_id == job_id)
        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def update_scan(
        self, scan_id: int, scan_data: VulnerabilityScanUpdate
    ) -> Optional[VulnerabilityScan]:
        """Update a vulnerability scan.

        Args:
            scan_id: Vulnerability scan ID
            scan_data: Vulnerability scan update data

        Returns:
            Updated vulnerability scan or None if not found
        """
        db_scan = await self.get_scan(scan_id)
        if not db_scan:
            return None

        # Update fields if provided
        update_data = scan_data.dict(exclude_unset=True)
        for key, value in update_data.items():
            setattr(db_scan, key, value)

        db_scan.updated_at = datetime.utcnow()
        self.session.add(db_scan)
        await self.session.flush()
        await self.session.refresh(db_scan)
        return db_scan

    async def update_scan_status(
        self,
        scan_id: int,
        status: ScanStatus,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Optional[VulnerabilityScan]:
        """Update a vulnerability scan status.

        Args:
            scan_id: Vulnerability scan ID
            status: New scan status
            metadata: Optional metadata to update

        Returns:
            Updated vulnerability scan or None if not found
        """
        db_scan = await self.get_scan(scan_id)
        if not db_scan:
            return None

        db_scan.status = status
        if metadata:
            db_scan.scan_metadata = {**db_scan.scan_metadata, **metadata}

        # Update timestamps based on status
        if status == ScanStatus.RUNNING and not db_scan.start_time:
            db_scan.start_time = datetime.utcnow()
        elif status in [ScanStatus.COMPLETED, ScanStatus.FAILED, ScanStatus.CANCELLED]:
            db_scan.end_time = datetime.utcnow()

        db_scan.updated_at = datetime.utcnow()
        self.session.add(db_scan)
        await self.session.flush()
        await self.session.refresh(db_scan)
        return db_scan

    async def delete_scan(self, scan_id: int) -> bool:
        """Delete a vulnerability scan.

        Args:
            scan_id: Vulnerability scan ID

        Returns:
            True if deleted, False if not found
        """
        db_scan = await self.get_scan(scan_id)
        if not db_scan:
            return False

        await self.session.delete(db_scan)
        await self.session.flush()
        return True


class VulnerabilityRepository:
    """Repository for vulnerabilities."""

    def __init__(self, session: AsyncSession):
        """Initialize with database session.

        Args:
            session: SQLAlchemy async session
        """
        self.session = session

    async def create_vulnerability(
        self, vulnerability_data: VulnerabilityCreate
    ) -> Vulnerability:
        """Create a new vulnerability.

        Args:
            vulnerability_data: Vulnerability data

        Returns:
            Created vulnerability
        """
        db_vulnerability = Vulnerability(
            scan_id=vulnerability_data.scan_id,
            target_id=vulnerability_data.target_id,
            name=vulnerability_data.name,
            description=vulnerability_data.description,
            severity=vulnerability_data.severity,
            status=vulnerability_data.status,
            cve_id=vulnerability_data.cve_id,
            cvss_score=vulnerability_data.cvss_score,
            affected_component=vulnerability_data.affected_component,
            port_number=vulnerability_data.port_number,
            protocol=vulnerability_data.protocol,
            details=vulnerability_data.details,
            remediation=vulnerability_data.remediation,
        )
        self.session.add(db_vulnerability)
        await self.session.flush()
        await self.session.refresh(db_vulnerability)
        return db_vulnerability

    async def get_vulnerability(self, vulnerability_id: int) -> Optional[Vulnerability]:
        """Get a vulnerability by ID.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            Vulnerability or None if not found
        """
        result = await self.session.execute(
            select(Vulnerability).where(Vulnerability.id == vulnerability_id)
        )
        vulnerability: Optional[Vulnerability] = result.scalars().first()
        return vulnerability

    async def get_vulnerabilities_by_scan(self, scan_id: int) -> List[Vulnerability]:
        """Get vulnerabilities by scan ID.

        Args:
            scan_id: Scan ID

        Returns:
            List of vulnerabilities
        """
        result = await self.session.execute(
            select(Vulnerability).where(Vulnerability.scan_id == scan_id)
        )
        return list(result.scalars().all())

    async def get_vulnerabilities_by_target(
        self, target_id: int
    ) -> List[Vulnerability]:
        """Get vulnerabilities by target ID.

        Args:
            target_id: Target ID

        Returns:
            List of vulnerabilities
        """
        result = await self.session.execute(
            select(Vulnerability).where(Vulnerability.target_id == target_id)
        )
        return list(result.scalars().all())

    async def update_vulnerability(
        self, vulnerability_id: int, vulnerability_data: VulnerabilityUpdate
    ) -> Optional[Vulnerability]:
        """Update a vulnerability.

        Args:
            vulnerability_id: Vulnerability ID
            vulnerability_data: Vulnerability update data

        Returns:
            Updated vulnerability or None if not found
        """
        db_vulnerability = await self.get_vulnerability(vulnerability_id)
        if not db_vulnerability:
            return None

        # Update fields if provided
        update_data = vulnerability_data.dict(exclude_unset=True)
        for key, value in update_data.items():
            setattr(db_vulnerability, key, value)

        db_vulnerability.updated_at = datetime.utcnow()
        self.session.add(db_vulnerability)
        await self.session.flush()
        await self.session.refresh(db_vulnerability)
        return db_vulnerability

    async def delete_vulnerability(self, vulnerability_id: int) -> bool:
        """Delete a vulnerability.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            True if deleted, False if not found
        """
        db_vulnerability = await self.get_vulnerability(vulnerability_id)
        if not db_vulnerability:
            return False

        await self.session.delete(db_vulnerability)
        await self.session.flush()
        return True
