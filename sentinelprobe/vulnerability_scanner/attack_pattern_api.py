"""API endpoints for attack patterns."""

import logging
from typing import Dict, List, Optional, cast

from fastapi import APIRouter, Depends, HTTPException, Path, Query
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.core.db import get_db_session
from sentinelprobe.vulnerability_scanner.attack_pattern_repository import (
    AttackPatternRepository,
)
from sentinelprobe.vulnerability_scanner.attack_patterns import (
    AttackPatternCreate,
    AttackPatternResponse,
    AttackPatternUpdate,
    AttackType,
    VulnerabilityAttackPatternMappingCreate,
    VulnerabilityAttackPatternMappingResponse,
)
from sentinelprobe.vulnerability_scanner.models import VulnerabilitySeverity
from sentinelprobe.vulnerability_scanner.repository import VulnerabilityRepository

router = APIRouter(prefix="/attack-patterns", tags=["attack-patterns"])

logger = logging.getLogger(__name__)


@router.post("", status_code=201, response_model=AttackPatternResponse)
async def create_attack_pattern(
    attack_pattern_data: AttackPatternCreate,
    session: AsyncSession = Depends(get_db_session),
) -> AttackPatternResponse:
    """
    Create a new attack pattern.

    Args:
        attack_pattern_data: Attack pattern creation data
        session: Database session

    Returns:
        Created attack pattern
    """
    repository = AttackPatternRepository(session)

    # Check if attack pattern with same name already exists
    existing_pattern = await repository.get_attack_pattern_by_name(
        attack_pattern_data.name
    )
    if existing_pattern:
        raise HTTPException(
            status_code=400,
            detail=(
                f"Attack pattern with name '{attack_pattern_data.name}' already exists"
            ),
        )

    attack_pattern = await repository.create_attack_pattern(attack_pattern_data)
    return cast(
        AttackPatternResponse,
        AttackPatternResponse.model_validate(attack_pattern.__dict__),
    )


@router.get("/{attack_pattern_id}", response_model=AttackPatternResponse)
async def get_attack_pattern(
    attack_pattern_id: int = Path(..., description="Attack pattern ID"),
    session: AsyncSession = Depends(get_db_session),
) -> AttackPatternResponse:
    """
    Get attack pattern details.

    Args:
        attack_pattern_id: Attack pattern ID
        session: Database session

    Returns:
        Attack pattern details
    """
    repository = AttackPatternRepository(session)
    attack_pattern = await repository.get_attack_pattern(attack_pattern_id)
    if not attack_pattern:
        raise HTTPException(
            status_code=404,
            detail=f"Attack pattern with ID {attack_pattern_id} not found",
        )
    return cast(
        AttackPatternResponse,
        AttackPatternResponse.model_validate(attack_pattern.__dict__),
    )


@router.get("", response_model=List[AttackPatternResponse])
async def list_attack_patterns(
    attack_type: Optional[AttackType] = Query(
        None, description="Filter by attack type"
    ),
    cwe_id: Optional[str] = Query(None, description="Filter by CWE ID"),
    severity: Optional[VulnerabilitySeverity] = Query(
        None, description="Filter by typical severity"
    ),
    session: AsyncSession = Depends(get_db_session),
) -> List[AttackPatternResponse]:
    """
    List attack patterns with optional filtering.

    Args:
        attack_type: Filter by attack type (optional)
        cwe_id: Filter by CWE ID (optional)
        severity: Filter by typical severity (optional)
        session: Database session

    Returns:
        List of attack patterns
    """
    repository = AttackPatternRepository(session)

    if attack_type:
        attack_patterns = await repository.get_attack_patterns_by_type(attack_type)
    elif cwe_id:
        attack_patterns = await repository.get_attack_patterns_by_cwe(cwe_id)
    else:
        attack_patterns = await repository.get_all_attack_patterns()

    # Apply severity filter if provided
    if severity:
        attack_patterns = [
            ap for ap in attack_patterns if ap.typical_severity == severity
        ]

    return [
        cast(AttackPatternResponse, AttackPatternResponse.model_validate(ap.__dict__))
        for ap in attack_patterns
    ]


@router.patch("/{attack_pattern_id}", response_model=AttackPatternResponse)
async def update_attack_pattern(
    attack_pattern_id: int,
    update_data: AttackPatternUpdate,
    session: AsyncSession = Depends(get_db_session),
) -> AttackPatternResponse:
    """
    Update attack pattern details.

    Args:
        attack_pattern_id: Attack pattern ID
        update_data: Attack pattern update data
        session: Database session

    Returns:
        Updated attack pattern
    """
    repository = AttackPatternRepository(session)
    attack_pattern = await repository.update_attack_pattern(
        attack_pattern_id, update_data
    )
    if not attack_pattern:
        raise HTTPException(
            status_code=404,
            detail=f"Attack pattern with ID {attack_pattern_id} not found",
        )
    return cast(
        AttackPatternResponse,
        AttackPatternResponse.model_validate(attack_pattern.__dict__),
    )


@router.delete("/{attack_pattern_id}", status_code=204)
async def delete_attack_pattern(
    attack_pattern_id: int = Path(..., description="Attack pattern ID"),
    session: AsyncSession = Depends(get_db_session),
) -> None:
    """
    Delete an attack pattern.

    Args:
        attack_pattern_id: Attack pattern ID
        session: Database session
    """
    repository = AttackPatternRepository(session)
    success = await repository.delete_attack_pattern(attack_pattern_id)
    if not success:
        raise HTTPException(
            status_code=404,
            detail=f"Attack pattern with ID {attack_pattern_id} not found",
        )


@router.post(
    "/mappings",
    status_code=201,
    response_model=VulnerabilityAttackPatternMappingResponse,
)
async def create_vulnerability_attack_pattern_mapping(
    mapping_data: VulnerabilityAttackPatternMappingCreate,
    session: AsyncSession = Depends(get_db_session),
) -> VulnerabilityAttackPatternMappingResponse:
    """
    Create a mapping between a vulnerability and an attack pattern.

    Args:
        mapping_data: Mapping creation data
        session: Database session

    Returns:
        Created mapping
    """
    ap_repository = AttackPatternRepository(session)
    vuln_repository = VulnerabilityRepository(session)

    # Verify vulnerability exists
    vulnerability = await vuln_repository.get_vulnerability(
        mapping_data.vulnerability_id
    )
    if not vulnerability:
        raise HTTPException(
            status_code=404,
            detail=f"Vulnerability with ID {mapping_data.vulnerability_id} not found",
        )

    # Verify attack pattern exists
    attack_pattern = await ap_repository.get_attack_pattern(
        mapping_data.attack_pattern_id
    )
    if not attack_pattern:
        raise HTTPException(
            status_code=404,
            detail=f"Attack pattern with ID {mapping_data.attack_pattern_id} not found",
        )

    mapping = await ap_repository.create_vulnerability_attack_pattern_mapping(
        mapping_data
    )
    return VulnerabilityAttackPatternMappingResponse(
        id=mapping.id,
        vulnerability_id=mapping.vulnerability_id,
        attack_pattern_id=mapping.attack_pattern_id,
        match_confidence=mapping.match_confidence,
        match_details=mapping.match_details,
        created_at=mapping.created_at,
    )


@router.get(
    "/vulnerabilities/{vulnerability_id}/match",
    response_model=List[Dict],
)
async def match_vulnerability_to_attack_patterns(
    vulnerability_id: int = Path(..., description="Vulnerability ID"),
    session: AsyncSession = Depends(get_db_session),
) -> List[Dict]:
    """
    Match a vulnerability to potential attack patterns.

    Args:
        vulnerability_id: Vulnerability ID
        session: Database session

    Returns:
        List of potential attack pattern matches with confidence scores
    """
    ap_repository = AttackPatternRepository(session)
    vuln_repository = VulnerabilityRepository(session)

    # Get vulnerability
    vulnerability = await vuln_repository.get_vulnerability(vulnerability_id)
    if not vulnerability:
        raise HTTPException(
            status_code=404,
            detail=f"Vulnerability with ID {vulnerability_id} not found",
        )

    # Match to attack patterns
    matched_patterns = await ap_repository.match_vulnerability_to_attack_patterns(
        vulnerability
    )

    # Convert to response format
    result = []
    for pattern, confidence in matched_patterns:
        result.append(
            {
                "attack_pattern": AttackPatternResponse.model_validate(
                    pattern.__dict__
                ),
                "confidence": confidence,
                "details": {
                    "matched_indicators": [
                        k
                        for k, v in pattern.pattern_indicators.items()
                        if k in vulnerability.details
                        and vulnerability.details.get(k) == v
                    ],
                },
            }
        )

    return result


@router.get(
    "/vulnerabilities/{vulnerability_id}",
    response_model=List[Dict],
)
async def get_vulnerability_attack_patterns(
    vulnerability_id: int = Path(..., description="Vulnerability ID"),
    session: AsyncSession = Depends(get_db_session),
) -> List[Dict]:
    """
    Get attack patterns associated with a vulnerability.

    Args:
        vulnerability_id: Vulnerability ID
        session: Database session

    Returns:
        List of associated attack patterns with confidence scores
    """
    ap_repository = AttackPatternRepository(session)
    vuln_repository = VulnerabilityRepository(session)

    # Verify vulnerability exists
    vulnerability = await vuln_repository.get_vulnerability(vulnerability_id)
    if not vulnerability:
        raise HTTPException(
            status_code=404,
            detail=f"Vulnerability with ID {vulnerability_id} not found",
        )

    # Get associated attack patterns
    pattern_mappings = await ap_repository.get_vulnerability_attack_patterns(
        vulnerability_id
    )

    # Convert to response format
    result = []
    for pattern, confidence in pattern_mappings:
        result.append(
            {
                "attack_pattern": AttackPatternResponse.model_validate(
                    pattern.__dict__
                ),
                "confidence": confidence,
            }
        )

    return result
