"""SSH Scanner Plugin for Vulnerability Scanner."""

import logging
import re
from typing import Any, Dict, List

from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.reconnaissance.models import ServiceType
from sentinelprobe.reconnaissance.repository import ServiceRepository
from sentinelprobe.vulnerability_scanner.models import (
    VulnerabilityCreate,
    VulnerabilityScan,
    VulnerabilitySeverity,
    VulnerabilityStatus,
)
from sentinelprobe.vulnerability_scanner.scanner_plugin import ScannerPlugin

logger = logging.getLogger(__name__)


class SshScanner(ScannerPlugin):
    """SSH vulnerability scanner implementation.

    This scanner checks for common SSH vulnerabilities such as:
    - Weak encryption algorithms
    - Outdated SSH versions
    - Insecure authentication methods
    - Default or weak configurations
    """

    name = "ssh_scanner"
    description = "Specialized scanner for SSH services"

    def __init__(self, session: AsyncSession):
        """Initialize with session."""
        super().__init__(session)
        self.service_repository = ServiceRepository(session)

    async def scan(
        self,
        scan: VulnerabilityScan,
        target_id: int,
        parameters: Dict[str, Any],
    ) -> List[VulnerabilityCreate]:
        """Perform an SSH vulnerability scan.

        Args:
            scan: The scan configuration
            target_id: Target ID to scan
            parameters: Scan parameters including target host/ip

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []

        # Get SSH services for the target
        services = await self.service_repository.get_services_by_target_and_type(
            target_id=target_id, service_type=ServiceType.SSH
        )

        if not services:
            logger.info(f"No SSH services found for target {target_id}")
            return []

        for service in services:
            port = service.port
            service_details = service.metadata or {}
            banner = service_details.get("banner", "")
            version = service_details.get("version", "")

            # Check for outdated SSH version
            if self._check_outdated_version(version, banner):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Outdated SSH Version",
                        description=f"The SSH server on port {port} is running an outdated version.",
                        severity=VulnerabilitySeverity.HIGH,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"ssh-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "version": version or self._extract_version(banner),
                            "finding_type": "outdated_software",
                        },
                        remediation="Update the SSH server to the latest version to address known vulnerabilities.",
                    )
                )

            # Check for weak algorithms and ciphers
            if self._check_weak_algorithms(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Weak SSH Ciphers/Algorithms",
                        description=f"The SSH server on port {port} supports weak encryption algorithms.",
                        severity=VulnerabilitySeverity.MEDIUM,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"ssh-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "weak_algorithms": self._get_weak_algorithms(
                                service_details
                            ),
                            "finding_type": "weak_cryptography",
                        },
                        remediation="Configure the SSH server to disable weak ciphers and algorithms.",
                    )
                )

            # Check for password authentication
            if self._check_password_auth(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Password Authentication Enabled",
                        description=f"The SSH server on port {port} has password authentication enabled, "
                        f"which is susceptible to brute force attacks.",
                        severity=VulnerabilitySeverity.MEDIUM,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"ssh-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "finding_type": "insecure_authentication",
                            "recommendation": "Use key-based authentication and disable password authentication",
                        },
                        remediation="Configure the SSH server to use key-based authentication only "
                        "and disable password authentication.",
                    )
                )

            # Check for root login
            if self._check_root_login(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Root Login Permitted",
                        description=f"The SSH server on port {port} allows direct root login, "
                        f"which is a security risk.",
                        severity=VulnerabilitySeverity.HIGH,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"ssh-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "finding_type": "insecure_configuration",
                            "recommendation": "Disable direct root login",
                        },
                        remediation="Disable direct root login by setting 'PermitRootLogin no' in sshd_config.",
                    )
                )

        return vulnerabilities

    def _extract_version(self, banner: str) -> str:
        """Extract SSH version from banner."""
        match = re.search(r"SSH-(\d+\.\d+[.-]\d+[^\s]*)", banner)
        if match:
            return match.group(1)
        return "unknown"

    def _check_outdated_version(self, version: str, banner: str) -> bool:
        """Check if the SSH version is outdated."""
        if not version and not banner:
            return False

        # Use the version if provided, otherwise extract from banner
        ssh_version: str = version or self._extract_version(banner)

        if "unknown" in ssh_version:
            return False

        # Extract major.minor.patch
        match = re.search(r"(\d+)\.(\d+)(?:\.(\d+))?", ssh_version)
        if not match:
            return False

        # Analyze version numbers
        groups = match.groups()
        major = int(groups[0])
        minor = int(groups[1])
        patch = int(groups[2]) if groups[2] else 0

        # SSH 1.x is considered insecure
        if major < 2:
            return True

        # Check for outdated OpenSSH versions
        if "openssh" in ssh_version.lower():
            if major < 7 or (major == 7 and minor < 9):
                return True
            # Check patch level for OpenSSH 7.9
            elif major == 7 and minor == 9 and patch < 3:
                return True

        return False

    def _check_weak_algorithms(self, service_details: Dict[str, Any]) -> bool:
        """Check if weak algorithms are supported."""
        algorithms = service_details.get("algorithms", {})
        encryption = algorithms.get("encryption", [])
        kex = algorithms.get("kex", [])
        mac = algorithms.get("mac", [])

        weak_ciphers = ["3des-cbc", "aes128-cbc", "aes192-cbc", "aes256-cbc", "arcfour"]
        weak_kex = ["diffie-hellman-group1-sha1", "diffie-hellman-group14-sha1"]
        weak_mac = ["hmac-md5", "hmac-sha1"]

        # Check for weak encryption algorithms
        for cipher in weak_ciphers:
            if any(cipher in alg.lower() for alg in encryption):
                return True

        # Check for weak key exchange algorithms
        for k in weak_kex:
            if any(k in alg.lower() for alg in kex):
                return True

        # Check for weak MAC algorithms
        for m in weak_mac:
            if any(m in alg.lower() for alg in mac):
                return True

        return False

    def _get_weak_algorithms(
        self, service_details: Dict[str, Any]
    ) -> Dict[str, List[str]]:
        """Get a list of weak algorithms supported by the server."""
        algorithms = service_details.get("algorithms", {})
        encryption = algorithms.get("encryption", [])
        kex = algorithms.get("kex", [])
        mac = algorithms.get("mac", [])

        weak_ciphers = ["3des-cbc", "aes128-cbc", "aes192-cbc", "aes256-cbc", "arcfour"]
        weak_kex = ["diffie-hellman-group1-sha1", "diffie-hellman-group14-sha1"]
        weak_mac = ["hmac-md5", "hmac-sha1"]

        results: Dict[str, List[str]] = {"encryption": [], "kex": [], "mac": []}

        # Find weak encryption algorithms
        for cipher in weak_ciphers:
            for alg in encryption:
                if cipher in alg.lower():
                    results["encryption"].append(alg)

        # Find weak key exchange algorithms
        for k in weak_kex:
            for alg in kex:
                if k in alg.lower():
                    results["kex"].append(alg)

        # Find weak MAC algorithms
        for m in weak_mac:
            for alg in mac:
                if m in alg.lower():
                    results["mac"].append(alg)

        return results

    def _check_password_auth(self, service_details: Dict[str, Any]) -> bool:
        """Check if password authentication is enabled."""
        config = service_details.get("config", {})

        # Handle potential non-dict config
        if not isinstance(config, dict):
            return False

        # Get the password_authentication setting with explicit default
        auth_setting = config.get("password_authentication", "yes")

        # Ensure we're comparing strings
        if isinstance(auth_setting, str):
            return auth_setting.lower() == "yes"

        # Default to false if the value is not a string
        return False

    def _check_root_login(self, service_details: Dict[str, Any]) -> bool:
        """Check if root login is permitted."""
        config = service_details.get("config", {})

        # Handle potential non-dict config
        if not isinstance(config, dict):
            return False

        # Get the permit_root_login setting with explicit default
        root_login = config.get("permit_root_login", "yes")

        # Ensure we're comparing with strings
        if isinstance(root_login, str):
            return root_login.lower() in ["yes", "without-password"]

        # Default to false if the value is not a string
        return False
