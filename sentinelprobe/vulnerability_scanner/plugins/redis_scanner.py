"""Redis Scanner Plugin for Vulnerability Scanner."""

import logging
import re
from typing import Any, Dict, List

from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.reconnaissance.models import ServiceType
from sentinelprobe.reconnaissance.repository import ServiceRepository
from sentinelprobe.vulnerability_scanner.models import (
    VulnerabilityCreate,
    VulnerabilityScan,
    VulnerabilitySeverity,
    VulnerabilityStatus,
)
from sentinelprobe.vulnerability_scanner.scanner_plugin import ScannerPlugin

logger = logging.getLogger(__name__)


class RedisScanner(ScannerPlugin):
    """Redis vulnerability scanner implementation.

    This scanner checks for common Redis vulnerabilities such as:
    - Authentication issues (missing/weak authentication)
    - Outdated Redis versions
    - Public exposure to internet
    - Insecure configurations
    """

    name = "redis_scanner"
    description = "Specialized scanner for Redis database services"

    def __init__(self, session: AsyncSession):
        """Initialize with session."""
        super().__init__(session)
        self.service_repository = ServiceRepository(session)

    async def scan(
        self,
        scan: VulnerabilityScan,
        target_id: int,
        parameters: Dict[str, Any],
    ) -> List[VulnerabilityCreate]:
        """Perform a Redis vulnerability scan.

        Args:
            scan: The scan configuration
            target_id: Target ID to scan
            parameters: Scan parameters including target host/ip

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []

        # Get Redis services for the target
        services = await self.service_repository.get_services_by_target_and_type(
            target_id=target_id, service_type=ServiceType.REDIS
        )

        if not services:
            logger.info(f"No Redis services found for target {target_id}")
            return []

        for service in services:
            port = service.port
            service_details = service.service_metadata or {}

            # Check for authentication issues
            if self._check_missing_authentication(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Redis Without Authentication",
                        description=f"The Redis server on port {port.port_number} has no authentication enabled.",
                        severity=VulnerabilitySeverity.CRITICAL,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"redis:{port.port_number}",
                        port_number=port.port_number,
                        protocol=port.protocol,
                        details={
                            "finding_type": "authentication_issue",
                            "authentication": "none",
                        },
                        remediation=(
                            "Configure Redis to require authentication by setting a "
                            "strong password with the 'requirepass' configuration directive."
                        ),
                    )
                )

            # Check for outdated Redis version
            if self._check_outdated_version(service.version):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Outdated Redis Version",
                        description=f"The Redis server on port {port.port_number} is running an outdated version ({service.version}).",
                        severity=VulnerabilitySeverity.HIGH,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"redis:{port.port_number}",
                        port_number=port.port_number,
                        protocol=port.protocol,
                        details={
                            "finding_type": "outdated_software",
                            "version": service.version,
                        },
                        remediation="Update Redis to the latest stable version to address known vulnerabilities.",
                    )
                )

            # Check for public exposure
            if self._check_public_exposure(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Redis Exposed to Public Internet",
                        description=f"The Redis server on port {port.port_number} is exposed to the public internet.",
                        severity=VulnerabilitySeverity.CRITICAL,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"redis:{port.port_number}",
                        port_number=port.port_number,
                        protocol=port.protocol,
                        details={
                            "finding_type": "network_exposure",
                            "exposed": True,
                            "binding": service_details.get("binding", "unknown"),
                        },
                        remediation=(
                            "Configure Redis to bind to localhost or internal network interfaces only. "
                            "Use a firewall to restrict access to trusted IP addresses."
                        ),
                    )
                )

            # Check for insecure configuration
            insecure_configs = self._check_insecure_configuration(service_details)
            if insecure_configs:
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Insecure Redis Configuration",
                        description=f"The Redis server on port {port.port_number} has insecure configuration settings.",
                        severity=VulnerabilitySeverity.HIGH,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"redis:{port.port_number}",
                        port_number=port.port_number,
                        protocol=port.protocol,
                        details={
                            "finding_type": "configuration_issue",
                            "insecure_settings": insecure_configs,
                        },
                        remediation=(
                            "Update the Redis configuration to address the identified issues. "
                            "Disable dangerous commands, enable protected mode, and set appropriate limits."
                        ),
                    )
                )

        return vulnerabilities

    def _check_missing_authentication(self, service_details: Dict[str, Any]) -> bool:
        """Check if Redis is running without authentication."""
        # Check if "requirepass" is set in config or we got "NOAUTH" in banner
        if "raw_banner" in service_details:
            banner = service_details["raw_banner"].lower()
            if (
                "authentication required" not in banner
                and "auth required" not in banner
            ):
                return True

        # If we have config details, check for requirepass
        if "config" in service_details:
            config = service_details["config"]
            if not config.get("requirepass"):
                return True

        # If we have auth_status information, use it
        if service_details.get("auth_status") == "none":
            return True

        return False

    def _check_outdated_version(self, version: str) -> bool:
        """Check if the Redis version is outdated."""
        if not version:
            return False

        # Extract version number
        match = re.search(r"(\d+)\.(\d+)\.(\d+)", version)
        if not match:
            return False

        major, minor, patch = map(int, match.groups())

        # As of 2023, Redis versions below 6.0 are considered outdated
        if major < 6:
            return True

        # For Redis 6.x, versions below 6.2 have known vulnerabilities
        if major == 6 and minor < 2:
            return True

        return False

    def _check_public_exposure(self, service_details: Dict[str, Any]) -> bool:
        """Check if Redis is exposed to the public internet."""
        # Check binding configuration
        if "binding" in service_details:
            binding = service_details.get("binding", "")
            # If bound to 0.0.0.0 or public IP, consider it exposed
            if (
                binding == "0.0.0.0"
                or not binding.startswith("127.")
                and not binding.startswith("192.168.")
                and not binding.startswith("10.")
            ):
                return True

        # Check protected mode status
        if "config" in service_details:
            config = service_details["config"]
            if config.get("protected-mode") == "no":
                return True

        return False

    def _check_insecure_configuration(
        self, service_details: Dict[str, Any]
    ) -> List[str]:
        """Check for insecure Redis configuration settings."""
        insecure_settings = []

        if "config" not in service_details:
            return []

        config = service_details["config"]

        # Dangerous commands enabled
        dangerous_commands = [
            "CONFIG",
            "FLUSHALL",
            "FLUSHDB",
            "EVAL",
            "KEYS",
        ]

        # Check if rename-command is used
        if "rename-command" not in config:
            insecure_settings.append("Dangerous commands not renamed")
        else:
            # Make sure we have a proper dictionary for rename-command
            rename_commands = config.get("rename-command", {})

            # If it's not a dictionary or is empty, consider it insecure
            if not isinstance(rename_commands, dict) or not rename_commands:
                insecure_settings.append("Dangerous commands not renamed")
            else:
                # Check if dangerous commands are properly renamed
                renamed_cmds = set(k.upper() for k in rename_commands.keys())
                for cmd in dangerous_commands:
                    if cmd not in renamed_cmds:
                        insecure_settings.append(f"{cmd} command not renamed")

        # Protected mode disabled
        if config.get("protected-mode") == "no":
            insecure_settings.append("Protected mode disabled")

        # No maxmemory limit
        if "maxmemory" not in config or config.get("maxmemory") == "0":
            insecure_settings.append("No maxmemory limit set")

        # No client timeout
        if "timeout" not in config or config.get("timeout") == "0":
            insecure_settings.append("No client timeout set")

        return insecure_settings
