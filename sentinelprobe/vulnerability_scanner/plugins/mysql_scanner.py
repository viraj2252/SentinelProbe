"""MySQL Scanner Plugin for Vulnerability Scanner."""

import logging
import re
from typing import Any, Dict, List

from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.reconnaissance.models import ServiceType
from sentinelprobe.reconnaissance.repository import ServiceRepository
from sentinelprobe.vulnerability_scanner.models import (
    VulnerabilityCreate,
    VulnerabilityScan,
    VulnerabilitySeverity,
    VulnerabilityStatus,
)
from sentinelprobe.vulnerability_scanner.scanner_plugin import ScannerPlugin

logger = logging.getLogger(__name__)


class MySqlScanner(ScannerPlugin):
    """MySQL vulnerability scanner implementation.

    This scanner checks for common MySQL vulnerabilities such as:
    - Outdated MySQL versions
    - Weak authentication settings
    - Insecure configurations
    - Exposed MySQL instances
    """

    name = "mysql_scanner"
    description = "Specialized scanner for MySQL database services"

    def __init__(self, session: AsyncSession):
        """Initialize with session."""
        super().__init__(session)
        self.service_repository = ServiceRepository(session)

    async def scan(
        self,
        scan: VulnerabilityScan,
        target_id: int,
        parameters: Dict[str, Any],
    ) -> List[VulnerabilityCreate]:
        """Perform a MySQL vulnerability scan.

        Args:
            scan: The scan configuration
            target_id: Target ID to scan
            parameters: Scan parameters including target host/ip

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []

        # Get MySQL services for the target
        services = await self.service_repository.get_services_by_target_and_type(
            target_id=target_id, service_type=ServiceType.MYSQL
        )

        if not services:
            logger.info(f"No MySQL services found for target {target_id}")
            return []

        for service in services:
            port = service.port
            service_details = service.metadata or {}
            version = service_details.get("version", "")
            banner = service_details.get("banner", "")

            # Check for outdated MySQL version
            if self._check_outdated_version(version, banner):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Outdated MySQL Version",
                        description=f"The MySQL server on port {port} is running an outdated version.",
                        severity=VulnerabilitySeverity.HIGH,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"mysql-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "version": version or self._extract_version(banner),
                            "finding_type": "outdated_software",
                        },
                        remediation="Update the MySQL server to the latest version to address known vulnerabilities.",
                    )
                )

            # Check for public exposure
            if self._check_public_exposure(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Publicly Exposed MySQL Server",
                        description=f"The MySQL server on port {port} is exposed to the public internet.",
                        severity=VulnerabilitySeverity.CRITICAL,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"mysql-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "finding_type": "exposure",
                            "recommendation": "Restrict access using firewall rules",
                        },
                        remediation="Restrict MySQL access to specific IP ranges using firewall rules "
                        "and bind MySQL to localhost or internal interfaces only.",
                    )
                )

            # Check for weak authentication
            if self._check_weak_auth(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Weak MySQL Authentication",
                        description=f"The MySQL server on port {port} is using weak authentication mechanisms.",
                        severity=VulnerabilitySeverity.HIGH,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"mysql-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "finding_type": "weak_authentication",
                            "authentication_method": service_details.get(
                                "auth_method", "unknown"
                            ),
                        },
                        remediation="Configure MySQL to use strong authentication methods. "
                        "Disable old authentication methods and require TLS for connections.",
                    )
                )

            # Check for default credentials
            if self._check_default_credentials(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Default MySQL Credentials",
                        description=f"The MySQL server on port {port} may be using default or weak credentials.",
                        severity=VulnerabilitySeverity.CRITICAL,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"mysql-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "finding_type": "default_credentials",
                            "recommendation": "Change default credentials and require strong passwords",
                        },
                        remediation="Change all default credentials, remove anonymous users, and "
                        "implement a strong password policy for database accounts.",
                    )
                )

            # Check for insecure configuration
            if self._check_insecure_config(service_details):
                vulnerabilities.append(
                    VulnerabilityCreate(
                        scan_id=scan.id,
                        target_id=target_id,
                        name="Insecure MySQL Configuration",
                        description=f"The MySQL server on port {port} has insecure configuration settings.",
                        severity=VulnerabilitySeverity.MEDIUM,
                        status=VulnerabilityStatus.CONFIRMED,
                        affected_component=f"mysql-server:{port}",
                        port_number=port,
                        protocol=service.protocol,
                        details={
                            "finding_type": "insecure_configuration",
                            "insecure_settings": self._get_insecure_settings(
                                service_details
                            ),
                        },
                        remediation="Review and update MySQL configuration to follow security best practices. "
                        "Disable unneeded features and ensure proper access controls are in place.",
                    )
                )

        return vulnerabilities

    def _extract_version(self, banner: str) -> str:
        """Extract MySQL version from banner."""
        match = re.search(r"(\d+\.\d+\.\d+)", banner)
        if match:
            return match.group(1)
        return "unknown"

    def _check_outdated_version(self, version: str, banner: str) -> bool:
        """Check if the MySQL version is outdated."""
        if not version and not banner:
            return False

        # Use the version if provided, otherwise extract from banner
        mysql_version = version or self._extract_version(banner)

        if "unknown" in mysql_version:
            return False

        # Extract major.minor.patch
        match = re.search(r"(\d+)\.(\d+)\.(\d+)", mysql_version)
        if not match:
            return False

        # Analyze version numbers
        major = int(match.group(1))
        minor = int(match.group(2))
        patch = int(match.group(3))

        # MySQL 5.5, 5.6, and 5.7 are considered outdated
        if major < 5 or (major == 5 and minor < 7):
            return True

        # MySQL 8.0.x where x < 28 (as of 2023) has known vulnerabilities
        if major == 8 and minor == 0 and patch < 28:
            return True

        return False

    def _check_public_exposure(self, service_details: Dict[str, Any]) -> bool:
        """Check if the MySQL server is exposed to the public internet."""
        # This would require additional network context to determine accurately
        # For now, we'll check metadata for hints
        if "binding" in service_details:
            binding = service_details.get("binding", "")
            # If bound to 0.0.0.0 or public IP, consider it exposed
            if (
                binding == "0.0.0.0"
                or not binding.startswith("127.")
                and not binding.startswith("192.168.")
            ):
                return True

        return False

    def _check_weak_auth(self, service_details: Dict[str, Any]) -> bool:
        """Check if weak authentication methods are in use."""
        auth_method = service_details.get("auth_method", "").lower()

        # Old authentication methods are considered weak
        if "old_password" in auth_method or "mysql_old_password" in auth_method:
            return True

        # Check if SSL/TLS is not required
        if "require_secure_transport" in service_details:
            if not service_details.get("require_secure_transport"):
                return True

        return False

    def _check_default_credentials(self, service_details: Dict[str, Any]) -> bool:
        """Check if default credentials are present."""
        has_anonymous = service_details.get("has_anonymous_users", False)
        has_default = service_details.get("has_default_users", False)
        has_empty = service_details.get("has_empty_passwords", False)

        return has_anonymous or has_default or has_empty

    def _check_insecure_config(self, service_details: Dict[str, Any]) -> bool:  # type: ignore
        """Check for insecure configuration settings."""
        # Get the config dictionary with a default empty dict
        config_data = service_details.get("config", {})

        # Ensure we have a dictionary
        if not isinstance(config_data, dict):
            return False

        # Check each insecure setting individually
        has_local_infile = False
        has_empty_secure_file_priv = False
        has_no_error_log = False

        # Check local_infile setting
        if "local_infile" in config_data:
            local_infile_value = config_data["local_infile"]
            has_local_infile = bool(local_infile_value)

        # Check secure_file_priv setting
        if "secure_file_priv" in config_data:
            secure_file_priv_value = config_data["secure_file_priv"]
            has_empty_secure_file_priv = secure_file_priv_value == ""

        # Check log_error setting
        if "log_error" in config_data:
            log_error_value = config_data["log_error"]
            has_no_error_log = not bool(log_error_value)

        # Return True if any insecure setting is found
        return has_local_infile or has_empty_secure_file_priv or has_no_error_log

    def _get_insecure_settings(self, service_details: Dict[str, Any]) -> Dict[str, Any]:
        """Get a list of insecure configuration settings."""
        config = service_details.get("config", {})
        insecure = {}

        if not config.get("local_infile", True):
            insecure["local_infile"] = "enabled"

        if config.get("secure_file_priv") == "":
            insecure["secure_file_priv"] = "disabled"

        if not config.get("log_error", ""):
            insecure["log_error"] = "disabled"

        return insecure
