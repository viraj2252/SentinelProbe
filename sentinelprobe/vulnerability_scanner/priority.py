"""Vulnerability prioritization algorithms.

This module provides algorithms for prioritizing vulnerabilities based on:
1. Severity and CVSS score
2. Attack pattern mapping confidence
3. Business impact
4. Exploitability factors
"""

import logging
from typing import Any, Dict, List, Optional, Tuple

from sentinelprobe.vulnerability_scanner.attack_patterns import AttackPattern
from sentinelprobe.vulnerability_scanner.models import (
    Vulnerability,
    VulnerabilitySeverity,
)

logger = logging.getLogger(__name__)

# Weight factors for different components of the prioritization score
SEVERITY_WEIGHT = 0.4
ATTACK_PATTERN_WEIGHT = 0.2
BUSINESS_IMPACT_WEIGHT = 0.2
EXPLOITABILITY_WEIGHT = 0.2

# Severity score mappings
SEVERITY_SCORES = {
    VulnerabilitySeverity.CRITICAL: 10.0,
    VulnerabilitySeverity.HIGH: 8.0,
    VulnerabilitySeverity.MEDIUM: 5.0,
    VulnerabilitySeverity.LOW: 2.0,
    VulnerabilitySeverity.INFO: 0.5,
}


async def get_exploitability_score(vulnerability: Vulnerability) -> float:
    """Calculate an exploitability score for a vulnerability.

    Current factors:
    - Presence of CVE ID (indicates known vulnerability)
    - CVSS score (if available)
    - Affected component criticality
    - Network accessibility (port and protocol)

    Args:
        vulnerability: The vulnerability to score

    Returns:
        Exploitability score (0-10 scale)
    """
    score = 0.0

    # Base score
    base_score = SEVERITY_SCORES.get(vulnerability.severity, 0)
    score += base_score * 0.5  # 50% of the score is based on severity

    # If CVSS score is available, use it for 25% of the score
    if vulnerability.cvss_score is not None:
        score += min(10.0, vulnerability.cvss_score) * 0.25
    elif vulnerability.cve_id:
        # If we have a CVE but no CVSS, add a smaller bonus
        score += 2.0

    # Network accessibility increases exploitability
    if vulnerability.port_number is not None and vulnerability.protocol:
        # Common services ports have higher risk
        high_risk_ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 443, 445, 3389]
        if vulnerability.port_number in high_risk_ports:
            score += 1.5
        else:
            score += 0.8

    # Cap at 10.0
    return min(10.0, score)


async def get_business_impact_score(
    vulnerability: Vulnerability, target_metadata: Dict[str, Any]
) -> float:
    """Calculate a business impact score for a vulnerability.

    Factors:
    - Target criticality (from target metadata)
    - Affected component type

    Args:
        vulnerability: The vulnerability to score
        target_metadata: Metadata about the target system

    Returns:
        Business impact score (0-10 scale)
    """
    score = 0.0

    # Target criticality (50% of impact score)
    criticality_map = {"low": 2.0, "medium": 5.0, "high": 7.5, "critical": 10.0}
    criticality = target_metadata.get("criticality", "medium").lower()
    score += criticality_map.get(criticality, 5.0) * 0.5

    # Component type impact (50% of impact score)
    high_impact_components = [
        "database",
        "authentication",
        "authorization",
        "payment",
        "pii",
    ]
    medium_impact_components = ["api", "web", "application", "service"]

    component = vulnerability.affected_component.lower()

    for high_component in high_impact_components:
        if high_component in component:
            score += 5.0 * 0.5
            break
    else:
        for medium_component in medium_impact_components:
            if medium_component in component:
                score += 3.0 * 0.5
                break
        else:
            score += 1.0 * 0.5

    # Cap at 10.0
    return min(10.0, score)


def calculate_attack_pattern_score(
    vulnerability: Vulnerability, attack_patterns: List[Tuple[AttackPattern, float]]
) -> float:
    """
    Calculate a score based on associated attack patterns.

    Args:
        vulnerability: The vulnerability to score
        attack_patterns: List of tuples containing attack patterns and confidence scores

    Returns:
        float: A score between 0 and 1 representing the attack pattern risk
    """
    if not attack_patterns:
        return 0.0

    # Calculate a weighted score based on attack pattern confidence
    total_confidence = sum(confidence for _, confidence in attack_patterns)

    # Normalize to 0-1 scale, with a maximum value of 1.0
    normalized_score = min(total_confidence / 3.0, 1.0)

    return float(normalized_score)


def calculate_severity_score(vulnerability: Vulnerability) -> float:
    """
    Calculate a score based on the vulnerability severity.

    Args:
        vulnerability: The vulnerability to score

    Returns:
        float: A score between 0 and 1 representing the severity
    """
    if not vulnerability.cvss_score:
        return 0.0

    # Convert CVSS score (0-10) to a 0-1 scale
    return float(vulnerability.cvss_score / 10.0)


def calculate_business_impact_score(vulnerability: Vulnerability) -> float:
    """
    Calculate a score based on the business impact of the vulnerability.

    Args:
        vulnerability: The vulnerability to score

    Returns:
        float: A score between 0 and 1 representing the business impact
    """
    if not vulnerability.details:
        return 0.0

    # Check for business impact in details
    impact = vulnerability.details.get("business_impact")
    if not impact:
        return 0.0

    # Convert string values to numeric scores
    if isinstance(impact, str):
        impact_map = {
            "critical": 1.0,
            "high": 0.8,
            "medium": 0.5,
            "low": 0.2,
            "none": 0.0,
        }
        return impact_map.get(impact.lower(), 0.0)

    # If it's already a number between 0-10, normalize to 0-1
    if isinstance(impact, (int, float)):
        return min(float(impact) / 10.0, 1.0)

    return 0.0


def calculate_vulnerability_score(
    vulnerability: Vulnerability,
    attack_patterns: Optional[List[Tuple[AttackPattern, float]]] = None,
    business_impact: Optional[float] = None,
    exploitability: Optional[float] = None,
) -> float:
    """Calculate an overall prioritization score for a vulnerability.

    Args:
        vulnerability: The vulnerability to score
        attack_patterns: Optional list of (attack_pattern, confidence) tuples
        business_impact: Optional pre-calculated business impact score
        exploitability: Optional pre-calculated exploitability score

    Returns:
        Overall prioritization score (0-10 scale)
    """
    # Get severity component
    severity_score = calculate_severity_score(vulnerability)

    # Get attack pattern component
    attack_pattern_score = 0.0
    if attack_patterns:
        attack_pattern_score = calculate_attack_pattern_score(
            vulnerability, attack_patterns
        )

    # Get exploitability component from parameter or vulnerability details
    exploitability_score = 0.0
    if exploitability is not None:
        exploitability_score = exploitability
    elif vulnerability.details and "exploitability" in vulnerability.details:
        exploitability_score = min(10.0, float(vulnerability.details["exploitability"]))

    # Get business impact component
    business_impact_score = 0.0
    if business_impact is not None:
        business_impact_score = business_impact
    elif vulnerability.details and "business_impact" in vulnerability.details:
        business_impact_score = min(
            10.0, float(vulnerability.details["business_impact"])
        )

    # Calculate weighted score
    score = (
        (severity_score * SEVERITY_WEIGHT)
        + (attack_pattern_score * ATTACK_PATTERN_WEIGHT)
        + (business_impact_score * BUSINESS_IMPACT_WEIGHT)
        + (exploitability_score * EXPLOITABILITY_WEIGHT)
    )

    logger.debug(
        f"Vulnerability {vulnerability.id} scoring: "
        f"severity={severity_score:.2f}, "
        f"attack_pattern={attack_pattern_score:.2f}, "
        f"business_impact={business_impact_score:.2f}, "
        f"exploitability={exploitability_score:.2f}, "
        f"total={score:.2f}"
    )

    return score


def prioritize_vulnerabilities(
    vulnerabilities: List[Vulnerability],
    attack_patterns_map: Dict[int, List[Tuple[AttackPattern, float]]],
) -> List[Tuple[Vulnerability, float]]:
    """
    Prioritize vulnerabilities based on multiple factors.

    Args:
        vulnerabilities: List of vulnerabilities to prioritize
        attack_patterns_map: Dictionary mapping vulnerability IDs to their attack patterns

    Returns:
        List of tuples containing vulnerabilities and their priority scores
    """
    prioritized_list = []

    for vuln in vulnerabilities:
        attack_patterns = attack_patterns_map.get(vuln.id, [])

        # Calculate individual scores
        severity_score = calculate_severity_score(vuln)
        attack_pattern_score = calculate_attack_pattern_score(vuln, attack_patterns)
        business_impact_score = calculate_business_impact_score(vuln)

        # Calculate final score (weighted average)
        final_score = (
            severity_score * SEVERITY_WEIGHT
            + attack_pattern_score * ATTACK_PATTERN_WEIGHT
            + business_impact_score * BUSINESS_IMPACT_WEIGHT
        )

        prioritized_list.append((vuln, final_score))

    # Sort by score in descending order
    return sorted(prioritized_list, key=lambda x: x[1], reverse=True)
