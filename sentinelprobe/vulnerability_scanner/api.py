"""API endpoints for the Vulnerability Scanner module."""

from typing import Dict, List, Optional, cast

from fastapi import APIRouter, Depends, HTTPException, Path, Query
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.core.db import get_db_session
from sentinelprobe.vulnerability_scanner.models import (
    ScanType,
    VulnerabilityCreate,
    VulnerabilityResponse,
    VulnerabilityScanCreate,
    VulnerabilityScanResponse,
    VulnerabilityUpdate,
)
from sentinelprobe.vulnerability_scanner.service import VulnerabilityScannerService

router = APIRouter(prefix="/vulnerability", tags=["vulnerability"])


@router.post("/scans", status_code=201, response_model=VulnerabilityScanResponse)
async def create_scan(
    scan_data: VulnerabilityScanCreate,
    session: AsyncSession = Depends(get_db_session),
) -> VulnerabilityScanResponse:
    """
    Create a new vulnerability scan.

    Args:
        scan_data: Vulnerability scan creation data
        session: Database session

    Returns:
        Created vulnerability scan
    """
    service = VulnerabilityScannerService(session)
    scan = await service.create_scan(
        job_id=scan_data.job_id,
        target_id=scan_data.target_id,
        name=scan_data.name,
        description=scan_data.description,
        scan_type=scan_data.scan_type or ScanType.STANDARD,
        scanner_module=scan_data.scanner_module,
        parameters=scan_data.parameters,
        strategy_id=scan_data.strategy_id,
    )
    return cast(
        VulnerabilityScanResponse,
        VulnerabilityScanResponse.model_validate(scan.__dict__),
    )


@router.get("/scans/{scan_id}", response_model=VulnerabilityScanResponse)
async def get_scan(
    scan_id: int = Path(..., description="Vulnerability scan ID"),
    session: AsyncSession = Depends(get_db_session),
) -> VulnerabilityScanResponse:
    """
    Get vulnerability scan details.

    Args:
        scan_id: Vulnerability scan ID
        session: Database session

    Returns:
        Vulnerability scan details
    """
    service = VulnerabilityScannerService(session)
    scan = await service.get_scan(scan_id)
    if not scan:
        raise HTTPException(
            status_code=404, detail=f"Vulnerability scan with ID {scan_id} not found"
        )
    return cast(
        VulnerabilityScanResponse,
        VulnerabilityScanResponse.model_validate(scan.__dict__),
    )


@router.get("/scans", response_model=List[VulnerabilityScanResponse])
async def list_scans(
    job_id: Optional[int] = Query(None, description="Filter by job ID"),
    target_id: Optional[int] = Query(None, description="Filter by target ID"),
    session: AsyncSession = Depends(get_db_session),
) -> List[VulnerabilityScanResponse]:
    """
    List vulnerability scans with optional filtering.

    Args:
        job_id: Filter by job ID (optional)
        target_id: Filter by target ID (optional)
        session: Database session

    Returns:
        List of vulnerability scans
    """
    service = VulnerabilityScannerService(session)

    if job_id:
        scans = await service.get_scans_by_job(job_id)
    elif target_id:
        scans = await service.get_scans_by_target(target_id)
    else:
        scans = await service.get_all_scans()

    return [
        cast(
            VulnerabilityScanResponse,
            VulnerabilityScanResponse.model_validate(scan.__dict__),
        )
        for scan in scans
    ]


@router.post("/scans/{scan_id}/start", status_code=202)
async def start_scan(
    scan_id: int = Path(..., description="Vulnerability scan ID"),
    session: AsyncSession = Depends(get_db_session),
) -> Dict[str, str]:
    """
    Start a vulnerability scan.

    Args:
        scan_id: Vulnerability scan ID
        session: Database session

    Returns:
        Status message
    """
    service = VulnerabilityScannerService(session)

    try:
        await service.start_scan(scan_id)
        return {"status": "success", "message": f"Scan {scan_id} started successfully"}
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to start scan: {str(e)}")


@router.post("/vulnerabilities", status_code=201, response_model=VulnerabilityResponse)
async def create_vulnerability(
    vulnerability_data: VulnerabilityCreate,
    session: AsyncSession = Depends(get_db_session),
) -> VulnerabilityResponse:
    """
    Create a new vulnerability record.

    Args:
        vulnerability_data: Vulnerability creation data
        session: Database session

    Returns:
        Created vulnerability
    """
    service = VulnerabilityScannerService(session)

    # Get the scan to ensure it exists
    scan = await service.get_scan(vulnerability_data.scan_id)
    if not scan:
        raise HTTPException(
            status_code=404,
            detail=f"Scan with ID {vulnerability_data.scan_id} not found",
        )

    # Create the vulnerability using the repository
    vulnerability = await service.vulnerability_repository.create_vulnerability(
        vulnerability_data
    )
    return cast(
        VulnerabilityResponse,
        VulnerabilityResponse.model_validate(vulnerability.__dict__),
    )


@router.get("/vulnerabilities/{vulnerability_id}", response_model=VulnerabilityResponse)
async def get_vulnerability(
    vulnerability_id: int = Path(..., description="Vulnerability ID"),
    session: AsyncSession = Depends(get_db_session),
) -> VulnerabilityResponse:
    """
    Get vulnerability details.

    Args:
        vulnerability_id: Vulnerability ID
        session: Database session

    Returns:
        Vulnerability details
    """
    service = VulnerabilityScannerService(session)
    vulnerability = await service.get_vulnerability(vulnerability_id)
    if not vulnerability:
        raise HTTPException(
            status_code=404,
            detail=f"Vulnerability with ID {vulnerability_id} not found",
        )
    return cast(
        VulnerabilityResponse,
        VulnerabilityResponse.model_validate(vulnerability.__dict__),
    )


@router.get(
    "/scans/{scan_id}/vulnerabilities", response_model=List[VulnerabilityResponse]
)
async def get_scan_vulnerabilities(
    scan_id: int = Path(..., description="Vulnerability scan ID"),
    session: AsyncSession = Depends(get_db_session),
) -> List[VulnerabilityResponse]:
    """
    Get vulnerabilities for a specific scan.

    Args:
        scan_id: Vulnerability scan ID
        session: Database session

    Returns:
        List of vulnerabilities
    """
    service = VulnerabilityScannerService(session)
    vulnerabilities = await service.get_scan_vulnerabilities(scan_id)
    return [
        cast(VulnerabilityResponse, VulnerabilityResponse.model_validate(vuln.__dict__))
        for vuln in vulnerabilities
    ]


@router.get(
    "/targets/{target_id}/vulnerabilities", response_model=List[VulnerabilityResponse]
)
async def get_target_vulnerabilities(
    target_id: int = Path(..., description="Target ID"),
    session: AsyncSession = Depends(get_db_session),
) -> List[VulnerabilityResponse]:
    """
    Get vulnerabilities for a specific target.

    Args:
        target_id: Target ID
        session: Database session

    Returns:
        List of vulnerabilities
    """
    service = VulnerabilityScannerService(session)
    vulnerabilities = await service.get_target_vulnerabilities(target_id)
    return [
        cast(VulnerabilityResponse, VulnerabilityResponse.model_validate(vuln.__dict__))
        for vuln in vulnerabilities
    ]


@router.patch(
    "/vulnerabilities/{vulnerability_id}", response_model=VulnerabilityResponse
)
async def update_vulnerability_status(
    vulnerability_id: int,
    update_data: VulnerabilityUpdate,
    session: AsyncSession = Depends(get_db_session),
) -> VulnerabilityResponse:
    """
    Update vulnerability status or details.

    Args:
        vulnerability_id: Vulnerability ID
        update_data: Vulnerability update data
        session: Database session

    Returns:
        Updated vulnerability
    """
    service = VulnerabilityScannerService(session)
    vulnerability = await service.update_vulnerability(vulnerability_id, update_data)

    if not vulnerability:
        raise HTTPException(
            status_code=404,
            detail=f"Vulnerability with ID {vulnerability_id} not found",
        )

    return cast(
        VulnerabilityResponse,
        VulnerabilityResponse.model_validate(vulnerability.__dict__),
    )
