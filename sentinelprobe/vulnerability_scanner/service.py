"""Service layer for the Vulnerability Scanner module."""

import logging
from typing import Any, Dict, List, Optional, Tuple, Type

from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.vulnerability_scanner.attack_pattern_repository import (
    AttackPatternRepository,
    VulnerabilityAttackPatternMapping,
)
from sentinelprobe.vulnerability_scanner.attack_patterns import (
    AttackPattern,
    AttackPatternCreate,
    AttackPatternUpdate,
    VulnerabilityAttackPatternMappingCreate,
)
from sentinelprobe.vulnerability_scanner.models import (
    ScanStatus,
    ScanType,
    Vulnerability,
    VulnerabilityCreate,
    VulnerabilityScan,
    VulnerabilityScanCreate,
    VulnerabilitySeverity,
    VulnerabilityStatus,
    VulnerabilityUpdate,
)
from sentinelprobe.vulnerability_scanner.plugins.http_scanner import HttpScanner
from sentinelprobe.vulnerability_scanner.plugins.mongodb_scanner import MongoDBScanner
from sentinelprobe.vulnerability_scanner.plugins.mysql_scanner import MySqlScanner
from sentinelprobe.vulnerability_scanner.plugins.redis_scanner import RedisScanner
from sentinelprobe.vulnerability_scanner.plugins.ssh_scanner import SshScanner
from sentinelprobe.vulnerability_scanner.priority import (
    calculate_vulnerability_score,
    get_business_impact_score,
    get_exploitability_score,
    prioritize_vulnerabilities,
)
from sentinelprobe.vulnerability_scanner.repository import (
    VulnerabilityRepository,
    VulnerabilityScanRepository,
)
from sentinelprobe.vulnerability_scanner.scanner_plugin import ScannerPlugin

logger = logging.getLogger(__name__)


class BasicScanner(ScannerPlugin):
    """Basic vulnerability scanner implementation."""

    name = "basic_scanner"
    description = "Basic vulnerability scanner that checks for common issues"

    async def scan(
        self,
        scan: VulnerabilityScan,
        target_id: int,
        parameters: Dict[str, Any],
    ) -> List[VulnerabilityCreate]:
        """Perform a basic vulnerability scan.

        Args:
            scan: The scan configuration
            target_id: Target ID to scan
            parameters: Scan parameters

        Returns:
            List of detected vulnerabilities
        """
        # In a real implementation, this would perform actual scanning
        # For now, we just return a placeholder vulnerability
        vulnerabilities = [
            VulnerabilityCreate(
                scan_id=scan.id,
                target_id=target_id,
                name="Example Vulnerability",
                description="Example vulnerability found by basic scanner",
                severity=VulnerabilitySeverity.MEDIUM,
                status=VulnerabilityStatus.UNCONFIRMED,
                affected_component="example-component",
                details={
                    "finding_type": "example",
                    "technical_details": "Example technical details would go here",
                },
                remediation="This is an example remediation instruction.",
            )
        ]
        return vulnerabilities


class VulnerabilityScannerService:
    """Service for vulnerability scanning operations."""

    # Register all scanner plugins here
    SCANNER_PLUGINS = {
        "basic_scanner": BasicScanner,
        "http_scanner": HttpScanner,
        "ssh_scanner": SshScanner,
        "mysql_scanner": MySqlScanner,
        "redis_scanner": RedisScanner,
        "mongodb_scanner": MongoDBScanner,
    }

    def __init__(self, session: AsyncSession):
        """Initialize the service with database session.

        Args:
            session: Database session
        """
        self.session = session
        self.scan_repository = VulnerabilityScanRepository(session)
        self.vulnerability_repository = VulnerabilityRepository(session)
        self.attack_pattern_repository = AttackPatternRepository(session)

    async def create_scan(
        self,
        job_id: int,
        target_id: int,
        name: str,
        description: str,
        scan_type: ScanType = ScanType.STANDARD,
        scanner_module: str = "basic_scanner",
        parameters: Optional[Dict[str, Any]] = None,
        strategy_id: Optional[int] = None,
    ) -> VulnerabilityScan:
        """Create a new vulnerability scan.

        Args:
            job_id: Job ID
            target_id: Target ID
            name: Scan name
            description: Scan description
            scan_type: Scan type
            scanner_module: Scanner module to use
            parameters: Optional scan parameters
            strategy_id: Optional strategy ID

        Returns:
            Created vulnerability scan
        """
        scan_data = VulnerabilityScanCreate(
            job_id=job_id,
            target_id=target_id,
            strategy_id=strategy_id,
            name=name,
            description=description,
            scan_type=scan_type,
            scanner_module=scanner_module,
            parameters=parameters or {},
            scan_metadata={},
        )
        return await self.scan_repository.create_scan(scan_data)

    async def get_scan(self, scan_id: int) -> Optional[VulnerabilityScan]:
        """Get a vulnerability scan by ID.

        Args:
            scan_id: Vulnerability scan ID

        Returns:
            Vulnerability scan or None if not found
        """
        return await self.scan_repository.get_scan(scan_id)

    async def get_scan_vulnerabilities(self, scan_id: int) -> List[Vulnerability]:
        """Get vulnerabilities for a scan.

        Args:
            scan_id: Vulnerability scan ID

        Returns:
            List of vulnerabilities
        """
        return await self.vulnerability_repository.get_vulnerabilities_by_scan(scan_id)

    async def get_target_vulnerabilities(self, target_id: int) -> List[Vulnerability]:
        """Get vulnerabilities for a target.

        Args:
            target_id: Target ID

        Returns:
            List of vulnerabilities
        """
        return await self.vulnerability_repository.get_vulnerabilities_by_target(
            target_id
        )

    async def get_scanner_plugin(
        self, scanner_name: str
    ) -> Optional[Type[ScannerPlugin]]:
        """Get a scanner plugin by name.

        Args:
            scanner_name: Name of the scanner plugin

        Returns:
            Scanner plugin class or None if not found
        """
        return self.SCANNER_PLUGINS.get(scanner_name)

    async def start_scan(self, scan_id: int) -> Optional[VulnerabilityScan]:
        """Start a vulnerability scan.

        Args:
            scan_id: Vulnerability scan ID

        Returns:
            Updated vulnerability scan or None if not found or already running
        """
        scan = await self.scan_repository.get_scan(scan_id)
        if not scan:
            logger.error(f"Scan {scan_id} not found")
            return None

        if scan.status != ScanStatus.PENDING:
            logger.error(f"Scan {scan_id} is not in PENDING state")
            return None

        # Update scan status to running
        scan = await self.scan_repository.update_scan_status(
            scan_id, ScanStatus.RUNNING, {"start_message": "Scan started"}
        )

        return scan

    async def execute_scan(self, scan_id: int) -> Optional[List[Vulnerability]]:
        """Execute a vulnerability scan.

        Args:
            scan_id: Vulnerability scan ID

        Returns:
            List of detected vulnerabilities or None if the scan failed
        """
        scan = await self.scan_repository.get_scan(scan_id)
        if not scan:
            logger.error(f"Scan {scan_id} not found")
            return None

        if scan.status != ScanStatus.RUNNING:
            logger.error(f"Scan {scan_id} is not in RUNNING state")
            return None

        try:
            # Get the scanner plugin
            scanner_class = await self.get_scanner_plugin(scan.scanner_module)
            if not scanner_class:
                error_msg = f"Scanner module {scan.scanner_module} not found"
                logger.error(error_msg)
                await self.scan_repository.update_scan_status(
                    scan_id, ScanStatus.FAILED, {"error": error_msg}
                )
                return None

            # Initialize the scanner plugin
            scanner = scanner_class(self.session)

            # Execute the scan
            vulnerability_data_list = await scanner.scan(
                scan, scan.target_id, scan.parameters
            )

            # Store the results
            vulnerabilities = []
            for vulnerability_data in vulnerability_data_list:
                vulnerability = (
                    await self.vulnerability_repository.create_vulnerability(
                        vulnerability_data
                    )
                )
                vulnerabilities.append(vulnerability)

            # Update scan status to completed
            await self.scan_repository.update_scan_status(
                scan_id,
                ScanStatus.COMPLETED,
                {
                    "completion_message": "Scan completed successfully",
                    "vulnerabilities_found": len(vulnerabilities),
                },
            )

            return vulnerabilities

        except Exception as e:
            error_msg = f"Error executing scan: {str(e)}"
            logger.exception(error_msg)
            await self.scan_repository.update_scan_status(
                scan_id, ScanStatus.FAILED, {"error": error_msg}
            )
            return None

    async def cancel_scan(self, scan_id: int) -> Optional[VulnerabilityScan]:
        """Cancel a vulnerability scan.

        Args:
            scan_id: Vulnerability scan ID

        Returns:
            Updated vulnerability scan or None if not found or not running
        """
        scan = await self.scan_repository.get_scan(scan_id)
        if not scan:
            logger.error(f"Scan {scan_id} not found")
            return None

        if scan.status != ScanStatus.RUNNING:
            logger.error(f"Scan {scan_id} is not in RUNNING state")
            return None

        # Update scan status to cancelled
        scan = await self.scan_repository.update_scan_status(
            scan_id, ScanStatus.CANCELLED, {"cancel_message": "Scan cancelled by user"}
        )

        return scan

    async def process_scan_from_strategy(
        self,
        strategy_id: int,
        job_id: int,
        target_id: int,
        strategy_data: Dict[str, Any],
    ) -> Optional[VulnerabilityScan]:
        """Process a vulnerability scan from a test strategy.

        Args:
            strategy_id: Strategy ID
            job_id: Job ID
            target_id: Target ID
            strategy_data: Strategy data

        Returns:
            Created and executed vulnerability scan or None if failed
        """
        try:
            service_type = strategy_data.get("service_type", "unknown")
            scan_type_str = strategy_data.get("scan_type", "standard")
            parameters = strategy_data.get("parameters", {})

            # Determine scan type
            try:
                scan_type = ScanType[scan_type_str.upper()]
            except (KeyError, AttributeError):
                scan_type = ScanType.STANDARD

            # Create the scan
            scan = await self.create_scan(
                job_id=job_id,
                target_id=target_id,
                name=f"Vulnerability scan for {service_type}",
                description=f"Automated vulnerability scan for {service_type} service",
                scan_type=scan_type,
                # Use appropriate scanner based on service_type
                scanner_module="basic_scanner",
                parameters=parameters,
                strategy_id=strategy_id,
            )

            # Start the scan
            await self.start_scan(scan.id)

            # Execute the scan
            await self.execute_scan(scan.id)

            return scan

        except Exception as e:
            logger.exception(f"Error processing scan from strategy: {str(e)}")
            return None

    async def get_vulnerability(self, vulnerability_id: int) -> Optional[Vulnerability]:
        """Get a vulnerability by ID.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            Vulnerability or None if not found
        """
        return await self.vulnerability_repository.get_vulnerability(vulnerability_id)

    async def get_all_scans(self) -> List[VulnerabilityScan]:
        """Get all vulnerability scans.

        Returns:
            List of all vulnerability scans
        """
        return await self.scan_repository.get_all_scans()

    async def get_scans_by_job(self, job_id: int) -> List[VulnerabilityScan]:
        """Get vulnerability scans by job ID.

        Args:
            job_id: Job ID

        Returns:
            List of vulnerability scans for the job
        """
        return await self.scan_repository.get_scans_by_job(job_id)

    async def get_scans_by_target(self, target_id: int) -> List[VulnerabilityScan]:
        """Get vulnerability scans by target ID.

        Args:
            target_id: Target ID

        Returns:
            List of vulnerability scans for the target
        """
        return await self.scan_repository.get_scans_by_target(target_id)

    async def update_vulnerability(
        self, vulnerability_id: int, vulnerability_data: VulnerabilityUpdate
    ) -> Optional[Vulnerability]:
        """Update a vulnerability.

        Args:
            vulnerability_id: Vulnerability ID
            vulnerability_data: Vulnerability update data

        Returns:
            Updated vulnerability or None if not found
        """
        return await self.vulnerability_repository.update_vulnerability(
            vulnerability_id, vulnerability_data
        )

    # Attack Pattern Methods
    async def create_attack_pattern(
        self, attack_pattern_data: AttackPatternCreate
    ) -> AttackPattern:
        """Create a new attack pattern.

        Args:
            attack_pattern_data: Attack pattern data

        Returns:
            Created attack pattern
        """
        return await self.attack_pattern_repository.create_attack_pattern(
            attack_pattern_data
        )

    async def get_attack_pattern(
        self, attack_pattern_id: int
    ) -> Optional[AttackPattern]:
        """Get an attack pattern by ID.

        Args:
            attack_pattern_id: Attack pattern ID

        Returns:
            Attack pattern or None if not found
        """
        return await self.attack_pattern_repository.get_attack_pattern(
            attack_pattern_id
        )

    async def update_attack_pattern(
        self, attack_pattern_id: int, attack_pattern_data: AttackPatternUpdate
    ) -> Optional[AttackPattern]:
        """Update an attack pattern.

        Args:
            attack_pattern_id: Attack pattern ID
            attack_pattern_data: Attack pattern update data

        Returns:
            Updated attack pattern or None if not found
        """
        return await self.attack_pattern_repository.update_attack_pattern(
            attack_pattern_id, attack_pattern_data
        )

    async def delete_attack_pattern(self, attack_pattern_id: int) -> bool:
        """Delete an attack pattern.

        Args:
            attack_pattern_id: Attack pattern ID

        Returns:
            True if deleted, False if not found
        """
        return await self.attack_pattern_repository.delete_attack_pattern(
            attack_pattern_id
        )

    async def get_all_attack_patterns(self) -> List[AttackPattern]:
        """Get all attack patterns.

        Returns:
            List of all attack patterns
        """
        return await self.attack_pattern_repository.get_all_attack_patterns()

    async def match_vulnerability_to_attack_patterns(
        self, vulnerability_id: int
    ) -> List[Tuple[AttackPattern, float]]:
        """Match a vulnerability to attack patterns based on its characteristics.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            List of tuples containing (attack_pattern, confidence_score)
        """
        vulnerability = await self.vulnerability_repository.get_vulnerability(
            vulnerability_id
        )
        if not vulnerability:
            raise ValueError(f"Vulnerability with ID {vulnerability_id} not found")

        # Get all attack patterns
        attack_patterns = await self.attack_pattern_repository.get_all_attack_patterns()

        # Match vulnerability to attack patterns
        matches: List[Tuple[AttackPattern, float]] = []
        for pattern in attack_patterns:
            confidence = (
                self.attack_pattern_repository._calculate_pattern_match_confidence(
                    vulnerability, pattern
                )
            )
            if confidence > 0.5:  # Only include matches with confidence > 50%
                matches.append((pattern, confidence))

        # Sort by confidence score in descending order
        matches.sort(key=lambda x: x[1], reverse=True)

        # Create mappings for top matches
        for pattern, confidence in matches[:5]:  # Store top 5 matches
            await self.create_vulnerability_attack_pattern_mapping(
                vulnerability_id, pattern.id, confidence
            )

        return matches

    async def create_vulnerability_attack_pattern_mapping(
        self, vulnerability_id: int, attack_pattern_id: int, confidence: float = 100.0
    ) -> VulnerabilityAttackPatternMapping:
        """Create a mapping between a vulnerability and an attack pattern.

        Args:
            vulnerability_id: Vulnerability ID
            attack_pattern_id: Attack pattern ID
            confidence: Match confidence (default 100.0)

        Returns:
            Created mapping

        Raises:
            ValueError: If vulnerability or attack pattern not found
        """
        # Verify vulnerability exists
        vulnerability = await self.vulnerability_repository.get_vulnerability(
            vulnerability_id
        )
        if not vulnerability:
            raise ValueError(f"Vulnerability with ID {vulnerability_id} not found")

        # Verify attack pattern exists
        attack_pattern = await self.attack_pattern_repository.get_attack_pattern(
            attack_pattern_id
        )
        if not attack_pattern:
            raise ValueError(f"Attack pattern with ID {attack_pattern_id} not found")

        mapping_data = VulnerabilityAttackPatternMappingCreate(
            vulnerability_id=vulnerability_id,
            attack_pattern_id=attack_pattern_id,
            match_confidence=confidence,
        )
        return await self.attack_pattern_repository.create_vulnerability_attack_pattern_mapping(
            mapping_data
        )

    async def get_vulnerability_attack_patterns(
        self, vulnerability_id: int
    ) -> List[Tuple[AttackPattern, float]]:
        """Get attack patterns associated with a vulnerability.

        Args:
            vulnerability_id: Vulnerability ID

        Returns:
            List of tuples containing (attack_pattern, confidence)

        Raises:
            ValueError: If vulnerability not found
        """
        # Verify vulnerability exists
        vulnerability = await self.vulnerability_repository.get_vulnerability(
            vulnerability_id
        )
        if not vulnerability:
            raise ValueError(f"Vulnerability with ID {vulnerability_id} not found")

        return await self.attack_pattern_repository.get_vulnerability_attack_patterns(
            vulnerability_id
        )

    async def auto_match_and_map_vulnerability(
        self, vulnerability_id: int, confidence_threshold: float = 70.0
    ) -> List[Tuple[AttackPattern, float]]:
        """Automatically match a vulnerability to attack patterns and create mappings.

        Only creates mappings for matches above the confidence threshold.

        Args:
            vulnerability_id: Vulnerability ID
            confidence_threshold: Minimum confidence to create a mapping (default 70.0)

        Returns:
            List of tuples containing (attack_pattern, confidence) for created mappings

        Raises:
            ValueError: If vulnerability not found
        """
        # Match vulnerability to attack patterns
        matched_patterns = await self.match_vulnerability_to_attack_patterns(
            vulnerability_id
        )

        # Filter by confidence threshold
        high_confidence_matches = [
            (pattern, confidence)
            for pattern, confidence in matched_patterns
            if confidence >= confidence_threshold
        ]

        # Create mappings for high confidence matches
        created_mappings = []
        for pattern, confidence in high_confidence_matches:
            await self.create_vulnerability_attack_pattern_mapping(
                vulnerability_id, pattern.id, confidence
            )
            created_mappings.append((pattern, confidence))

        return created_mappings

    async def prioritize_target_vulnerabilities(
        self, target_id: int, include_business_impact: bool = False
    ) -> List[Tuple[Vulnerability, float]]:
        """
        Prioritize vulnerabilities for a target.

        Args:
            target_id: Target ID
            include_business_impact: Whether to include business impact in prioritization

        Returns:
            List of tuples containing vulnerabilities and their priority scores
        """
        # Get all vulnerabilities for the target
        vulnerabilities = await self.get_target_vulnerabilities(target_id)

        if not vulnerabilities:
            return []

        # Get attack patterns for all vulnerabilities
        attack_patterns_map = {}
        for vuln in vulnerabilities:
            attack_patterns = await self.get_vulnerability_attack_patterns(vuln.id)
            if attack_patterns:
                attack_patterns_map[vuln.id] = attack_patterns

        # Prioritize vulnerabilities
        return prioritize_vulnerabilities(vulnerabilities, attack_patterns_map)

    async def prioritize_scan_vulnerabilities(
        self, scan_id: int, include_business_impact: bool = False
    ) -> List[Tuple[Vulnerability, float]]:
        """
        Prioritize vulnerabilities for a scan.

        Args:
            scan_id: Scan ID
            include_business_impact: Whether to include business impact in prioritization

        Returns:
            List of tuples containing vulnerabilities and their priority scores
        """
        # Get all vulnerabilities for the scan
        vulnerabilities = await self.get_scan_vulnerabilities(scan_id)

        if not vulnerabilities:
            return []

        # Get attack patterns for all vulnerabilities
        attack_patterns_map = {}
        for vuln in vulnerabilities:
            attack_patterns = await self.get_vulnerability_attack_patterns(vuln.id)
            if attack_patterns:
                attack_patterns_map[vuln.id] = attack_patterns

        # Prioritize vulnerabilities
        return prioritize_vulnerabilities(vulnerabilities, attack_patterns_map)

    async def get_vulnerability_score(
        self, vulnerability_id: int, include_business_impact: bool = True
    ) -> Tuple[Optional[Vulnerability], Optional[float]]:
        """Calculate the prioritization score for a single vulnerability.

        Args:
            vulnerability_id: ID of the vulnerability
            include_business_impact: Whether to calculate business impact score

        Returns:
            Tuple of (vulnerability, score) or (None, None) if not found
        """
        # Get the vulnerability
        vulnerability = await self.get_vulnerability(vulnerability_id)
        if not vulnerability:
            return None, None

        # Get attack pattern mappings
        attack_patterns = await self.get_vulnerability_attack_patterns(vulnerability_id)

        # Get business impact score if requested
        business_impact = None
        if include_business_impact:
            # TODO: In the future, get target metadata from target repository
            target_metadata = {"criticality": "medium"}  # Placeholder
            business_impact = await get_business_impact_score(
                vulnerability, target_metadata
            )

        # Calculate score
        score = calculate_vulnerability_score(
            vulnerability, attack_patterns, business_impact
        )

        return vulnerability, score

    async def update_vulnerability_exploitability(
        self, vulnerability_id: int
    ) -> Optional[Vulnerability]:
        """Update the exploitability score for a vulnerability.

        Args:
            vulnerability_id: ID of the vulnerability

        Returns:
            Updated vulnerability or None if not found
        """
        # Get the vulnerability
        vulnerability = await self.get_vulnerability(vulnerability_id)
        if not vulnerability:
            return None

        # Calculate exploitability score
        exploitability_score = await get_exploitability_score(vulnerability)

        # Update vulnerability details with the new score
        details = vulnerability.details.copy() if vulnerability.details else {}
        details["exploitability"] = exploitability_score

        # Create update data
        update_data = VulnerabilityUpdate(details=details)

        # Update the vulnerability
        return await self.update_vulnerability(vulnerability_id, update_data)
