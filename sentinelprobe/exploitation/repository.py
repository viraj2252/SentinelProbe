"""Repository layer for the Exploitation Engine."""

import logging
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.exploitation.models import (
    Exploit,
    ExploitAttempt,
    ExploitStatus,
    ExploitType,
    PayloadType,
)

logger = logging.getLogger(__name__)


class ExploitRepository:
    """Repository for Exploit operations."""

    def __init__(self, session: AsyncSession):
        """Initialize with session.

        Args:
            session: SQLAlchemy async session
        """
        self.session = session

    async def create_exploit(
        self,
        name: str,
        description: str,
        exploit_type: ExploitType,
        target_services: List[str],
        payload_template: str,
        payload_type: PayloadType,
        parameters: Dict[str, Any],
        risk_level: int,
        target_versions: Optional[Dict[str, str]] = None,
        success_indicators: Optional[Dict[str, Any]] = None,
        exploit_metadata: Optional[Dict[str, Any]] = None,
    ) -> Exploit:
        """Create a new exploit.

        Args:
            name: Name of the exploit
            description: Description of the exploit
            exploit_type: Type of the exploit
            target_services: List of services this exploit targets
            payload_template: Template for generating payloads
            payload_type: Type of payload
            parameters: Required parameters for the exploit
            risk_level: Risk level (1-10)
            target_versions: Optional version ranges this exploit works on
            success_indicators: Optional indicators of successful exploitation
            exploit_metadata: Optional additional metadata

        Returns:
            The created exploit
        """
        exploit = Exploit(
            name=name,
            description=description,
            exploit_type=exploit_type,
            target_services=target_services,
            target_versions=target_versions or {},
            payload_template=payload_template,
            payload_type=payload_type,
            parameters=parameters,
            success_indicators=success_indicators or {},
            risk_level=risk_level,
            exploit_metadata=exploit_metadata or {},
        )

        self.session.add(exploit)
        await self.session.commit()
        return exploit

    async def get_exploit(self, exploit_id: int) -> Optional[Exploit]:
        """Get an exploit by ID.

        Args:
            exploit_id: ID of the exploit

        Returns:
            The exploit or None if not found
        """
        result = await self.session.execute(
            select(Exploit).where(Exploit.id == exploit_id)
        )
        exploit = result.scalars().first()
        return exploit if exploit is not None else None

    async def get_exploits_by_type(self, exploit_type: ExploitType) -> List[Exploit]:
        """Get exploits by type.

        Args:
            exploit_type: Type of exploits to get

        Returns:
            List of exploits
        """
        result = await self.session.execute(
            select(Exploit).where(Exploit.exploit_type == exploit_type)
        )
        return list(result.scalars().all())

    async def get_exploits_by_service(self, service_type: str) -> List[Exploit]:
        """Get exploits that target a specific service type.

        Args:
            service_type: Type of service

        Returns:
            List of exploits
        """
        # Using JSONB containment to check if the service is in the target_services array
        result = await self.session.execute(
            select(Exploit).where(
                func.jsonb_exists(Exploit.target_services, service_type)
            )
        )
        return list(result.scalars().all())

    async def get_active_exploits(self) -> List[Exploit]:
        """Get all active exploits.

        Returns:
            List of active exploits
        """
        result = await self.session.execute(
            select(Exploit).where(Exploit.is_active == True)  # noqa: E712
        )
        return list(result.scalars().all())

    async def update_exploit(self, exploit_id: int, **kwargs: Any) -> Optional[Exploit]:
        """Update an exploit.

        Args:
            exploit_id: ID of the exploit to update
            **kwargs: Fields to update

        Returns:
            The updated exploit or None if not found
        """
        exploit = await self.get_exploit(exploit_id)
        if not exploit:
            return None

        for key, value in kwargs.items():
            if hasattr(exploit, key):
                setattr(exploit, key, value)

        # Update the updated_at timestamp manually
        setattr(exploit, "updated_at", datetime.utcnow())
        await self.session.commit()
        return exploit

    async def delete_exploit(self, exploit_id: int) -> bool:
        """Delete an exploit.

        Args:
            exploit_id: ID of the exploit to delete

        Returns:
            True if deleted, False if not found
        """
        exploit = await self.get_exploit(exploit_id)
        if not exploit:
            return False

        await self.session.delete(exploit)
        await self.session.commit()
        return True


class ExploitAttemptRepository:
    """Repository for ExploitAttempt operations."""

    def __init__(self, session: AsyncSession):
        """Initialize with session.

        Args:
            session: SQLAlchemy async session
        """
        self.session = session

    async def create_attempt(
        self,
        job_id: int,
        exploit_id: int,
        vulnerability_id: int,
        target_id: int,
        payload: Optional[str] = None,
        parameters_used: Optional[Dict[str, Any]] = None,
        attempt_metadata: Optional[Dict[str, Any]] = None,
    ) -> ExploitAttempt:
        """Create a new exploitation attempt.

        Args:
            job_id: ID of the job
            exploit_id: ID of the exploit
            vulnerability_id: ID of the vulnerability
            target_id: ID of the target
            payload: Optional payload used
            parameters_used: Optional parameters used
            attempt_metadata: Optional additional metadata

        Returns:
            The created attempt
        """
        attempt = ExploitAttempt(
            job_id=job_id,
            exploit_id=exploit_id,
            vulnerability_id=vulnerability_id,
            target_id=target_id,
            status=ExploitStatus.PENDING,
            payload=payload,
            parameters_used=parameters_used or {},
            attempt_metadata=attempt_metadata or {},
        )

        self.session.add(attempt)
        await self.session.commit()
        return attempt

    async def get_attempt(self, attempt_id: int) -> Optional[ExploitAttempt]:
        """Get an attempt by ID.

        Args:
            attempt_id: ID of the attempt

        Returns:
            The attempt or None if not found
        """
        result = await self.session.execute(
            select(ExploitAttempt).where(ExploitAttempt.id == attempt_id)
        )
        attempt = result.scalars().first()
        return attempt if attempt is not None else None

    async def get_attempts_by_job(self, job_id: int) -> List[ExploitAttempt]:
        """Get attempts by job ID.

        Args:
            job_id: ID of the job

        Returns:
            List of attempts
        """
        result = await self.session.execute(
            select(ExploitAttempt).where(ExploitAttempt.job_id == job_id)
        )
        return list(result.scalars().all())

    async def get_attempts_by_vulnerability(
        self, vulnerability_id: int
    ) -> List[ExploitAttempt]:
        """Get attempts for a specific vulnerability.

        Args:
            vulnerability_id: ID of the vulnerability

        Returns:
            List of attempts
        """
        result = await self.session.execute(
            select(ExploitAttempt).where(
                ExploitAttempt.vulnerability_id == vulnerability_id
            )
        )
        return list(result.scalars().all())

    async def get_attempts_by_status(
        self, status: ExploitStatus
    ) -> List[ExploitAttempt]:
        """Get attempts by status.

        Args:
            status: Status to filter by

        Returns:
            List of attempts
        """
        result = await self.session.execute(
            select(ExploitAttempt).where(ExploitAttempt.status == status)
        )
        return list(result.scalars().all())

    async def update_attempt_status(
        self,
        attempt_id: int,
        status: ExploitStatus,
        result: Optional[str] = None,
        is_successful: Optional[bool] = None,
        execution_time: Optional[int] = None,
    ) -> Optional[ExploitAttempt]:
        """Update the status of an exploit attempt.

        Args:
            attempt_id: ID of the attempt
            status: New status
            result: Optional result output
            is_successful: Whether the attempt was successful
            execution_time: Execution time in milliseconds

        Returns:
            The updated attempt or None if not found
        """
        attempt = await self.get_attempt(attempt_id)
        if not attempt:
            return None

        # Update the fields
        setattr(attempt, "status", status)

        if result is not None:
            setattr(attempt, "result", result)

        if is_successful is not None:
            setattr(attempt, "is_successful", is_successful)

        if execution_time is not None:
            setattr(attempt, "execution_time", execution_time)

        setattr(attempt, "updated_at", datetime.utcnow())

        await self.session.commit()
        return attempt

    async def get_success_rate_by_exploit(
        self, exploit_id: int
    ) -> Tuple[int, int, float]:
        """Get the success rate for a specific exploit.

        Args:
            exploit_id: ID of the exploit

        Returns:
            Tuple of (total attempts, successful attempts, success rate)
        """
        # Query for the total number of attempts
        total_result = await self.session.execute(
            select(func.count()).where(ExploitAttempt.exploit_id == exploit_id)
        )
        total_attempts = total_result.scalar() or 0

        # Query for the number of successful attempts
        success_result = await self.session.execute(
            select(func.count()).where(
                ExploitAttempt.exploit_id == exploit_id,
                ExploitAttempt.is_successful == True,  # noqa: E712
            )
        )
        successful_attempts = success_result.scalar() or 0

        # Calculate success rate (avoid division by zero)
        success_rate = (
            (successful_attempts / total_attempts) * 100 if total_attempts > 0 else 0
        )

        return total_attempts, successful_attempts, success_rate
