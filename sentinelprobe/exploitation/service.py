"""Service layer for the Exploitation Engine."""

import importlib
import logging
import os
import pkgutil
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.exploitation.models import (
    Exploit,
    ExploitConfig,
    ExploitResult,
    ExploitType,
)
from sentinelprobe.exploitation.plugin import ExploitPlugin
from sentinelprobe.exploitation.repository import (
    ExploitAttemptRepository,
    ExploitRepository,
)
from sentinelprobe.reconnaissance.models import Target
from sentinelprobe.reconnaissance.repository import TargetRepository
from sentinelprobe.vulnerability_scanner.models import (
    Vulnerability,
    VulnerabilitySeverity,
)
from sentinelprobe.vulnerability_scanner.repository import VulnerabilityRepository

logger = logging.getLogger(__name__)


class ExploitationService:
    """Service for executing exploits."""

    def __init__(
        self,
        session: AsyncSession,
        plugin_package: str = "sentinelprobe.exploitation.plugins",
    ):
        """Initialize with session and plugin package.

        Args:
            session: SQLAlchemy async session
            plugin_package: The package containing exploitation plugins
        """
        self.session = session
        self.exploit_repo = ExploitRepository(session)
        self.attempt_repo = ExploitAttemptRepository(session)
        self.target_repo = TargetRepository(session)
        self.vuln_repo = VulnerabilityRepository(session)
        self.plugin_package = plugin_package
        self._plugins: Dict[str, ExploitPlugin] = {}
        self._load_plugins()

    def _load_plugins(self) -> None:
        """Load all available exploitation plugins."""
        logger.info("Loading exploitation plugins...")
        self._plugins = {}

        try:
            # Import the plugin package
            package = importlib.import_module(self.plugin_package)
            package_file = package.__file__
            if package_file is None:
                logger.error("Could not get package file for plugin package")
                return

            package_path = os.path.dirname(package_file)

            # Discover all modules in the package
            for _, module_name, is_pkg in pkgutil.iter_modules([package_path]):
                if not is_pkg:  # Only load modules, not sub-packages
                    try:
                        # Import the module
                        module = importlib.import_module(
                            f"{self.plugin_package}.{module_name}"
                        )

                        # Look for ExploitPlugin subclasses in the module
                        for attr_name in dir(module):
                            attr = getattr(module, attr_name)
                            if (
                                isinstance(attr, type)
                                and issubclass(attr, ExploitPlugin)
                                and attr is not ExploitPlugin
                            ):
                                # Instantiate and register the plugin
                                plugin = attr()
                                self._plugins[plugin.name] = plugin
                                logger.info(
                                    f"Loaded exploitation plugin: {plugin.name}"
                                )
                    except Exception as e:
                        logger.error(
                            f"Error loading exploitation plugin module {module_name}: {e}"
                        )

            logger.info(f"Loaded {len(self._plugins)} exploitation plugins")
        except Exception as e:
            logger.error(f"Error loading exploitation plugins: {e}")

    def get_available_plugins(self) -> List[Dict[str, Any]]:
        """Get information about all available plugins.

        Returns:
            List of plugin information dictionaries
        """
        return [
            {
                "name": plugin.name,
                "description": plugin.description,
                "exploit_type": plugin.exploit_type.value,
                "payload_type": plugin.payload_type.value,
                "target_services": plugin.target_services,
                "risk_level": plugin.risk_level,
            }
            for plugin in self._plugins.values()
        ]

    def get_plugin(self, plugin_name: str) -> Optional[ExploitPlugin]:
        """Get a plugin by name.

        Args:
            plugin_name: Name of the plugin to get

        Returns:
            The plugin if found, None otherwise
        """
        return self._plugins.get(plugin_name)

    def get_plugins_for_exploit_type(
        self, exploit_type: ExploitType
    ) -> List[ExploitPlugin]:
        """Get all plugins for a specific exploit type.

        Args:
            exploit_type: Type of exploit to filter by

        Returns:
            List of plugins matching the exploit type
        """
        return [
            plugin
            for plugin in self._plugins.values()
            if plugin.exploit_type == exploit_type
        ]

    def get_plugins_for_service(self, service: str) -> List[ExploitPlugin]:
        """Get all plugins applicable to a specific service.

        Args:
            service: Service to filter plugins by

        Returns:
            List of plugins targeting the service
        """
        return [
            plugin
            for plugin in self._plugins.values()
            if service.lower() in [s.lower() for s in plugin.target_services]
        ]

    async def find_applicable_plugins(
        self, vulnerability: Vulnerability, target: Target
    ) -> List[ExploitPlugin]:
        """Find plugins applicable to the given vulnerability.

        Args:
            vulnerability: The vulnerability to find plugins for
            target: The target with the vulnerability

        Returns:
            List of applicable plugins
        """
        applicable_plugins = []

        for plugin in self._plugins.values():
            try:
                if await plugin.check_applicability(vulnerability, target):
                    applicable_plugins.append(plugin)
            except Exception as e:
                logger.error(
                    f"Error checking applicability of plugin {plugin.name}: {e}"
                )

        return applicable_plugins

    async def generate_payload(
        self,
        plugin_name: str,
        vulnerability: Vulnerability,
        target: Target,
        parameters: Optional[Dict[str, Any]] = None,
    ) -> Optional[str]:
        """Generate an exploit payload using the specified plugin.

        Args:
            plugin_name: Name of the plugin to use
            vulnerability: The vulnerability to exploit
            target: The target with the vulnerability
            parameters: Additional parameters for payload generation

        Returns:
            Generated payload or None if generation failed
        """
        plugin = self.get_plugin(plugin_name)
        if not plugin:
            logger.error(f"Plugin {plugin_name} not found")
            return None

        try:
            return await plugin.generate_payload(
                vulnerability, target, parameters or {}
            )
        except Exception as e:
            logger.error(f"Error generating payload with plugin {plugin_name}: {e}")
            return None

    async def execute_exploit(
        self,
        plugin_name: str,
        vulnerability: Vulnerability,
        target: Target,
        config: Optional[ExploitConfig] = None,
    ) -> ExploitResult:
        """Execute an exploit against a target.

        Args:
            plugin_name: Name of the plugin to use
            vulnerability: The vulnerability to exploit
            target: The target with the vulnerability
            config: Exploitation configuration

        Returns:
            Result of the exploitation attempt
        """
        plugin = self.get_plugin(plugin_name)
        if not plugin:
            return ExploitResult(
                success=False,
                message=f"Plugin {plugin_name} not found",
                raw_output="",
            )

        # Use default config if none provided
        config = config or ExploitConfig()

        try:
            # Check applicability first
            applicable = await plugin.check_applicability(vulnerability, target)
            if not applicable:
                return ExploitResult(
                    success=False,
                    message=f"Plugin {plugin_name} is not applicable to this vulnerability",
                    raw_output="",
                )

            # Generate payload
            payload = await plugin.generate_payload(
                vulnerability, target, config.parameters
            )
            if not payload:
                return ExploitResult(
                    success=False,
                    message=f"Failed to generate payload with plugin {plugin_name}",
                    raw_output="",
                )

            # Execute the exploit
            result_text, success = await plugin.execute_exploit(
                vulnerability, target, payload, config.safe_mode
            )

            # Create result object
            result = ExploitResult(
                success=success,
                message="Exploitation successful" if success else "Exploitation failed",
                raw_output=result_text,
                extracted_data=self._parse_result_data(result_text) if success else {},
            )

            return result
        except Exception as e:
            logger.error(f"Error executing exploit with plugin {plugin_name}: {e}")
            return ExploitResult(
                success=False,
                message=f"Error executing exploit: {str(e)}",
                raw_output="",
            )

    def _parse_result_data(self, result_text: str) -> Dict[str, Any]:
        """Parse structured data from exploit result.

        This is a simple implementation that could be extended to be smarter
        at extracting structured data from various exploit outputs.

        Args:
            result_text: Raw result text from the exploit

        Returns:
            Extracted structured data
        """
        data: Dict[str, Dict[str, str]] = {}

        # Simple extraction of key-value pairs
        lines = result_text.split("\n")
        current_section = "default"
        data[current_section] = {}

        for line in lines:
            line = line.strip()
            if not line or line.startswith("[-]"):
                continue

            if line.startswith("[+]"):
                # Section header
                current_section = line[4:].strip().lower().replace(" ", "_")
                if current_section not in data:
                    data[current_section] = {}
                continue

            if ":" in line:
                # Key-value pair
                parts = line.split(":", 1)
                key = parts[0].strip().lower().replace(" ", "_")
                value = parts[1].strip()
                data[current_section][key] = value

        # Clean up and flatten if possible
        if len(data) == 1 and "default" in data and not data["default"]:
            return {}

        return data

    async def find_matching_exploits(
        self, vulnerability: Vulnerability
    ) -> List[Exploit]:
        """Find exploits that could work for a given vulnerability.

        Args:
            vulnerability: The vulnerability to find exploits for

        Returns:
            List of matching exploits
        """
        matching_exploits = []

        # If we have service information, find exploits targeting that service
        if vulnerability.affected_component:
            service_exploits = await self.exploit_repo.get_exploits_by_service(
                vulnerability.affected_component.split()[0].lower()
            )
            matching_exploits.extend(service_exploits)

        # Find exploits by vulnerability type if we can deduce it
        exploit_type = self._deduce_exploit_type(vulnerability)
        if exploit_type:
            type_exploits = await self.exploit_repo.get_exploits_by_type(exploit_type)
            # Add exploits that weren't already added from the service search
            for exploit in type_exploits:
                if exploit not in matching_exploits:
                    matching_exploits.append(exploit)

        # Only return active exploits
        return [exploit for exploit in matching_exploits if exploit.is_active]

    def _deduce_exploit_type(
        self, vulnerability: Vulnerability
    ) -> Optional[ExploitType]:
        """Attempt to deduce the exploit type from the vulnerability.

        Args:
            vulnerability: The vulnerability

        Returns:
            The deduced exploit type or None
        """
        name = vulnerability.name.lower()
        description = (
            vulnerability.description.lower() if vulnerability.description else ""
        )

        # Check for common vulnerability types in the name or description
        if any(
            term in name or term in description for term in ["sql", "injection", "sqli"]
        ):
            return ExploitType.SQL_INJECTION
        elif any(
            term in name or term in description
            for term in ["command", "cmd", "rce", "code execution"]
        ):
            return ExploitType.COMMAND_INJECTION
        elif any(term in name or term in description for term in ["xss", "cross site"]):
            return ExploitType.XSS
        elif any(
            term in name or term in description
            for term in ["traversal", "directory", "path", "lfi", "rfi", "include"]
        ):
            return ExploitType.PATH_TRAVERSAL
        elif any(
            term in name or term in description
            for term in ["auth", "bypass", "authentication"]
        ):
            return ExploitType.AUTHENTICATION_BYPASS
        elif any(
            term in name or term in description
            for term in ["privilege", "escalation", "priv esc"]
        ):
            return ExploitType.PRIVILEGE_ESCALATION
        elif any(
            term in name or term in description for term in ["deserial", "serialize"]
        ):
            return ExploitType.DESERIALIZATION
        elif any(
            term in name or term in description
            for term in ["ssrf", "server side request"]
        ):
            return ExploitType.SSRF

        return None

    async def prioritize_exploits(
        self, vulnerability: Vulnerability, matching_exploits: List[Exploit]
    ) -> List[Tuple[Exploit, float]]:
        """Prioritize exploits based on various factors.

        Args:
            vulnerability: The vulnerability to exploit
            matching_exploits: List of matching exploits

        Returns:
            List of tuples containing (exploit, score)
        """
        if not matching_exploits:
            return []

        scored_exploits = []

        for exploit in matching_exploits:
            # Base score is the inverse of the risk level (lower risk = higher score)
            # Scale from 0-1 where 1 is best
            risk_score = 1 - (exploit.risk_level / 10)

            # Get historical success rate
            total, successful, success_rate = (
                await self.attempt_repo.get_success_rate_by_exploit(exploit.id)  # type: ignore
            )

            # Adjust for limited data
            if total < 5:
                # With limited data, we reduce the weight of success_rate
                success_score = 0.5 if total == 0 else success_rate * 0.7 + 0.3
            else:
                success_score = success_rate

            # Calculate final score (equal weights for now)
            final_score = (risk_score + success_score) / 2

            scored_exploits.append((exploit, final_score))

        # Sort by score in descending order
        return sorted(scored_exploits, key=lambda x: x[1], reverse=True)  # type: ignore

    async def analyze_vulnerability_for_exploitation(
        self, vulnerability_id: int, job_id: int
    ) -> Dict[str, Any]:
        """Analyze a vulnerability for potential exploitation.

        Args:
            vulnerability_id: The vulnerability ID
            job_id: The job ID

        Returns:
            Analysis results
        """
        vulnerability = await self.vuln_repo.get_vulnerability(vulnerability_id)
        if not vulnerability:
            raise ValueError(f"Vulnerability {vulnerability_id} not found")

        target = await self.target_repo.get_target(vulnerability.target_id)
        if not target:
            raise ValueError(f"Target {vulnerability.target_id} not found")

        # Find matching exploits
        matching_exploits = await self.find_matching_exploits(vulnerability)

        # Prioritize exploits
        prioritized_exploits = await self.prioritize_exploits(
            vulnerability, matching_exploits
        )

        # Prepare analysis results
        analysis = {
            "vulnerability_id": vulnerability_id,
            "vulnerability_name": vulnerability.name,
            "vulnerability_severity": vulnerability.severity.value,
            "target_id": target.id,
            "target_ip": target.ip_address,
            "target_hostname": target.hostname,
            "exploitability": {
                "is_exploitable": len(matching_exploits) > 0,
                "exploit_count": len(matching_exploits),
                "best_exploits": (
                    [
                        {
                            "id": exploit.id,
                            "name": exploit.name,
                            "type": exploit.exploit_type.value,
                            "risk_level": exploit.risk_level,
                            "score": score,
                        }
                        for exploit, score in prioritized_exploits[:3]  # Top 3 exploits
                    ]
                    if prioritized_exploits
                    else []
                ),
            },
            "recommendations": self._generate_recommendations(
                vulnerability, target, matching_exploits
            ),
        }

        return analysis

    def _generate_recommendations(
        self,
        vulnerability: Vulnerability,
        target: Target,
        matching_exploits: List[Exploit],
    ) -> Dict[str, Any]:
        """Generate recommendations based on the vulnerability and exploits.

        Args:
            vulnerability: The vulnerability
            target: The target
            matching_exploits: List of matching exploits

        Returns:
            Recommendations
        """
        recommendations = {
            "proceed_with_exploitation": False,
            "safe_mode_recommended": True,
            "rationale": "",
            "remediation_priority": "low",
        }

        # Determine if exploitation should proceed
        if matching_exploits:
            # By default, we recommend proceeding with critical and high vulns
            if vulnerability.severity in (
                VulnerabilitySeverity.CRITICAL,
                VulnerabilitySeverity.HIGH,
            ):
                recommendations["proceed_with_exploitation"] = True
                recommendations["remediation_priority"] = "high"
                recommendations["rationale"] = (
                    f"{vulnerability.severity.value} severity vulnerability with "
                    f"{len(matching_exploits)} available exploits. Recommend "
                    "verification through safe exploitation."
                )
            else:
                recommendations["rationale"] = (
                    f"{vulnerability.severity.value} severity vulnerability. "
                    "Risk may not justify exploitation. Consider manual verification."
                )
        else:
            recommendations["rationale"] = (
                "No matching exploits found. Cannot proceed with exploitation."
            )

        # Additional recommendation logic could be added here

        return recommendations

    async def get_success_rate_by_exploit(
        self, exploit: Exploit
    ) -> Tuple[int, int, float]:
        """
        Get the success rate for a specific exploit.

        Args:
            exploit: The exploit to get the success rate for

        Returns:
            Tuple of (total attempts, successful attempts, success rate)
        """
        if exploit.id is None:
            return (0, 0, 0.0)

        # Cast the Column[int] to an actual integer
        exploit_id: int = int(exploit.id)  # type: ignore

        # Use the repository to get the actual data
        total, successful, rate = await self.attempt_repo.get_success_rate_by_exploit(
            exploit_id
        )
        return (total, successful, float(rate))

    async def get_most_successful_exploits(
        self, limit: int = 10
    ) -> List[Tuple[Exploit, float]]:
        """
        Get the most successful exploits based on success rate.

        Args:
            limit: Maximum number of exploits to return

        Returns:
            List of tuples containing (exploit, success_rate)
        """
        exploits = await self.exploit_repo.get_active_exploits()
        results: List[Tuple[Exploit, float]] = []

        for exploit in exploits:
            total, successful, rate = await self.get_success_rate_by_exploit(exploit)
            # Ensure we have a proper float
            results.append((exploit, float(rate)))

        # Create a new list with explicit typing to avoid mypy issues
        typed_results: List[Tuple[Exploit, float]] = [(e, float(r)) for e, r in results]  # type: ignore

        # Sort by success rate, descending
        return sorted(typed_results, key=lambda x: x[1], reverse=True)[:limit]
