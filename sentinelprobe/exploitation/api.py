"""API routes for the Exploitation Engine."""

import logging
from datetime import datetime
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.core.db import get_db_session
from sentinelprobe.exploitation.models import (
    ExploitConfig,
    ExploitStatus,
    ExploitType,
    PayloadType,
)
from sentinelprobe.exploitation.service import ExploitationService
from sentinelprobe.vulnerability_scanner.repository import VulnerabilityRepository

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/exploitation", tags=["exploitation"])


class ExploitCreate(BaseModel):
    """Model for creating an exploit."""

    name: str = Field(..., description="Name of the exploit")
    description: str = Field(..., description="Description of the exploit")
    exploit_type: ExploitType = Field(..., description="Type of the exploit")
    target_services: List[str] = Field(
        ..., description="List of services this exploit targets"
    )
    payload_template: str = Field(..., description="Template for generating payloads")
    payload_type: PayloadType = Field(..., description="Type of payload")
    parameters: Dict[str, Any] = Field(
        ..., description="Required parameters for the exploit"
    )
    risk_level: int = Field(..., description="Risk level (1-10)", ge=1, le=10)
    target_versions: Optional[Dict[str, str]] = Field(
        None, description="Optional version ranges this exploit works on"
    )
    success_indicators: Optional[Dict[str, Any]] = Field(
        None, description="Optional indicators of successful exploitation"
    )
    exploit_metadata: Optional[Dict[str, Any]] = Field(
        None, description="Optional additional metadata"
    )


class ExploitResponse(BaseModel):
    """Model for exploit response."""

    id: int
    name: str
    description: str
    exploit_type: str
    target_services: List[str]
    payload_type: str
    risk_level: int
    is_active: bool
    target_versions: Optional[Dict[str, str]] = None
    exploit_metadata: Optional[Dict[str, Any]] = None


class ExploitAttemptCreate(BaseModel):
    """Model for creating an exploit attempt."""

    vulnerability_id: int = Field(..., description="ID of the vulnerability to exploit")
    exploit_id: int = Field(..., description="ID of the exploit to use")
    safe_mode: bool = Field(
        True, description="Whether to operate in safe mode (no real exploitation)"
    )


class ExploitAttemptResponse(BaseModel):
    """Model for exploit attempt response."""

    id: int
    job_id: int
    exploit_id: int
    vulnerability_id: int
    target_id: int
    status: str
    is_successful: bool
    execution_time: Optional[int] = None
    payload: Optional[str] = None
    result: Optional[str] = None
    attempt_metadata: Optional[Dict[str, Any]] = None


class VulnerabilityAnalysis(BaseModel):
    """Model for vulnerability analysis response."""

    vulnerability_id: int
    vulnerability_name: str
    vulnerability_severity: str
    target_id: int
    target_ip: str
    target_hostname: str
    exploitability: Dict[str, Any]
    recommendations: Dict[str, Any]


class PluginInfo(BaseModel):
    """Information about an exploit plugin."""

    name: str = Field(..., description="Name of the plugin")
    description: str = Field(..., description="Description of the plugin")
    exploit_type: str = Field(..., description="Type of exploit")
    payload_type: str = Field(..., description="Type of payload")
    target_services: List[str] = Field(..., description="Target services")
    risk_level: int = Field(..., description="Risk level (1-10)")


class ExploitConfigModel(BaseModel):
    """Configuration model for an exploit."""

    name: str
    plugin_name: str
    vulnerability_id: int
    parameters: Dict[str, Any] = {}


class ExploitResultModel(BaseModel):
    """Model for exploit execution results."""

    success: bool
    message: str
    raw_output: str = ""
    extracted_data: Dict[str, Any] = {}


class GeneratePayloadRequest(BaseModel):
    """Request model for generating an exploit payload."""

    plugin_name: str
    vulnerability_id: int
    parameters: Dict[str, Any] = {}


class GeneratePayloadResponse(BaseModel):
    """Response for a payload generation request."""

    plugin_name: str = Field(..., description="Name of the plugin used")
    vulnerability_id: int = Field(..., description="ID of the vulnerability")
    payload: str = Field(..., description="Generated payload")


class ExecuteExploitRequest(BaseModel):
    """Request to execute an exploit."""

    plugin_name: str = Field(..., description="Name of the plugin to use")
    vulnerability_id: int = Field(..., description="ID of the vulnerability to exploit")
    config: Optional[ExploitConfigModel] = Field(
        None, description="Configuration for the exploit"
    )


@router.post(
    "/exploits",
    response_model=ExploitResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new exploit",
)
async def create_exploit(
    exploit_data: ExploitCreate,
    session: AsyncSession = Depends(get_db_session),
) -> Any:
    """Create a new exploit.

    Args:
        exploit_data: Exploit data
        session: Database session

    Returns:
        Created exploit
    """
    service = ExploitationService(session)

    try:
        exploit = await service.exploit_repo.create_exploit(
            name=exploit_data.name,
            description=exploit_data.description,
            exploit_type=exploit_data.exploit_type,
            target_services=exploit_data.target_services,
            payload_template=exploit_data.payload_template,
            payload_type=exploit_data.payload_type,
            parameters=exploit_data.parameters,
            risk_level=exploit_data.risk_level,
            target_versions=exploit_data.target_versions,
            success_indicators=exploit_data.success_indicators,
            exploit_metadata=exploit_data.exploit_metadata,
        )

        return {
            "id": exploit.id,
            "name": exploit.name,
            "description": exploit.description,
            "exploit_type": exploit.exploit_type.value,
            "target_services": exploit.target_services,
            "payload_type": exploit.payload_type.value,
            "risk_level": exploit.risk_level,
            "is_active": exploit.is_active,
            "target_versions": exploit.target_versions,
            "exploit_metadata": exploit.exploit_metadata,
        }
    except Exception as e:
        logger.exception(f"Error creating exploit: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating exploit: {str(e)}",
        )


@router.get(
    "/exploits",
    response_model=List[ExploitResponse],
    summary="Get all exploits",
)
async def get_exploits(
    exploit_type: Optional[ExploitType] = None,
    service_type: Optional[str] = None,
    active_only: bool = True,
    session: AsyncSession = Depends(get_db_session),
) -> Any:
    """Get exploits with optional filtering.

    Args:
        exploit_type: Filter by exploit type
        service_type: Filter by service type
        active_only: Only return active exploits
        session: Database session

    Returns:
        List of exploits
    """
    service = ExploitationService(session)

    try:
        if exploit_type:
            exploits = await service.exploit_repo.get_exploits_by_type(exploit_type)
        elif service_type:
            exploits = await service.exploit_repo.get_exploits_by_service(service_type)
        elif active_only:
            exploits = await service.exploit_repo.get_active_exploits()
        else:
            # Get all exploits (could be more efficient with a custom query)
            # For now, we'll just filter the active exploits
            exploits = await service.exploit_repo.get_active_exploits()
            # TODO: Add a method to repository to get all exploits

        return [
            {
                "id": exploit.id,
                "name": exploit.name,
                "description": exploit.description,
                "exploit_type": exploit.exploit_type.value,
                "target_services": exploit.target_services,
                "payload_type": exploit.payload_type.value,
                "risk_level": exploit.risk_level,
                "is_active": exploit.is_active,
                "target_versions": exploit.target_versions,
                "exploit_metadata": exploit.exploit_metadata,
            }
            for exploit in exploits
        ]
    except Exception as e:
        logger.exception(f"Error getting exploits: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting exploits: {str(e)}",
        )


@router.get(
    "/exploits/{exploit_id}",
    response_model=ExploitResponse,
    summary="Get an exploit by ID",
)
async def get_exploit(
    exploit_id: int,
    session: AsyncSession = Depends(get_db_session),
) -> Any:
    """Get an exploit by ID.

    Args:
        exploit_id: ID of the exploit
        session: Database session

    Returns:
        The exploit
    """
    service = ExploitationService(session)

    try:
        exploit = await service.exploit_repo.get_exploit(exploit_id)

        if not exploit:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Exploit {exploit_id} not found",
            )

        return {
            "id": exploit.id,
            "name": exploit.name,
            "description": exploit.description,
            "exploit_type": exploit.exploit_type.value,
            "target_services": exploit.target_services,
            "payload_type": exploit.payload_type.value,
            "risk_level": exploit.risk_level,
            "is_active": exploit.is_active,
            "target_versions": exploit.target_versions,
            "exploit_metadata": exploit.exploit_metadata,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error getting exploit {exploit_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting exploit {exploit_id}: {str(e)}",
        )


@router.post(
    "/execute/{job_id}",
    response_model=ExploitAttemptResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Execute an exploit against a vulnerability",
)
async def execute_exploit(
    job_id: int,
    attempt_data: ExploitAttemptCreate,
    session: AsyncSession = Depends(get_db_session),
) -> Any:
    """Execute an exploit against a vulnerability.

    Args:
        job_id: ID of the job
        attempt_data: Exploit attempt data
        session: Database session

    Returns:
        Created exploit attempt
    """
    service = ExploitationService(session)
    vuln_repo = VulnerabilityRepository(session)

    try:
        # Get the vulnerability
        vulnerability = await vuln_repo.get_vulnerability(attempt_data.vulnerability_id)
        if not vulnerability:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Vulnerability {attempt_data.vulnerability_id} not found",
            )

        # Get the exploit
        exploit = await service.exploit_repo.get_exploit(attempt_data.exploit_id)
        if not exploit:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Exploit {attempt_data.exploit_id} not found",
            )

        # Get the target
        target = await service.target_repo.get_target(vulnerability.target_id)
        if not target:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Target {vulnerability.target_id} not found",
            )

        # Create the attempt
        attempt = await service.attempt_repo.create_attempt(
            job_id=job_id,
            exploit_id=attempt_data.exploit_id,
            vulnerability_id=attempt_data.vulnerability_id,
            target_id=target.id,
            attempt_metadata={"safe_mode": attempt_data.safe_mode},
        )
        if attempt is None:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to create exploit attempt",
            )

        # Update to in-progress
        if attempt.id is None:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Created attempt has no ID",
            )
        updated_attempt = await service.attempt_repo.update_attempt_status(
            int(attempt.id), ExploitStatus.IN_PROGRESS
        )
        if updated_attempt is None:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to update exploit attempt {attempt.id}",
            )
        attempt = updated_attempt

        # Execute the exploit
        start_time = datetime.now()

        # This is a simplified execution - in production this would be more complex
        is_successful = False

        # Update the attempt with the results
        execution_time = int((datetime.now() - start_time).total_seconds() * 1000)
        if attempt.id is None:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Attempt has no ID",
            )
        updated_attempt = await service.attempt_repo.update_attempt_status(
            int(attempt.id),
            ExploitStatus.SUCCESSFUL if is_successful else ExploitStatus.FAILED,
            result="Execution results would be here",
            is_successful=is_successful,
            execution_time=execution_time,
        )
        if updated_attempt is None:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to update exploit attempt {attempt.id} with results",
            )
        attempt = updated_attempt

        return {
            "id": attempt.id,
            "job_id": attempt.job_id,
            "exploit_id": attempt.exploit_id,
            "vulnerability_id": attempt.vulnerability_id,
            "target_id": attempt.target_id,
            "status": attempt.status.value,
            "is_successful": attempt.is_successful,
            "execution_time": attempt.execution_time,
            "payload": attempt.payload,
            "result": attempt.result,
            "attempt_metadata": attempt.attempt_metadata,
        }
    except Exception as e:
        logger.exception(f"Error executing exploit: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error executing exploit: {str(e)}",
        )


@router.get(
    "/attempts/{attempt_id}",
    response_model=ExploitAttemptResponse,
    summary="Get an exploit attempt by ID",
)
async def get_attempt(
    attempt_id: int,
    session: AsyncSession = Depends(get_db_session),
) -> Any:
    """Get an exploit attempt by ID.

    Args:
        attempt_id: ID of the attempt
        session: Database session

    Returns:
        The exploit attempt
    """
    service = ExploitationService(session)

    try:
        attempt = await service.attempt_repo.get_attempt(attempt_id)

        if not attempt:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Exploit attempt {attempt_id} not found",
            )

        return {
            "id": attempt.id,
            "job_id": attempt.job_id,
            "exploit_id": attempt.exploit_id,
            "vulnerability_id": attempt.vulnerability_id,
            "target_id": attempt.target_id,
            "status": attempt.status.value,
            "is_successful": attempt.is_successful,
            "execution_time": attempt.execution_time,
            "payload": attempt.payload,
            "result": attempt.result,
            "attempt_metadata": attempt.attempt_metadata,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Error getting attempt {attempt_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting attempt {attempt_id}: {str(e)}",
        )


@router.get(
    "/analyze/{job_id}/vulnerability/{vulnerability_id}",
    response_model=VulnerabilityAnalysis,
    summary="Analyze a vulnerability for exploitation",
)
async def analyze_vulnerability(
    job_id: int,
    vulnerability_id: int,
    session: AsyncSession = Depends(get_db_session),
) -> Any:
    """Analyze a vulnerability for potential exploitation.

    Args:
        job_id: ID of the job
        vulnerability_id: ID of the vulnerability
        session: Database session

    Returns:
        Analysis results
    """
    service = ExploitationService(session)

    try:
        analysis = await service.analyze_vulnerability_for_exploitation(
            vulnerability_id=vulnerability_id,
            job_id=job_id,
        )

        return analysis
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except Exception as e:
        logger.exception(f"Error analyzing vulnerability {vulnerability_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error analyzing vulnerability {vulnerability_id}: {str(e)}",
        )


@router.get("/plugins", response_model=List[PluginInfo])
async def get_plugins(
    session: AsyncSession = Depends(get_db_session),
) -> List[PluginInfo]:
    """Get all available exploit plugins.

    Args:
        session: Database session

    Returns:
        List of plugin information
    """
    service = ExploitationService(session)
    plugins_data = service.get_available_plugins()

    # Convert to PluginInfo models
    result: List[PluginInfo] = []
    for plugin_data in plugins_data:
        plugin_info = PluginInfo(
            name=plugin_data["name"],
            description=plugin_data["description"],
            exploit_type=plugin_data["exploit_type"],
            payload_type=plugin_data["payload_type"],
            target_services=plugin_data["target_services"],
            risk_level=plugin_data["risk_level"],
        )
        result.append(plugin_info)

    return result


@router.get("/plugins/{plugin_name}", response_model=PluginInfo)
async def get_plugin(
    plugin_name: str,
    session: AsyncSession = Depends(get_db_session),
) -> PluginInfo:
    """Get information about a specific plugin.

    Args:
        plugin_name: Name of the plugin
        session: Database session

    Returns:
        Plugin information
    """
    service = ExploitationService(session)
    plugin = service.get_plugin(plugin_name)

    if not plugin:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Plugin {plugin_name} not found",
        )

    return PluginInfo(
        name=plugin.name,
        description=plugin.description,
        exploit_type=plugin.exploit_type.value,
        payload_type=plugin.payload_type.value,
        target_services=plugin.target_services,
        risk_level=plugin.risk_level,
    )


@router.get(
    "/plugins/by-vulnerability/{vulnerability_id}", response_model=List[PluginInfo]
)
async def get_plugins_for_vulnerability(
    vulnerability_id: int,
    session: AsyncSession = Depends(get_db_session),
) -> List[PluginInfo]:
    """Get all plugins applicable to a specific vulnerability.

    Args:
        vulnerability_id: ID of the vulnerability
        session: Database session

    Returns:
        List of applicable plugins
    """
    service = ExploitationService(session)
    vuln_repo = VulnerabilityRepository(session)

    vulnerability = await vuln_repo.get_vulnerability(vulnerability_id)
    if not vulnerability:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Vulnerability {vulnerability_id} not found",
        )

    target = await service.target_repo.get_target(vulnerability.target_id)
    if not target:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Target {vulnerability.target_id} not found",
        )

    applicable_plugins = await service.find_applicable_plugins(vulnerability, target)

    # Convert to PluginInfo models
    result: List[PluginInfo] = []
    for plugin in applicable_plugins:
        plugin_info = PluginInfo(
            name=plugin.name,
            description=plugin.description,
            exploit_type=plugin.exploit_type.value,
            payload_type=plugin.payload_type.value,
            target_services=plugin.target_services,
            risk_level=plugin.risk_level,
        )
        result.append(plugin_info)

    return result


@router.post("/payload", response_model=GeneratePayloadResponse)
async def generate_payload(
    request: GeneratePayloadRequest,
    session: AsyncSession = Depends(get_db_session),
) -> GeneratePayloadResponse:
    """Generate an exploit payload.

    Args:
        request: Payload generation request
        session: Database session

    Returns:
        Generated payload
    """
    service = ExploitationService(session)
    vuln_repo = VulnerabilityRepository(session)

    vulnerability = await vuln_repo.get_vulnerability(request.vulnerability_id)
    if not vulnerability:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Vulnerability {request.vulnerability_id} not found",
        )

    target = await service.target_repo.get_target(vulnerability.target_id)
    if not target:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Target {vulnerability.target_id} not found",
        )

    plugin = service.get_plugin(request.plugin_name)
    if not plugin:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Plugin {request.plugin_name} not found",
        )

    payload = await service.generate_payload(
        request.plugin_name, vulnerability, target, request.parameters
    )
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to generate payload with plugin {request.plugin_name}",
        )

    return GeneratePayloadResponse(
        plugin_name=request.plugin_name,
        vulnerability_id=request.vulnerability_id,
        payload=payload,
    )


@router.post("/execute", response_model=ExploitResultModel)
async def execute_exploit_api(
    request: ExecuteExploitRequest,
    session: AsyncSession = Depends(get_db_session),
) -> ExploitResultModel:
    """Execute an exploit against a target.

    Args:
        request: The execution request
        session: Database session

    Returns:
        Result of the exploit
    """
    service = ExploitationService(session)
    vuln_repo = VulnerabilityRepository(session)

    try:
        # Get the vulnerability
        vulnerability = await vuln_repo.get_vulnerability(request.vulnerability_id)
        if not vulnerability:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Vulnerability {request.vulnerability_id} not found",
            )

        # Get the target
        target = await service.target_repo.get_target(vulnerability.target_id)
        if not target:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Target {vulnerability.target_id} not found",
            )

        # Get the plugin
        plugin = service.get_plugin(request.plugin_name)
        if not plugin:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Plugin {request.plugin_name} not found",
            )

        # Check applicability
        applicable = await plugin.check_applicability(vulnerability, target)
        if not applicable:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Plugin {request.plugin_name} is not applicable to this vulnerability",
            )

        # Create config
        config = request.config.dict() if request.config else {}
        config_obj = ExploitConfig(**config)

        # Execute exploit
        result = await service.execute_exploit(
            request.plugin_name, vulnerability, target, config_obj
        )

        # Return result
        return ExploitResultModel(
            success=result.success,
            message=result.message,
            raw_output=result.raw_output,
            extracted_data=result.extracted_data,
        )
    except Exception as e:
        logger.exception(f"Error executing exploit: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error executing exploit: {str(e)}",
        )
