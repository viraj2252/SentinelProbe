"""Data models for the Exploitation Engine."""

import enum
from datetime import datetime
from typing import Any, Dict, List, Optional, Union

from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Enum,
    ForeignKey,
    Integer,
    String,
    Text,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship

from sentinelprobe.core.db import Base


class ExploitStatus(enum.Enum):
    """Status of an exploit attempt."""

    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESSFUL = "successful"
    FAILED = "failed"
    ABORTED = "aborted"


class ExploitType(str, enum.Enum):
    """Types of exploits."""

    SQL_INJECTION = "SQL_INJECTION"
    COMMAND_INJECTION = "COMMAND_INJECTION"
    XSS = "XSS"
    XXE = "XXE"
    CSRF = "CSRF"
    SSRF = "SSRF"
    PATH_TRAVERSAL = "PATH_TRAVERSAL"
    FILE_INCLUSION = "FILE_INCLUSION"
    DESERIALIZATION = "DESERIALIZATION"
    BUFFER_OVERFLOW = "BUFFER_OVERFLOW"
    FORMAT_STRING = "FORMAT_STRING"
    RACE_CONDITION = "RACE_CONDITION"
    PRIVILEGE_ESCALATION = "PRIVILEGE_ESCALATION"
    AUTHENTICATION_BYPASS = "AUTHENTICATION_BYPASS"
    BUSINESS_LOGIC = "BUSINESS_LOGIC"
    DEFAULT_CREDENTIALS = "DEFAULT_CREDENTIALS"
    SECURITY_MISCONFIGURATION = "SECURITY_MISCONFIGURATION"
    OTHER = "OTHER"


class PayloadType(str, enum.Enum):
    """Types of exploit payloads."""

    SQL_QUERY = "SQL_QUERY"
    SHELL_COMMAND = "SHELL_COMMAND"
    JAVASCRIPT = "JAVASCRIPT"
    XML = "XML"
    FILE_PATH = "FILE_PATH"
    HTTP_REQUEST = "HTTP_REQUEST"
    SERIALIZED_DATA = "SERIALIZED_DATA"
    BINARY = "BINARY"
    PASSWORD = "PASSWORD"
    CONFIGURATION = "CONFIGURATION"
    OTHER = "OTHER"


class Exploit(Base):
    """Exploit model representing a potential exploit for vulnerabilities."""

    __tablename__ = "exploits"

    id = Column(Integer, primary_key=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    exploit_type: Column[Enum] = Column(Enum(ExploitType), nullable=False)
    target_services = Column(
        JSONB, nullable=False
    )  # List of service types this exploit targets
    target_versions = Column(
        JSONB, nullable=True
    )  # Version ranges this exploit works on
    payload_template = Column(
        Text, nullable=False
    )  # Template for generating the payload
    payload_type: Column[Enum] = Column(Enum(PayloadType), nullable=False)
    parameters = Column(JSONB, nullable=False)  # Required parameters for the exploit
    success_indicators = Column(
        JSONB, nullable=True
    )  # Indicators that the exploit was successful
    risk_level = Column(Integer, nullable=False)  # 1-10 risk level of the exploit
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    exploit_metadata = Column(JSONB, nullable=True)  # Additional metadata

    exploit_attempts = relationship("ExploitAttempt", back_populates="exploit")


class ExploitAttempt(Base):
    """Record of an attempt to exploit a vulnerability."""

    __tablename__ = "exploit_attempts"

    id = Column(Integer, primary_key=True)
    job_id = Column(Integer, nullable=False, index=True)
    exploit_id = Column(Integer, ForeignKey("exploits.id"), nullable=False)
    vulnerability_id = Column(Integer, ForeignKey("vulnerabilities.id"), nullable=False)
    target_id = Column(Integer, ForeignKey("targets.id"), nullable=False)
    status: Column[Enum] = Column(
        Enum(ExploitStatus), nullable=False, default=ExploitStatus.PENDING
    )
    payload = Column(Text, nullable=True)  # The actual payload used
    parameters_used = Column(JSONB, nullable=True)  # Parameters used for this attempt
    result = Column(Text, nullable=True)  # Result output from the exploit
    is_successful = Column(Boolean, default=False)
    execution_time = Column(Integer, nullable=True)  # Time taken in milliseconds
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    attempt_metadata = Column(JSONB, nullable=True)  # Additional metadata

    exploit = relationship("Exploit", back_populates="exploit_attempts")
    vulnerability = relationship("Vulnerability", backref="exploit_attempts")

    @property
    def duration_seconds(self) -> Optional[float]:
        """Get the duration in seconds."""
        if self.execution_time is not None:
            return float(self.execution_time) / 1000.0
        return None


class ExploitResult:
    """Result of an exploit attempt."""

    def __init__(
        self,
        success: bool,
        message: str,
        raw_output: str = "",
        extracted_data: Optional[
            Dict[str, Union[str, List[str], Dict[str, str]]]
        ] = None,
    ):
        """Initialize the exploit result.

        Args:
            success: Whether the exploit was successful
            message: Human-readable description of the result
            raw_output: Raw output from the exploit attempt
            extracted_data: Any data extracted during the exploit
        """
        self.success = success
        self.message = message
        self.raw_output = raw_output
        self.extracted_data = extracted_data or {}

    def __str__(self) -> str:
        """Get string representation of the exploit result.

        Returns:
            String representation
        """
        status = "[+]" if self.success else "[-]"
        return f"{status} {self.message}"

    def to_dict(self) -> Dict[str, Union[bool, str, Dict]]:
        """Convert the result to a dictionary.

        Returns:
            Dictionary representation
        """
        return {
            "success": self.success,
            "message": self.message,
            "raw_output": self.raw_output,
            "extracted_data": self.extracted_data,
        }


class ExploitConfig:
    """Configuration for an exploit."""

    def __init__(
        self,
        safe_mode: bool = True,
        timeout: int = 30,
        max_attempts: int = 3,
        parameters: Optional[Dict[str, Union[str, int, bool, List, Dict]]] = None,
    ):
        """Initialize the exploit configuration.

        Args:
            safe_mode: Whether to operate in safe mode (no real exploitation)
            timeout: Timeout in seconds for the exploit
            max_attempts: Maximum number of attempts to try
            parameters: Additional parameters for the exploit
        """
        self.safe_mode = safe_mode
        self.timeout = timeout
        self.max_attempts = max_attempts
        self.parameters = parameters or {}

    def to_dict(self) -> Dict[str, Union[bool, int, Dict]]:
        """Convert the configuration to a dictionary.

        Returns:
            Dictionary representation
        """
        return {
            "safe_mode": self.safe_mode,
            "timeout": self.timeout,
            "max_attempts": self.max_attempts,
            "parameters": self.parameters,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ExploitConfig":
        """Create an ExploitConfig from a dictionary.

        Args:
            data: Dictionary to create the configuration from

        Returns:
            ExploitConfig instance
        """
        return cls(
            safe_mode=data.get("safe_mode", True),
            timeout=data.get("timeout", 30),
            max_attempts=data.get("max_attempts", 3),
            parameters=data.get("parameters", {}),
        )
