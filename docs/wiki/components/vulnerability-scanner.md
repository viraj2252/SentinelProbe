# Vulnerability Scanner

The Vulnerability Scanner module is a core component of SentinelProbe that identifies security weaknesses in target systems through various testing methodologies. It builds upon the information gathered by the Reconnaissance Module to perform targeted vulnerability assessments.

## Overview

The Vulnerability Scanner analyzes target systems for security vulnerabilities using a plugin-based architecture that allows for specialized scanning techniques for different service types. It prioritizes findings based on severity, exploitability, and business impact to help focus remediation efforts on the most critical issues.

## Key Features

### Vulnerability Detection

- **Service-Specific Scanning**: Specialized scanners for different service types (HTTP, SSH, MySQL, Redis, MongoDB)
- **Comprehensive Coverage**: Detects a wide range of vulnerability types
- **Configurable Scan Depth**: Multiple scan types from basic to comprehensive
- **Custom Scan Parameters**: Tailored scanning based on target characteristics

### Vulnerability Management

- **Severity Classification**: Categorizes vulnerabilities by severity (Info, Low, Medium, High, Critical)
- **Status Tracking**: Tracks vulnerability status (Unconfirmed, Confirmed, False Positive, Remediated, Not Fixed)
- **Detailed Reporting**: Comprehensive information about each vulnerability
- **Remediation Guidance**: Actionable recommendations for fixing vulnerabilities

### Advanced Capabilities

- **Attack Pattern Matching**: Correlates findings with known attack patterns
- **Vulnerability Prioritization**: Scores vulnerabilities based on multiple factors
- **Business Impact Assessment**: Evaluates the potential business impact of vulnerabilities
- **Exploitability Analysis**: Determines how easily vulnerabilities can be exploited

## Architecture

The Vulnerability Scanner consists of several key components:

### Scanner Service

The `VulnerabilityScannerService` class is the central component that:

- Manages the scanning process
- Coordinates plugin execution
- Processes and stores scan results
- Handles scan status updates

### Plugin System

The scanner uses a plugin-based architecture with:

- `ScannerPlugin`: Base class for all scanner plugins
- Service-specific plugins (HTTP, SSH, MySQL, Redis, MongoDB)
- Extensible framework for adding new scanner types

### Models

Key data models include:

- `VulnerabilityScan`: Represents a scan configuration and execution
- `Vulnerability`: Represents a detected vulnerability
- `AttackPattern`: Represents known attack patterns
- `VulnerabilityAttackPatternMapping`: Links vulnerabilities to attack patterns

### Repository

Database interaction is handled by:

- `VulnerabilityScanRepository`: Manages scan configurations and results
- `VulnerabilityRepository`: Stores and retrieves vulnerability data
- `AttackPatternRepository`: Manages attack pattern information

### Prioritization Engine

The `priority.py` module provides:

- Vulnerability scoring algorithms
- Business impact assessment
- Exploitability scoring
- Vulnerability prioritization logic

## Scanner Plugins

The Vulnerability Scanner includes several specialized plugins:

### HTTP Scanner

- Detects web application vulnerabilities
- Checks for misconfigurations in web servers
- Identifies outdated software versions
- Tests for common web security issues (XSS, CSRF, etc.)

### SSH Scanner

- Checks for weak SSH configurations
- Identifies outdated SSH versions
- Tests for weak authentication mechanisms
- Detects insecure cipher suites

### MySQL Scanner

- Identifies database security misconfigurations
- Checks for weak authentication settings
- Detects outdated MySQL versions with known vulnerabilities
- Tests for excessive privileges

### Redis Scanner

- Checks for authentication issues
- Identifies insecure Redis configurations
- Detects public exposure of Redis instances
- Tests for outdated versions with known vulnerabilities

### MongoDB Scanner

- Identifies authentication issues
- Checks for insecure MongoDB configurations
- Detects outdated MongoDB versions
- Tests for excessive permissions

## Scan Types

The Vulnerability Scanner supports different scan types:

| Scan Type | Description | Use Case |
|-----------|-------------|----------|
| `BASIC` | Quick scan for common vulnerabilities | Initial assessment |
| `STANDARD` | Balanced scan with moderate depth | Regular security testing |
| `COMPREHENSIVE` | In-depth scan with extensive testing | Thorough security assessment |
| `CUSTOM` | User-defined scan parameters | Specialized testing scenarios |

## Usage Examples

### Programmatic Usage

```python
from sentinelprobe.core.db import get_session
from sentinelprobe.vulnerability_scanner.repository import (
    VulnerabilityScanRepository, VulnerabilityRepository
)
from sentinelprobe.vulnerability_scanner.service import VulnerabilityScannerService
from sentinelprobe.vulnerability_scanner.models import (
    VulnerabilityScanCreate, ScanType
)

async def run_vulnerability_scan(target_id: int, job_id: int):
    """Run a vulnerability scan on a target."""
    async with get_session() as session:
        # Initialize repositories
        scan_repo = VulnerabilityScanRepository(session)
        vuln_repo = VulnerabilityRepository(session)

        # Initialize scanner service
        scanner_service = VulnerabilityScannerService(
            scan_repository=scan_repo,
            vulnerability_repository=vuln_repo,
            session=session
        )

        # Create a scan configuration
        scan_data = VulnerabilityScanCreate(
            job_id=job_id,
            target_id=target_id,
            name="Comprehensive Web Server Scan",
            description="Full security assessment of web server",
            scan_type=ScanType.COMPREHENSIVE,
            scanner_module="http_scanner",
            parameters={
                "check_ssl": True,
                "check_headers": True,
                "check_common_vulnerabilities": True,
                "port": 443
            }
        )

        # Create and run the scan
        scan = await scanner_service.create_scan(scan_data)
        await scanner_service.run_scan(scan.id)

        # Wait for scan completion
        scan = await scanner_service.get_scan(scan.id)
        while scan.status not in ["completed", "failed", "cancelled"]:
            await asyncio.sleep(5)
            scan = await scanner_service.get_scan(scan.id)

        # Get vulnerabilities
        vulnerabilities = await vuln_repo.get_vulnerabilities_by_scan(scan.id)

        # Print results
        print(f"Scan completed with {len(vulnerabilities)} vulnerabilities found")
        for vuln in vulnerabilities:
            print(f"- {vuln.name} ({vuln.severity.value}): {vuln.description}")
```

### API Usage

```python
import aiohttp
import asyncio

async def run_scan_via_api():
    """Run a vulnerability scan via the SentinelProbe API."""
    async with aiohttp.ClientSession() as session:
        # Create a scan
        create_response = await session.post(
            "http://localhost:8000/api/vulnerability-scanner/scans",
            json={
                "job_id": 1,
                "target_id": 2,
                "name": "API-Triggered Scan",
                "description": "Vulnerability scan initiated via API",
                "scan_type": "standard",
                "scanner_module": "http_scanner",
                "parameters": {
                    "check_ssl": True,
                    "port": 443
                }
            }
        )
        scan_data = await create_response.json()
        scan_id = scan_data["id"]

        # Start the scan
        start_response = await session.post(
            f"http://localhost:8000/api/vulnerability-scanner/scans/{scan_id}/start"
        )

        # Check scan status
        while True:
            status_response = await session.get(
                f"http://localhost:8000/api/vulnerability-scanner/scans/{scan_id}"
            )
            status_data = await status_response.json()
            if status_data["status"] in ["completed", "failed", "cancelled"]:
                break
            await asyncio.sleep(5)

        # Get vulnerabilities
        vulns_response = await session.get(
            f"http://localhost:8000/api/vulnerability-scanner/scans/{scan_id}/vulnerabilities"
        )
        vulns_data = await vulns_response.json()

        return {
            "scan": status_data,
            "vulnerabilities": vulns_data
        }

# Run the async function
loop = asyncio.get_event_loop()
results = loop.run_until_complete(run_scan_via_api())
```

### Command Line Usage

```bash
# Run a basic scan on a target
python -m sentinelprobe vulnerability-scanner scan --target-id 1 --job-id 1 --scan-type basic --scanner http_scanner

# Run a comprehensive scan with custom parameters
python -m sentinelprobe vulnerability-scanner scan --target-id 2 --job-id 1 --scan-type comprehensive --scanner ssh_scanner --params '{"port": 22, "check_ciphers": true}'

# Get scan results
python -m sentinelprobe vulnerability-scanner results --scan-id 1 --format json
```

## Integration with AI Decision Engine

The Vulnerability Scanner integrates with the AI Decision Engine in several ways:

1. **Scan Selection**: The AI Decision Engine determines which scanners to use based on reconnaissance results
2. **Parameter Tuning**: Scan parameters are optimized based on target characteristics
3. **Result Analysis**: Scan results are analyzed to identify patterns and correlations
4. **Prioritization**: Vulnerabilities are prioritized based on multiple factors including AI-driven risk assessment

## Vulnerability Prioritization

The scanner uses a sophisticated prioritization system that considers:

1. **Base Severity**: The inherent severity of the vulnerability
2. **Exploitability**: How easily the vulnerability can be exploited
3. **Business Impact**: The potential impact on business operations
4. **Environmental Factors**: Context-specific factors that may increase or decrease risk
5. **Attack Pattern Correlation**: Relationship to known attack patterns

The final score is calculated using a weighted formula:

```
Score = (BaseSeverity * 0.4) + (Exploitability * 0.3) + (BusinessImpact * 0.3)
```

## Attack Pattern Matching

The Vulnerability Scanner includes an attack pattern matching system that:

1. Maintains a database of known attack patterns
2. Correlates vulnerabilities with these patterns
3. Identifies potential attack chains
4. Provides context for understanding the risk

## Performance Considerations

To optimize the performance of the Vulnerability Scanner:

- **Targeted Scanning**: Focus on relevant services rather than scanning everything
- **Scan Depth**: Adjust scan depth based on requirements and time constraints
- **Concurrent Scanning**: Run multiple scanners in parallel when appropriate
- **Resource Allocation**: Allocate sufficient resources for intensive scans

## Security and Ethical Considerations

When using the Vulnerability Scanner:

- **Obtain Permission**: Always have explicit permission before scanning any system
- **Minimize Impact**: Use appropriate scan parameters to avoid disrupting services
- **Handle Results Securely**: Treat vulnerability information as highly sensitive
- **Follow Responsible Disclosure**: If testing third-party systems, follow responsible disclosure practices

## Extending the Scanner

The plugin-based architecture makes it easy to extend the Vulnerability Scanner:

1. Create a new scanner plugin by subclassing `ScannerPlugin`
2. Implement the `scan` method with your custom logic
3. Register the plugin in the `SCANNER_PLUGINS` dictionary in `VulnerabilityScannerService`

Example of a custom scanner plugin:

```python
from sentinelprobe.vulnerability_scanner.scanner_plugin import ScannerPlugin
from sentinelprobe.vulnerability_scanner.models import (
    VulnerabilityCreate, VulnerabilitySeverity, VulnerabilityStatus
)

class CustomServiceScanner(ScannerPlugin):
    """Custom scanner for a specific service."""

    name = "custom_service_scanner"
    description = "Scanner for detecting vulnerabilities in Custom Service"

    async def scan(self, scan, target_id, parameters):
        """Perform a vulnerability scan for the custom service."""
        vulnerabilities = []

        # Custom scanning logic here
        # ...

        # Example vulnerability
        vulnerabilities.append(
            VulnerabilityCreate(
                scan_id=scan.id,
                target_id=target_id,
                name="Custom Service Vulnerability",
                description="A vulnerability in the custom service",
                severity=VulnerabilitySeverity.HIGH,
                status=VulnerabilityStatus.UNCONFIRMED,
                affected_component="custom-service",
                details={
                    "finding_type": "custom",
                    "technical_details": "Technical details about the vulnerability"
                },
                remediation="Steps to fix the vulnerability"
            )
        )

        return vulnerabilities
```

## Troubleshooting

### Common Issues

1. **Scan Failures**:
   - Check network connectivity to the target
   - Verify that required ports are accessible
   - Ensure sufficient permissions for the scan

2. **False Positives**:
   - Adjust scan parameters for more accurate results
   - Use the vulnerability status system to mark false positives
   - Provide feedback to improve scanner accuracy

3. **Performance Issues**:
   - Reduce scan scope or depth
   - Increase timeouts for slow targets
   - Run scans during off-peak hours

## API Reference

For a complete API reference, see the [API Documentation](../advanced/api-reference.md#vulnerability-scanner).
