"""Test fixtures for the Vulnerability Scanner module."""

import asyncio
from typing import AsyncGenerator
from unittest.mock import AsyncMock, patch

import pytest
import pytest_asyncio
from fastapi import FastAPI
from fastapi.testclient import TestClient
from sqlalchemy import MetaData
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from sentinelprobe.vulnerability_scanner.api import router as vulnerability_router
from sentinelprobe.vulnerability_scanner.attack_pattern_api import (
    router as attack_pattern_router,
)
from sentinelprobe.vulnerability_scanner.attack_patterns import (
    AttackPattern,
    VulnerabilityAttackPatternMapping,
)
from sentinelprobe.vulnerability_scanner.models import (
    ScanStatus,
    ScanType,
    Vulnerability,
    VulnerabilityScan,
    VulnerabilitySeverity,
    VulnerabilityStatus,
)


@pytest_asyncio.fixture
async def test_db_session() -> AsyncGenerator[AsyncSession, None]:
    """Create a test database session."""
    # Create an in-memory database for testing
    engine = create_async_engine("sqlite+aiosqlite:///:memory:")

    # Create only the tables needed for vulnerability tests
    async with engine.begin() as conn:
        # Create a temporary metadata with only the tables we need
        metadata = MetaData()

        # Import the models we need
        from sentinelprobe.ai_decision.models import TestStrategy
        from sentinelprobe.orchestration.models import Job
        from sentinelprobe.reconnaissance.models import Target

        # Copy the table definitions we need
        for table in [
            VulnerabilityScan.__table__,
            Vulnerability.__table__,
            AttackPattern.__table__,
            VulnerabilityAttackPatternMapping.__table__,
            Job.__table__,
            Target.__table__,
            TestStrategy.__table__,
        ]:
            table.to_metadata(metadata)

        # Create only these tables
        await conn.run_sync(metadata.create_all)

    # Create session
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

    # Yield a session
    async with async_session() as session:
        yield session

    # Cleanup
    async with engine.begin() as conn:
        await conn.run_sync(metadata.drop_all)


@pytest.fixture
def test_app():
    """Create a test FastAPI application."""
    app = FastAPI()
    app.include_router(vulnerability_router)
    app.include_router(attack_pattern_router)
    return app


@pytest.fixture
def test_client(test_app):
    """Create a test client for the application."""
    return TestClient(test_app)


@pytest_asyncio.fixture
async def mock_vulnerability_scan(test_db_session) -> VulnerabilityScan:
    """Create a mock vulnerability scan for testing."""
    scan = VulnerabilityScan(
        job_id=1,
        target_id=1,
        name="Test Scan",
        description="Test scan description",
        scan_type=ScanType.STANDARD,
        status=ScanStatus.PENDING,
        scanner_module="test_scanner",
        parameters={},
        scan_metadata={},
    )
    test_db_session.add(scan)
    await test_db_session.commit()
    await test_db_session.refresh(scan)
    return scan


@pytest_asyncio.fixture
async def mock_vulnerability(test_db_session, mock_vulnerability_scan) -> Vulnerability:
    """Create a mock vulnerability for testing."""
    vulnerability = Vulnerability(
        scan_id=mock_vulnerability_scan.id,
        target_id=1,
        name="Test Vulnerability",
        description="Test vulnerability description",
        severity=VulnerabilitySeverity.HIGH,
        status=VulnerabilityStatus.UNCONFIRMED,
        affected_component="Test Component",
        details={"test": "data"},
    )
    test_db_session.add(vulnerability)
    await test_db_session.commit()
    await test_db_session.refresh(vulnerability)
    return vulnerability
