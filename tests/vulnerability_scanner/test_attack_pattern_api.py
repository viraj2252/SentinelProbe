"""Tests for the Attack Pattern API endpoints."""

import json
from typing import Any, Dict, List

import pytest
from fastapi.testclient import TestClient

from sentinelprobe.vulnerability_scanner.attack_patterns import AttackType, AttackVector
from sentinelprobe.vulnerability_scanner.models import VulnerabilitySeverity


class TestAttackPatternAPI:
    """Tests for the Attack Pattern API."""

    def test_create_attack_pattern(self, test_client: TestClient, monkeypatch):
        """Test creating an attack pattern via API."""
        # Create test data
        attack_pattern_data = {
            "name": "SQL Injection",
            "description": "SQL injection attack pattern",
            "attack_type": "injection",
            "attack_vector": "web",
            "typical_severity": "high",
            "mitre_id": "T1190",
            "capec_id": "CAPEC-66",
            "cwe_ids": ["CWE-89"],
            "pattern_details": {"query_params": True, "body_params": True},
            "pattern_indicators": {"input_validation": False},
            "detection_guidance": "Monitor SQL error messages",
            "remediation_guidance": "Use parameterized queries",
        }

        # Mock repository call
        async def mock_create_attack_pattern(*args, **kwargs):
            # Return a mock attack pattern with ID 1
            return type(
                "AttackPattern",
                (),
                {
                    "__dict__": {
                        "id": 1,
                        "name": "SQL Injection",
                        "description": "SQL injection attack pattern",
                        "attack_type": AttackType.INJECTION,
                        "attack_vector": AttackVector.WEB,
                        "typical_severity": VulnerabilitySeverity.HIGH,
                        "mitre_id": "T1190",
                        "capec_id": "CAPEC-66",
                        "cwe_ids": ["CWE-89"],
                        "pattern_details": {"query_params": True, "body_params": True},
                        "pattern_indicators": {"input_validation": False},
                        "detection_guidance": "Monitor SQL error messages",
                        "remediation_guidance": "Use parameterized queries",
                        "created_at": "2023-01-01T00:00:00",
                        "updated_at": "2023-01-01T00:00:00",
                    }
                },
            )

        # Mock get_attack_pattern_by_name to return None (no existing pattern)
        async def mock_get_attack_pattern_by_name(*args, **kwargs):
            return None

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.create_attack_pattern",
            mock_create_attack_pattern,
        )
        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_pattern_by_name",
            mock_get_attack_pattern_by_name,
        )

        # Make API request
        response = test_client.post(
            "/api/v1/attack-patterns",
            json=attack_pattern_data,
        )

        # Assertions
        assert (
            response.status_code == 201
        ), f"Unexpected status code: {response.status_code} - {response.text}"
        data = response.json()
        assert data["id"] == 1
        assert data["name"] == "SQL Injection"
        assert data["attack_type"] == "injection"
        assert data["typical_severity"] == "high"

    def test_create_attack_pattern_duplicate_name(
        self, test_client: TestClient, monkeypatch
    ):
        """Test creating an attack pattern with a duplicate name."""
        # Create test data
        attack_pattern_data = {
            "name": "SQL Injection",
            "description": "SQL injection attack pattern",
            "attack_type": "injection",
            "attack_vector": "web",
            "typical_severity": "high",
            "cwe_ids": ["CWE-89"],
        }

        # Mock get_attack_pattern_by_name to return an existing pattern
        async def mock_get_attack_pattern_by_name(*args, **kwargs):
            # Return a mock attack pattern with ID 1
            return type(
                "AttackPattern",
                (),
                {
                    "id": 1,
                    "name": "SQL Injection",
                },
            )

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_pattern_by_name",
            mock_get_attack_pattern_by_name,
        )

        # Make API request
        response = test_client.post(
            "/api/v1/attack-patterns",
            json=attack_pattern_data,
        )

        # Assertions
        assert response.status_code == 400
        assert "already exists" in response.json()["detail"]

    def test_get_attack_pattern(self, test_client: TestClient, monkeypatch):
        """Test getting an attack pattern via API."""

        # Mock repository call
        async def mock_get_attack_pattern(*args, **kwargs):
            # Return a mock attack pattern
            return type(
                "AttackPattern",
                (),
                {
                    "__dict__": {
                        "id": 1,
                        "name": "SQL Injection",
                        "description": "SQL injection attack pattern",
                        "attack_type": AttackType.INJECTION,
                        "attack_vector": AttackVector.WEB,
                        "typical_severity": VulnerabilitySeverity.HIGH,
                        "mitre_id": "T1190",
                        "capec_id": "CAPEC-66",
                        "cwe_ids": ["CWE-89"],
                        "pattern_details": {"query_params": True, "body_params": True},
                        "pattern_indicators": {"input_validation": False},
                        "detection_guidance": "Monitor SQL error messages",
                        "remediation_guidance": "Use parameterized queries",
                        "created_at": "2023-01-01T00:00:00",
                        "updated_at": "2023-01-01T00:00:00",
                    }
                },
            )

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_pattern",
            mock_get_attack_pattern,
        )

        # Make API request
        response = test_client.get("/api/v1/attack-patterns/1")

        # Assertions
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == 1
        assert data["name"] == "SQL Injection"
        assert data["attack_type"] == "injection"
        assert data["typical_severity"] == "high"

    def test_get_attack_pattern_not_found(self, test_client: TestClient, monkeypatch):
        """Test getting a non-existent attack pattern via API."""

        # Mock repository call
        async def mock_get_attack_pattern(*args, **kwargs):
            return None

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_pattern",
            mock_get_attack_pattern,
        )

        # Make API request
        response = test_client.get("/api/v1/attack-patterns/999")

        # Assertions
        assert response.status_code == 404
        assert "not found" in response.json()["detail"]

    def test_list_attack_patterns(self, test_client: TestClient, monkeypatch):
        """Test listing attack patterns via API."""

        # Mock repository call
        async def mock_get_all_attack_patterns(*args, **kwargs):
            # Return mock attack patterns
            return [
                type(
                    "AttackPattern",
                    (),
                    {
                        "__dict__": {
                            "id": 1,
                            "name": "SQL Injection",
                            "description": "SQL injection attack pattern",
                            "attack_type": AttackType.INJECTION,
                            "attack_vector": AttackVector.WEB,
                            "typical_severity": VulnerabilitySeverity.HIGH,
                            "mitre_id": "T1190",
                            "capec_id": "CAPEC-66",
                            "cwe_ids": ["CWE-89"],
                            "pattern_details": {},
                            "pattern_indicators": {},
                            "detection_guidance": "Monitor SQL error messages",
                            "remediation_guidance": "Use parameterized queries",
                            "created_at": "2023-01-01T00:00:00",
                            "updated_at": "2023-01-01T00:00:00",
                        }
                    },
                ),
                type(
                    "AttackPattern",
                    (),
                    {
                        "__dict__": {
                            "id": 2,
                            "name": "XSS",
                            "description": "Cross-site scripting attack pattern",
                            "attack_type": AttackType.XSS,
                            "attack_vector": AttackVector.WEB,
                            "typical_severity": VulnerabilitySeverity.MEDIUM,
                            "mitre_id": None,
                            "capec_id": None,
                            "cwe_ids": ["CWE-79"],
                            "pattern_details": {},
                            "pattern_indicators": {},
                            "detection_guidance": None,
                            "remediation_guidance": None,
                            "created_at": "2023-01-01T00:00:00",
                            "updated_at": "2023-01-01T00:00:00",
                        }
                    },
                ),
            ]

        # Mock get_attack_patterns_by_type
        async def mock_get_attack_patterns_by_type(*args, **kwargs):
            # Return only injection attacks
            return [
                type(
                    "AttackPattern",
                    (),
                    {
                        "__dict__": {
                            "id": 1,
                            "name": "SQL Injection",
                            "description": "SQL injection attack pattern",
                            "attack_type": AttackType.INJECTION,
                            "attack_vector": AttackVector.WEB,
                            "typical_severity": VulnerabilitySeverity.HIGH,
                            "mitre_id": "T1190",
                            "capec_id": "CAPEC-66",
                            "cwe_ids": ["CWE-89"],
                            "pattern_details": {},
                            "pattern_indicators": {},
                            "detection_guidance": "Monitor SQL error messages",
                            "remediation_guidance": "Use parameterized queries",
                            "created_at": "2023-01-01T00:00:00",
                            "updated_at": "2023-01-01T00:00:00",
                        }
                    },
                )
            ]

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_all_attack_patterns",
            mock_get_all_attack_patterns,
        )
        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_patterns_by_type",
            mock_get_attack_patterns_by_type,
        )

        # Test listing all attack patterns
        response = test_client.get("/api/v1/attack-patterns")
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 2
        assert data[0]["id"] == 1
        assert data[0]["name"] == "SQL Injection"
        assert data[1]["id"] == 2
        assert data[1]["name"] == "XSS"

        # Test filtering by attack type
        response = test_client.get("/api/v1/attack-patterns?attack_type=injection")
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 1
        assert data[0]["id"] == 1
        assert data[0]["name"] == "SQL Injection"

    def test_match_vulnerability_to_attack_patterns(
        self, test_client: TestClient, monkeypatch
    ):
        """Test matching a vulnerability to attack patterns via API."""

        # Mock vulnerability repository
        async def mock_get_vulnerability(*args, **kwargs):
            return type(
                "Vulnerability",
                (),
                {
                    "id": 1,
                    "name": "SQL Injection in login",
                    "description": "SQL injection vulnerability in login page",
                    "severity": VulnerabilitySeverity.HIGH,
                    "details": {"cwe_id": "CWE-89"},
                },
            )

        # Mock attack pattern repository
        async def mock_match_vulnerability_to_attack_patterns(*args, **kwargs):
            # Return mock matches
            return [
                (
                    type(
                        "AttackPattern",
                        (),
                        {
                            "__dict__": {
                                "id": 1,
                                "name": "SQL Injection",
                                "description": "SQL injection attack pattern",
                                "attack_type": AttackType.INJECTION,
                                "attack_vector": AttackVector.WEB,
                                "typical_severity": VulnerabilitySeverity.HIGH,
                                "mitre_id": "T1190",
                                "capec_id": "CAPEC-66",
                                "cwe_ids": ["CWE-89"],
                                "pattern_details": {},
                                "pattern_indicators": {"input_validation": False},
                                "detection_guidance": "Monitor SQL error messages",
                                "remediation_guidance": "Use parameterized queries",
                                "created_at": "2023-01-01T00:00:00",
                                "updated_at": "2023-01-01T00:00:00",
                            }
                        },
                    ),
                    90.0,  # confidence
                ),
                (
                    type(
                        "AttackPattern",
                        (),
                        {
                            "__dict__": {
                                "id": 3,
                                "name": "Blind SQL Injection",
                                "description": "Blind SQL injection attack pattern",
                                "attack_type": AttackType.INJECTION,
                                "attack_vector": AttackVector.WEB,
                                "typical_severity": VulnerabilitySeverity.HIGH,
                                "mitre_id": None,
                                "capec_id": None,
                                "cwe_ids": ["CWE-89"],
                                "pattern_details": {},
                                "pattern_indicators": {},
                                "detection_guidance": None,
                                "remediation_guidance": None,
                                "created_at": "2023-01-01T00:00:00",
                                "updated_at": "2023-01-01T00:00:00",
                            }
                        },
                    ),
                    70.0,  # confidence
                ),
            ]

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.repository."
            "VulnerabilityRepository.get_vulnerability",
            mock_get_vulnerability,
        )
        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.match_vulnerability_to_attack_patterns",
            mock_match_vulnerability_to_attack_patterns,
        )

        # Make API request
        response = test_client.get("/api/v1/attack-patterns/vulnerabilities/1/match")

        # Assertions
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 2
        assert data[0]["attack_pattern"]["id"] == 1
        assert data[0]["attack_pattern"]["name"] == "SQL Injection"
        assert data[0]["confidence"] == 90.0
        assert data[1]["attack_pattern"]["id"] == 3
        assert data[1]["attack_pattern"]["name"] == "Blind SQL Injection"
        assert data[1]["confidence"] == 70.0
