"""Tests for the Attack Pattern API endpoints."""

import json
from typing import Any, Dict, List

import pytest
from fastapi.testclient import TestClient

from sentinelprobe.vulnerability_scanner.attack_patterns import AttackType, AttackVector
from sentinelprobe.vulnerability_scanner.models import VulnerabilitySeverity


class TestAttackPatternAPI:
    """Tests for the Attack Pattern API."""

    def test_create_attack_pattern(self, test_client: TestClient, monkeypatch):
        """Test creating an attack pattern via API."""
        # Create test data
        attack_pattern_data = {
            "name": "SQL Injection",
            "description": "SQL injection attack pattern",
            "attack_type": "injection",
            "attack_vector": "web",
            "typical_severity": "high",
            "mitre_id": "T1190",
            "capec_id": "CAPEC-66",
            "cwe_ids": ["CWE-89"],
            "pattern_details": {"query_params": True, "body_params": True},
            "pattern_indicators": {"input_validation": False},
            "detection_guidance": "Monitor SQL error messages",
            "remediation_guidance": "Use parameterized queries",
        }

        # Mock repository call
        async def mock_create_attack_pattern(*args, **kwargs):
            # Return a mock attack pattern with ID 1
            class MockAttackPattern:
                def __init__(self):
                    self.id = 1
                    self.name = "SQL Injection"
                    self.description = "SQL injection attack pattern"
                    self.attack_type = AttackType.INJECTION
                    self.attack_vector = AttackVector.WEB
                    self.typical_severity = VulnerabilitySeverity.HIGH
                    self.mitre_id = "T1190"
                    self.capec_id = "CAPEC-66"
                    self.cwe_ids = ["CWE-89"]
                    self.pattern_details = {"query_params": True, "body_params": True}
                    self.pattern_indicators = {"input_validation": False}
                    self.detection_guidance = "Monitor SQL error messages"
                    self.remediation_guidance = "Use parameterized queries"
                    self.created_at = "2023-01-01T00:00:00"
                    self.updated_at = "2023-01-01T00:00:00"

            return MockAttackPattern()

        # Mock get_attack_pattern_by_name to return None (no existing pattern)
        async def mock_get_attack_pattern_by_name(*args, **kwargs):
            return None

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.create_attack_pattern",
            mock_create_attack_pattern,
        )
        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_pattern_by_name",
            mock_get_attack_pattern_by_name,
        )

        # Make API request
        response = test_client.post(
            "/attack-patterns",
            json=attack_pattern_data,
        )

        # Assertions
        assert (
            response.status_code == 201
        ), f"Unexpected status code: {response.status_code} - {response.text}"
        data = response.json()
        assert data["id"] == 1
        assert data["name"] == "SQL Injection"
        assert data["attack_type"] == "injection"
        assert data["attack_vector"] == "web"
        assert data["typical_severity"] == "high"

    def test_create_attack_pattern_duplicate_name(
        self, test_client: TestClient, monkeypatch
    ):
        """Test creating an attack pattern with a duplicate name."""
        # Create test data
        attack_pattern_data = {
            "name": "SQL Injection",
            "description": "SQL injection attack pattern",
            "attack_type": "injection",
            "attack_vector": "web",
            "typical_severity": "high",
            "cwe_ids": ["CWE-89"],
        }

        # Mock get_attack_pattern_by_name to return an existing pattern
        async def mock_get_attack_pattern_by_name(*args, **kwargs):
            # Return a mock attack pattern with ID 1
            return type(
                "AttackPattern",
                (),
                {
                    "id": 1,
                    "name": "SQL Injection",
                },
            )

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_pattern_by_name",
            mock_get_attack_pattern_by_name,
        )

        # Make API request
        response = test_client.post(
            "/attack-patterns",
            json=attack_pattern_data,
        )

        # Assertions
        assert response.status_code == 400
        assert "already exists" in response.json()["detail"]

    def test_get_attack_pattern(self, test_client: TestClient, monkeypatch):
        """Test getting an attack pattern via API."""

        # Mock repository call
        async def mock_get_attack_pattern(*args, **kwargs):
            # Return a mock attack pattern
            class MockAttackPattern:
                def __init__(self):
                    self.id = 1
                    self.name = "SQL Injection"
                    self.description = "SQL injection attack pattern"
                    self.attack_type = AttackType.INJECTION
                    self.attack_vector = AttackVector.WEB
                    self.typical_severity = VulnerabilitySeverity.HIGH
                    self.mitre_id = "T1190"
                    self.capec_id = "CAPEC-66"
                    self.cwe_ids = ["CWE-89"]
                    self.pattern_details = {"query_params": True, "body_params": True}
                    self.pattern_indicators = {"input_validation": False}
                    self.detection_guidance = "Monitor SQL error messages"
                    self.remediation_guidance = "Use parameterized queries"
                    self.created_at = "2023-01-01T00:00:00"
                    self.updated_at = "2023-01-01T00:00:00"

            return MockAttackPattern()

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_pattern",
            mock_get_attack_pattern,
        )

        # Make API request
        response = test_client.get("/attack-patterns/1")

        # Assertions
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == 1
        assert data["name"] == "SQL Injection"
        assert data["attack_type"] == "injection"
        assert data["attack_vector"] == "web"

    def test_get_attack_pattern_not_found(self, test_client: TestClient, monkeypatch):
        """Test getting a non-existent attack pattern via API."""

        # Mock repository call
        async def mock_get_attack_pattern(*args, **kwargs):
            return None

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_pattern",
            mock_get_attack_pattern,
        )

        # Make API request
        response = test_client.get("/attack-patterns/999")

        # Assertions
        assert response.status_code == 404
        assert "not found" in response.json()["detail"]

    def test_list_attack_patterns(self, test_client: TestClient, monkeypatch):
        """Test listing attack patterns via API."""

        # Mock repository call
        async def mock_get_all_attack_patterns(*args, **kwargs):
            # Return mock attack patterns
            class MockAttackPattern1:
                def __init__(self):
                    self.id = 1
                    self.name = "SQL Injection"
                    self.description = "SQL injection attack pattern"
                    self.attack_type = AttackType.INJECTION
                    self.attack_vector = AttackVector.WEB
                    self.typical_severity = VulnerabilitySeverity.HIGH
                    self.mitre_id = "T1190"
                    self.capec_id = "CAPEC-66"
                    self.cwe_ids = ["CWE-89"]
                    self.pattern_details = {}
                    self.pattern_indicators = {}
                    self.detection_guidance = "Monitor SQL error messages"
                    self.remediation_guidance = "Use parameterized queries"
                    self.created_at = "2023-01-01T00:00:00"
                    self.updated_at = "2023-01-01T00:00:00"

            class MockAttackPattern2:
                def __init__(self):
                    self.id = 2
                    self.name = "XSS"
                    self.description = "Cross-site scripting attack pattern"
                    self.attack_type = AttackType.XSS
                    self.attack_vector = AttackVector.WEB
                    self.typical_severity = VulnerabilitySeverity.MEDIUM
                    self.mitre_id = None
                    self.capec_id = None
                    self.cwe_ids = ["CWE-79"]
                    self.pattern_details = {}
                    self.pattern_indicators = {}
                    self.detection_guidance = None
                    self.remediation_guidance = None
                    self.created_at = "2023-01-01T00:00:00"
                    self.updated_at = "2023-01-01T00:00:00"

            return [MockAttackPattern1(), MockAttackPattern2()]

        # Mock get_attack_patterns_by_type
        async def mock_get_attack_patterns_by_type(*args, **kwargs):
            # Return only injection attacks
            class MockAttackPattern:
                def __init__(self):
                    self.id = 1
                    self.name = "SQL Injection"
                    self.description = "SQL injection attack pattern"
                    self.attack_type = AttackType.INJECTION
                    self.attack_vector = AttackVector.WEB
                    self.typical_severity = VulnerabilitySeverity.HIGH
                    self.mitre_id = "T1190"
                    self.capec_id = "CAPEC-66"
                    self.cwe_ids = ["CWE-89"]
                    self.pattern_details = {}
                    self.pattern_indicators = {}
                    self.detection_guidance = "Monitor SQL error messages"
                    self.remediation_guidance = "Use parameterized queries"
                    self.created_at = "2023-01-01T00:00:00"
                    self.updated_at = "2023-01-01T00:00:00"

            return [MockAttackPattern()]

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_all_attack_patterns",
            mock_get_all_attack_patterns,
        )
        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.get_attack_patterns_by_type",
            mock_get_attack_patterns_by_type,
        )

        # Test listing all attack patterns
        response = test_client.get("/attack-patterns")
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 2
        assert data[0]["id"] == 1
        assert data[0]["name"] == "SQL Injection"
        assert data[1]["id"] == 2
        assert data[1]["name"] == "XSS"

        # Test filtering by attack type
        response = test_client.get("/attack-patterns?attack_type=injection")
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 1
        assert data[0]["id"] == 1
        assert data[0]["name"] == "SQL Injection"

    def test_match_vulnerability_to_attack_patterns(
        self, test_client: TestClient, monkeypatch
    ):
        """Test matching a vulnerability to attack patterns via API."""

        # Mock vulnerability repository
        async def mock_get_vulnerability(*args, **kwargs):
            class MockVulnerability:
                def __init__(self):
                    self.id = 1
                    self.name = "SQL Injection in login"
                    self.description = "SQL injection vulnerability in login page"
                    self.severity = VulnerabilitySeverity.HIGH
                    self.details = {"cwe_id": "CWE-89"}

            return MockVulnerability()

        # Mock attack pattern repository
        async def mock_match_vulnerability_to_attack_patterns(*args, **kwargs):
            # Return mock matches
            class MockAttackPattern1:
                def __init__(self):
                    self.id = 1
                    self.name = "SQL Injection"
                    self.description = "SQL injection attack pattern"
                    self.attack_type = AttackType.INJECTION
                    self.attack_vector = AttackVector.WEB
                    self.typical_severity = VulnerabilitySeverity.HIGH
                    self.mitre_id = "T1190"
                    self.capec_id = "CAPEC-66"
                    self.cwe_ids = ["CWE-89"]
                    self.pattern_details = {}
                    self.pattern_indicators = {"input_validation": False}
                    self.detection_guidance = "Monitor SQL error messages"
                    self.remediation_guidance = "Use parameterized queries"
                    self.created_at = "2023-01-01T00:00:00"
                    self.updated_at = "2023-01-01T00:00:00"

            class MockAttackPattern2:
                def __init__(self):
                    self.id = 3
                    self.name = "Blind SQL Injection"
                    self.description = "Blind SQL injection attack pattern"
                    self.attack_type = AttackType.INJECTION
                    self.attack_vector = AttackVector.WEB
                    self.typical_severity = VulnerabilitySeverity.HIGH
                    self.mitre_id = None
                    self.capec_id = None
                    self.cwe_ids = ["CWE-89"]
                    self.pattern_details = {}
                    self.pattern_indicators = {}
                    self.detection_guidance = None
                    self.remediation_guidance = None
                    self.created_at = "2023-01-01T00:00:00"
                    self.updated_at = "2023-01-01T00:00:00"

            return [(MockAttackPattern1(), 90.0), (MockAttackPattern2(), 70.0)]

        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.repository."
            "VulnerabilityRepository.get_vulnerability",
            mock_get_vulnerability,
        )
        monkeypatch.setattr(
            "sentinelprobe.vulnerability_scanner.attack_pattern_repository."
            "AttackPatternRepository.match_vulnerability_to_attack_patterns",
            mock_match_vulnerability_to_attack_patterns,
        )

        # Make API request
        response = test_client.get("/attack-patterns/vulnerabilities/1/match")

        # Assertions
        assert response.status_code == 200
        data = response.json()
        assert len(data) == 2
        assert data[0]["confidence"] == 90.0
        assert data[0]["attack_pattern"]["id"] == 1
        assert data[0]["attack_pattern"]["name"] == "SQL Injection"
        assert data[1]["confidence"] == 70.0
        assert data[1]["attack_pattern"]["id"] == 3
        assert data[1]["attack_pattern"]["name"] == "Blind SQL Injection"
