"""Tests for vulnerability prioritization algorithms."""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.vulnerability_scanner.attack_patterns import AttackPattern
from sentinelprobe.vulnerability_scanner.models import (
    Vulnerability,
    VulnerabilityCreate,
    VulnerabilitySeverity,
    VulnerabilityStatus,
)
from sentinelprobe.vulnerability_scanner.priority import (
    ATTACK_PATTERN_WEIGHT,
    BUSINESS_IMPACT_WEIGHT,
    SEVERITY_WEIGHT,
    calculate_attack_pattern_score,
    calculate_business_impact_score,
    calculate_severity_score,
    calculate_vulnerability_score,
    prioritize_vulnerabilities,
)


@pytest.fixture
def mock_vulnerability_critical() -> Vulnerability:
    """Create a mock critical vulnerability for testing."""
    return Vulnerability(
        id=1,
        scan_id=1,
        target_id=1,
        name="Critical SQL Injection",
        description="Critical SQL injection vulnerability in login endpoint",
        severity=VulnerabilitySeverity.CRITICAL,
        status=VulnerabilityStatus.CONFIRMED,
        cve_id="CVE-2023-1234",
        cvss_score=9.8,
        affected_component="authentication_service",
        port_number=443,
        protocol="https",
        details={},
        remediation="Update to latest version and use parameterized queries",
    )


@pytest.fixture
def mock_vulnerability_high() -> Vulnerability:
    """Create a mock high severity vulnerability for testing."""
    return Vulnerability(
        id=2,
        scan_id=1,
        target_id=1,
        name="Open Admin Interface",
        description="High severity exposure of admin interface",
        severity=VulnerabilitySeverity.HIGH,
        status=VulnerabilityStatus.CONFIRMED,
        cve_id=None,
        cvss_score=None,
        affected_component="admin_portal",
        port_number=8080,
        protocol="http",
        details={},
        remediation="Implement proper authentication",
    )


@pytest.fixture
def mock_vulnerability_medium() -> Vulnerability:
    """Create a mock medium severity vulnerability for testing."""
    return Vulnerability(
        id=3,
        scan_id=1,
        target_id=1,
        name="Missing HTTP Headers",
        description="Missing security headers in HTTP responses",
        severity=VulnerabilitySeverity.MEDIUM,
        status=VulnerabilityStatus.CONFIRMED,
        cve_id=None,
        cvss_score=None,
        affected_component="web_server",
        port_number=80,
        protocol="http",
        details={},
        remediation="Add security headers to web server configuration",
    )


@pytest.fixture
def mock_vulnerability_low() -> Vulnerability:
    """Create a mock low severity vulnerability for testing."""
    return Vulnerability(
        id=4,
        scan_id=1,
        target_id=1,
        name="Information Disclosure",
        description="Server information disclosure in headers",
        severity=VulnerabilitySeverity.LOW,
        status=VulnerabilityStatus.UNCONFIRMED,
        cve_id=None,
        cvss_score=None,
        affected_component="web_server",
        port_number=80,
        protocol="http",
        details={},
        remediation="Configure server to hide version information",
    )


@pytest.fixture
def mock_attack_patterns():
    """Create mock attack patterns for testing."""
    return [
        (
            {
                "id": 1,
                "name": "SQL Injection",
                "description": "Attack pattern for SQL injection",
            },
            95.0,
        ),
        (
            {
                "id": 2,
                "name": "Cross-Site Scripting",
                "description": "Attack pattern for XSS",
            },
            85.0,
        ),
    ]


def test_severity_score_calculation(
    mock_vulnerability_critical,
    mock_vulnerability_high,
    mock_vulnerability_medium,
    mock_vulnerability_low,
):
    """Test calculation of severity scores."""
    # Test critical vulnerability
    critical_score = calculate_severity_score(mock_vulnerability_critical)
    assert critical_score > 9.0, "Critical vulnerability should have high score"

    # Test high severity vulnerability
    high_score = calculate_severity_score(mock_vulnerability_high)
    assert (
        7.0 < high_score < 9.0
    ), "High severity vulnerability should have appropriate score"

    # Test medium severity vulnerability
    medium_score = calculate_severity_score(mock_vulnerability_medium)
    assert (
        4.0 < medium_score < 7.0
    ), "Medium severity vulnerability should have appropriate score"

    # Test low severity vulnerability
    low_score = calculate_severity_score(mock_vulnerability_low)
    assert low_score < 4.0, "Low severity vulnerability should have low score"


def test_attack_pattern_score_calculation(mock_attack_patterns):
    """Test calculation of attack pattern scores."""
    # Test with mock attack patterns
    score = calculate_attack_pattern_score(mock_attack_patterns)
    assert (
        7.0 < score < 10.0
    ), "Attack pattern score should be high with high confidence matches"

    # Test with single low confidence pattern
    low_confidence = [({"id": 3, "name": "Test Pattern"}, 60.0)]
    low_score = calculate_attack_pattern_score(low_confidence)
    assert low_score < 6.0, "Low confidence pattern should result in lower score"

    # Test with no patterns
    no_patterns_score = calculate_attack_pattern_score([])
    assert no_patterns_score == 0.0, "No patterns should result in zero score"


def test_vulnerability_score_calculation(
    mock_vulnerability_critical, mock_attack_patterns
):
    """Test calculation of overall vulnerability scores."""
    # Test with all components
    score = calculate_vulnerability_score(
        mock_vulnerability_critical,
        mock_attack_patterns,
        business_impact=8.5,
        exploitability=9.0,
    )
    assert (
        8.0 < score < 10.0
    ), "Critical vulnerability with high impact should have high score"

    # Test with only severity
    severity_only_score = calculate_vulnerability_score(mock_vulnerability_critical)
    assert (
        4.0 < severity_only_score < 6.0
    ), "Score with only severity should be proportional to severity weight"


def test_vulnerability_prioritization(
    mock_vulnerability_critical,
    mock_vulnerability_high,
    mock_vulnerability_medium,
    mock_vulnerability_low,
):
    """Test prioritization of vulnerabilities."""
    vulnerabilities = [
        mock_vulnerability_low,
        mock_vulnerability_critical,
        mock_vulnerability_medium,
        mock_vulnerability_high,
    ]

    # Create attack patterns map
    attack_patterns_map = {
        1: [({"id": 1, "name": "SQL Injection"}, 95.0)],
        2: [({"id": 2, "name": "Authentication Bypass"}, 80.0)],
    }

    # Create business impact map
    business_impact_map = {
        1: 9.0,  # Critical vuln has high business impact
        2: 7.0,  # High vuln has moderate business impact
        3: 4.0,  # Medium vuln has low business impact
    }

    # Prioritize vulnerabilities
    prioritized = prioritize_vulnerabilities(
        vulnerabilities, attack_patterns_map, business_impact_map
    )

    # Verify order: critical, high, medium, low
    assert len(prioritized) == 4, "Should have 4 prioritized vulnerabilities"
    assert prioritized[0][0].id == 1, "Critical vulnerability should be first"
    assert prioritized[1][0].id == 2, "High vulnerability should be second"
    assert prioritized[2][0].id == 3, "Medium vulnerability should be third"
    assert prioritized[3][0].id == 4, "Low vulnerability should be fourth"

    # Verify scores are decreasing
    assert (
        prioritized[0][1] > prioritized[1][1] > prioritized[2][1] > prioritized[3][1]
    ), "Scores should be decreasing"


@pytest.mark.asyncio
async def test_vulnerability_prioritization_service(
    db_session: AsyncSession,
    mock_vulnerability_critical: Vulnerability,
):
    """Test the vulnerability prioritization through the service layer."""
    from sentinelprobe.vulnerability_scanner.repository import (
        VulnerabilityRepository,
        VulnerabilityScanRepository,
    )
    from sentinelprobe.vulnerability_scanner.service import VulnerabilityScannerService

    # Create a test vulnerability in the database
    service = VulnerabilityScannerService(db_session)

    # Create a vulnerability
    vulnerability = await service.create_vulnerability(
        VulnerabilityCreate(
            scan_id=1,
            target_id=1,
            name="Critical SQL Injection",
            description="A critical SQL injection vulnerability",
            severity=VulnerabilitySeverity.CRITICAL,
            cvss_score=9.8,
            cve_id="CVE-2023-1234",
            details={"business_impact": "high"},
        )
    )

    # Get the vulnerability score
    prioritized_vulns = await service.prioritize_target_vulnerabilities(target_id=1)

    # Assert that we have at least one vulnerability
    assert prioritized_vulns

    # Assert that the score is high for critical vulnerabilities
    vuln, score = prioritized_vulns[0]
    assert score > 0.7  # High score for critical vulnerability
    assert vuln.id == vulnerability.id


@pytest.fixture
def vulnerability_high_severity():
    """Fixture for a high severity vulnerability."""
    return Vulnerability(
        id=1,
        scan_id=1,
        target_id=1,
        name="Critical SQL Injection",
        description="SQL Injection vulnerability in login form",
        severity=VulnerabilitySeverity.HIGH,
        cvss_score=8.5,
        status=VulnerabilityStatus.CONFIRMED,
        affected_component="authentication",
        remediation="Use parameterized queries",
        details={
            "exploitability": 9.0,
            "business_impact": "high",
        },
        cve_id="CVE-2023-1234",
        port_number=443,
        protocol="https",
    )


@pytest.fixture
def vulnerability_medium_severity():
    """Fixture for a medium severity vulnerability."""
    return Vulnerability(
        id=2,
        scan_id=1,
        target_id=1,
        name="XSS Vulnerability",
        description="Cross-site scripting in comment form",
        severity=VulnerabilitySeverity.MEDIUM,
        cvss_score=5.5,
        status=VulnerabilityStatus.CONFIRMED,
        affected_component="web",
        remediation="Sanitize user input",
        details={
            "exploitability": 6.0,
            "business_impact": "medium",
        },
        cve_id="CVE-2023-5678",
        port_number=80,
        protocol="http",
    )


@pytest.fixture
def vulnerability_low_severity():
    """Fixture for a low severity vulnerability."""
    return Vulnerability(
        id=3,
        scan_id=1,
        target_id=1,
        name="Information Disclosure",
        description="Server reveals version information",
        severity=VulnerabilitySeverity.LOW,
        cvss_score=2.0,
        status=VulnerabilityStatus.CONFIRMED,
        affected_component="web-server",
        remediation="Configure server to hide version info",
        details={
            "exploitability": 3.0,
            "business_impact": "low",
        },
        port_number=80,
        protocol="http",
    )


@pytest.fixture
def attack_pattern_sql_injection():
    """Fixture for a SQL injection attack pattern."""
    return AttackPattern(
        id=1,
        name="SQL Injection",
        description="Injection of SQL commands",
        mitre_attack_id="T1190",
        capec_id="CAPEC-66",
        typical_severity=VulnerabilitySeverity.HIGH,
        detection_methods=["input validation", "parameterized queries"],
        attack_prerequisites=["user input", "database access"],
        meta_tags=["injection", "database", "authentication"],
    )


def test_calculate_severity_score(
    vulnerability_high_severity,
    vulnerability_medium_severity,
    vulnerability_low_severity,
):
    """Test calculation of severity scores."""
    high_score = calculate_severity_score(vulnerability_high_severity)
    medium_score = calculate_severity_score(vulnerability_medium_severity)
    low_score = calculate_severity_score(vulnerability_low_severity)

    # Verify scores are properly normalized to 0-1 scale
    assert high_score == pytest.approx(0.85)
    assert medium_score == pytest.approx(0.55)
    assert low_score == pytest.approx(0.2)

    # Verify relative ordering
    assert high_score > medium_score > low_score


def test_calculate_attack_pattern_score(
    vulnerability_high_severity, attack_pattern_sql_injection
):
    """Test calculation of attack pattern scores."""
    # Test with high confidence match
    high_confidence = [(attack_pattern_sql_injection, 0.9)]
    high_score = calculate_attack_pattern_score(
        vulnerability_high_severity, high_confidence
    )

    # Test with medium confidence match
    medium_confidence = [(attack_pattern_sql_injection, 0.6)]
    medium_score = calculate_attack_pattern_score(
        vulnerability_high_severity, medium_confidence
    )

    # Test with low confidence match
    low_confidence = [(attack_pattern_sql_injection, 0.3)]
    low_score = calculate_attack_pattern_score(
        vulnerability_high_severity, low_confidence
    )

    # Test with multiple patterns
    multiple_patterns = [
        (attack_pattern_sql_injection, 0.8),
        (MagicMock(spec=AttackPattern), 0.7),
        (MagicMock(spec=AttackPattern), 0.5),
    ]
    multiple_score = calculate_attack_pattern_score(
        vulnerability_high_severity, multiple_patterns
    )

    # Verify scores are properly calculated
    assert high_score > medium_score > low_score
    assert multiple_score > high_score  # Multiple patterns should yield higher score


def test_calculate_business_impact_score(
    vulnerability_high_severity,
    vulnerability_medium_severity,
    vulnerability_low_severity,
):
    """Test calculation of business impact scores."""
    high_score = calculate_business_impact_score(vulnerability_high_severity)
    medium_score = calculate_business_impact_score(vulnerability_medium_severity)
    low_score = calculate_business_impact_score(vulnerability_low_severity)

    # Verify relative ordering
    assert high_score > medium_score > low_score

    # Test with missing business impact
    vuln_no_impact = Vulnerability(
        id=4,
        scan_id=1,
        target_id=1,
        name="No Impact",
        description="No business impact specified",
        severity=VulnerabilitySeverity.MEDIUM,
        status=VulnerabilityStatus.CONFIRMED,
        affected_component="misc",
    )
    no_impact_score = calculate_business_impact_score(vuln_no_impact)
    assert no_impact_score == 0.0


def test_calculate_vulnerability_score(
    vulnerability_high_severity,
    vulnerability_medium_severity,
    vulnerability_low_severity,
    attack_pattern_sql_injection,
):
    """Test calculation of overall vulnerability scores."""
    # Test with all factors
    attack_patterns = [(attack_pattern_sql_injection, 0.9)]
    business_impact = 0.8
    exploitability = 0.9

    high_score = calculate_vulnerability_score(
        vulnerability_high_severity, attack_patterns, business_impact, exploitability
    )

    medium_score = calculate_vulnerability_score(
        vulnerability_medium_severity,
        attack_patterns,
        business_impact=0.5,
        exploitability=0.6,
    )

    low_score = calculate_vulnerability_score(
        vulnerability_low_severity,
        attack_patterns,
        business_impact=0.2,
        exploitability=0.3,
    )

    # Verify relative ordering
    assert high_score > medium_score > low_score

    # Test with missing factors
    score_no_patterns = calculate_vulnerability_score(
        vulnerability_high_severity, None, business_impact, exploitability
    )

    score_no_impact = calculate_vulnerability_score(
        vulnerability_high_severity, attack_patterns, None, exploitability
    )

    # Scores should be lower when factors are missing
    assert high_score > score_no_patterns
    assert high_score > score_no_impact


def test_prioritize_vulnerabilities(
    vulnerability_high_severity,
    vulnerability_medium_severity,
    vulnerability_low_severity,
    attack_pattern_sql_injection,
):
    """Test the vulnerability prioritization algorithm."""
    # Create a list of vulnerabilities
    vulnerabilities = [
        vulnerability_medium_severity,  # Intentionally not in priority order
        vulnerability_high_severity,
        vulnerability_low_severity,
    ]

    # Create attack pattern map
    attack_patterns_map = {
        1: [(attack_pattern_sql_injection, 0.9)],  # High severity vuln
        2: [(attack_pattern_sql_injection, 0.5)],  # Medium severity vuln
        3: [],  # Low severity vuln - no attack patterns
    }

    # Prioritize vulnerabilities
    prioritized_list = prioritize_vulnerabilities(vulnerabilities, attack_patterns_map)

    # Verify correct ordering (should be high, medium, low)
    assert len(prioritized_list) == 3
    assert prioritized_list[0][0].id == 1  # High severity should be first
    assert prioritized_list[1][0].id == 2  # Medium severity should be second
    assert prioritized_list[2][0].id == 3  # Low severity should be last

    # Verify scores are decreasing
    assert prioritized_list[0][1] > prioritized_list[1][1] > prioritized_list[2][1]


def test_vulnerability_score_weightings():
    """Test that weightings appropriately influence the final scores."""
    # Create test vulnerabilities with different characteristics

    # High severity, low business impact
    vuln1 = Vulnerability(
        id=1,
        scan_id=1,
        target_id=1,
        name="High Severity Low Impact",
        severity=VulnerabilitySeverity.HIGH,
        cvss_score=8.0,
        details={"business_impact": "low"},
    )

    # Medium severity, high business impact
    vuln2 = Vulnerability(
        id=2,
        scan_id=1,
        target_id=1,
        name="Medium Severity High Impact",
        severity=VulnerabilitySeverity.MEDIUM,
        cvss_score=5.0,
        details={"business_impact": "high"},
    )

    # Create attack patterns
    attack_patterns_map = {
        1: [],  # No attack patterns for vuln1
        2: [(MagicMock(spec=AttackPattern), 0.7)],  # Pattern match for vuln2
    }

    # Prioritize with default weights
    prioritized_list = prioritize_vulnerabilities([vuln1, vuln2], attack_patterns_map)

    # With default weights, high severity should outweigh high business impact
    original_order = [v.id for v, _ in prioritized_list]

    # Now patch the weights to emphasize business impact over severity
    with (
        patch("sentinelprobe.vulnerability_scanner.priority.SEVERITY_WEIGHT", 0.2),
        patch(
            "sentinelprobe.vulnerability_scanner.priority.BUSINESS_IMPACT_WEIGHT", 0.6
        ),
        patch(
            "sentinelprobe.vulnerability_scanner.priority.ATTACK_PATTERN_WEIGHT", 0.2
        ),
    ):

        # Prioritize with modified weights
        modified_prioritized_list = prioritize_vulnerabilities(
            [vuln1, vuln2], attack_patterns_map
        )
        modified_order = [v.id for v, _ in modified_prioritized_list]

        # Order should be different with modified weights
        assert modified_order != original_order
        assert (
            modified_order[0] == 2
        )  # vuln2 should be first with higher business impact weight


@pytest.mark.asyncio
async def test_service_prioritize_target_vulnerabilities():
    """Test the service method for prioritizing target vulnerabilities."""
    # Mock the VulnerabilityScannerService
    with patch(
        "sentinelprobe.vulnerability_scanner.service.VulnerabilityScannerService"
    ) as mock_service:
        # Setup the mock service to return our test vulnerabilities
        service_instance = mock_service.return_value
        service_instance.get_target_vulnerabilities = AsyncMock()
        service_instance.get_vulnerability_attack_patterns = AsyncMock()

        # Create test vulnerabilities
        vuln_high = MagicMock(
            spec=Vulnerability,
            id=1,
            severity=VulnerabilitySeverity.HIGH,
            cvss_score=8.5,
        )
        vuln_medium = MagicMock(
            spec=Vulnerability,
            id=2,
            severity=VulnerabilitySeverity.MEDIUM,
            cvss_score=5.5,
        )
        service_instance.get_target_vulnerabilities.return_value = [
            vuln_high,
            vuln_medium,
        ]

        # Mock attack pattern responses
        attack_pattern = MagicMock(spec=AttackPattern)
        service_instance.get_vulnerability_attack_patterns.side_effect = [
            [(attack_pattern, 0.9)],  # High vulnerability
            [(attack_pattern, 0.5)],  # Medium vulnerability
        ]

        # Call the service method
        from sentinelprobe.vulnerability_scanner.service import (
            VulnerabilityScannerService,
        )

        service = VulnerabilityScannerService(AsyncMock())
        prioritized_vulns = await service.prioritize_target_vulnerabilities(target_id=1)

        # Verify results
        assert len(prioritized_vulns) == 2
        assert prioritized_vulns[0][0] == vuln_high  # High severity should be first
        assert (
            prioritized_vulns[1][0] == vuln_medium
        )  # Medium severity should be second
        assert (
            prioritized_vulns[0][1] > prioritized_vulns[1][1]
        )  # Score should be higher for high severity
