"""Tests for vulnerability prioritization algorithms."""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.vulnerability_scanner.attack_patterns import AttackPattern
from sentinelprobe.vulnerability_scanner.models import (
    Vulnerability,
    VulnerabilityCreate,
    VulnerabilitySeverity,
    VulnerabilityStatus,
)
from sentinelprobe.vulnerability_scanner.priority import (
    ATTACK_PATTERN_WEIGHT,
    BUSINESS_IMPACT_WEIGHT,
    SEVERITY_WEIGHT,
    calculate_attack_pattern_score,
    calculate_business_impact_score,
    calculate_severity_score,
    calculate_vulnerability_score,
    prioritize_vulnerabilities,
)


@pytest.fixture
def vulnerability_high_severity():
    """Fixture for a high severity vulnerability."""
    return Vulnerability(
        id=1,
        scan_id=1,
        target_id=1,
        name="Critical SQL Injection",
        description="SQL Injection vulnerability in login form",
        severity=VulnerabilitySeverity.HIGH,
        cvss_score=8.5,
        status=VulnerabilityStatus.CONFIRMED,
        affected_component="authentication",
        remediation="Use parameterized queries",
        details={
            "exploitability": 9.0,
            "business_impact": 0.8,  # Use numeric value instead of string
        },
        cve_id="CVE-2023-1234",
        port_number=443,
        protocol="https",
    )


@pytest.fixture
def vulnerability_medium_severity():
    """Fixture for a medium severity vulnerability."""
    return Vulnerability(
        id=2,
        scan_id=1,
        target_id=1,
        name="XSS Vulnerability",
        description="Cross-site scripting in comment form",
        severity=VulnerabilitySeverity.MEDIUM,
        cvss_score=5.5,
        status=VulnerabilityStatus.CONFIRMED,
        affected_component="web",
        remediation="Sanitize user input",
        details={
            "exploitability": 6.0,
            "business_impact": 0.5,  # Use numeric value instead of string
        },
        cve_id="CVE-2023-5678",
        port_number=80,
        protocol="http",
    )


@pytest.fixture
def vulnerability_low_severity():
    """Fixture for a low severity vulnerability."""
    return Vulnerability(
        id=3,
        scan_id=1,
        target_id=1,
        name="Information Disclosure",
        description="Server reveals version information",
        severity=VulnerabilitySeverity.LOW,
        cvss_score=2.0,
        status=VulnerabilityStatus.CONFIRMED,
        affected_component="web-server",
        remediation="Configure server to hide version info",
        details={
            "exploitability": 3.0,
            "business_impact": 0.2,  # Use numeric value instead of string
        },
        port_number=80,
        protocol="http",
    )


@pytest.fixture
def attack_pattern_sql_injection():
    """Fixture for a SQL injection attack pattern."""
    return MagicMock(
        spec=AttackPattern,
        id=1,
        name="SQL Injection",
        description="Injection of SQL commands",
        attack_type="injection",
        attack_vector="web",
        typical_severity=VulnerabilitySeverity.HIGH,
        mitre_id="T1190",
        capec_id="CAPEC-66",
        cwe_ids=["CWE-89"],
        pattern_details={
            "detection_methods": ["input validation", "parameterized queries"]
        },
        pattern_indicators={"attack_prerequisites": ["user input", "database access"]},
    )


def test_calculate_severity_score(
    vulnerability_high_severity,
    vulnerability_medium_severity,
    vulnerability_low_severity,
):
    """Test calculation of severity scores."""
    high_score = calculate_severity_score(vulnerability_high_severity)
    medium_score = calculate_severity_score(vulnerability_medium_severity)
    low_score = calculate_severity_score(vulnerability_low_severity)

    # Verify scores are properly normalized to 0-1 scale
    assert high_score == pytest.approx(0.85)
    assert medium_score == pytest.approx(0.55)
    assert low_score == pytest.approx(0.2)

    # Verify relative ordering
    assert high_score > medium_score > low_score


def test_calculate_attack_pattern_score(
    vulnerability_high_severity, attack_pattern_sql_injection
):
    """Test calculation of attack pattern scores."""
    # Test with high confidence match
    high_confidence = [(attack_pattern_sql_injection, 0.9)]
    high_score = calculate_attack_pattern_score(
        vulnerability_high_severity, high_confidence
    )

    # Test with medium confidence match
    medium_confidence = [(attack_pattern_sql_injection, 0.6)]
    medium_score = calculate_attack_pattern_score(
        vulnerability_high_severity, medium_confidence
    )

    # Test with low confidence match
    low_confidence = [(attack_pattern_sql_injection, 0.3)]
    low_score = calculate_attack_pattern_score(
        vulnerability_high_severity, low_confidence
    )

    # Test with multiple patterns
    multiple_patterns = [
        (attack_pattern_sql_injection, 0.8),
        (MagicMock(spec=AttackPattern), 0.7),
        (MagicMock(spec=AttackPattern), 0.5),
    ]
    multiple_score = calculate_attack_pattern_score(
        vulnerability_high_severity, multiple_patterns
    )

    # Verify scores are properly calculated
    assert high_score > medium_score > low_score
    assert multiple_score > high_score  # Multiple patterns should yield higher score


def test_calculate_business_impact_score(
    vulnerability_high_severity,
    vulnerability_medium_severity,
    vulnerability_low_severity,
):
    """Test calculation of business impact scores."""
    high_score = calculate_business_impact_score(vulnerability_high_severity)
    medium_score = calculate_business_impact_score(vulnerability_medium_severity)
    low_score = calculate_business_impact_score(vulnerability_low_severity)

    # Verify relative ordering
    assert high_score > medium_score > low_score

    # Test with missing business impact
    vuln_no_impact = Vulnerability(
        id=4,
        scan_id=1,
        target_id=1,
        name="No Impact",
        description="No business impact specified",
        severity=VulnerabilitySeverity.MEDIUM,
        status=VulnerabilityStatus.CONFIRMED,
        affected_component="misc",
    )
    no_impact_score = calculate_business_impact_score(vuln_no_impact)
    assert no_impact_score == 0.0


def test_prioritize_vulnerabilities(
    vulnerability_high_severity,
    vulnerability_medium_severity,
    vulnerability_low_severity,
    attack_pattern_sql_injection,
):
    """Test the vulnerability prioritization algorithm."""
    # Create a list of vulnerabilities
    vulnerabilities = [
        vulnerability_medium_severity,  # Intentionally not in priority order
        vulnerability_high_severity,
        vulnerability_low_severity,
    ]

    # Create attack pattern map
    attack_patterns_map = {
        1: [(attack_pattern_sql_injection, 0.9)],  # High severity vuln
        2: [(attack_pattern_sql_injection, 0.5)],  # Medium severity vuln
        3: [],  # Low severity vuln - no attack patterns
    }

    # Prioritize vulnerabilities
    prioritized_list = prioritize_vulnerabilities(vulnerabilities, attack_patterns_map)

    # Verify correct ordering (should be high, medium, low)
    assert len(prioritized_list) == 3
    assert prioritized_list[0][0].id == 1  # High severity should be first
    assert prioritized_list[1][0].id == 2  # Medium severity should be second
    assert prioritized_list[2][0].id == 3  # Low severity should be last

    # Verify scores are decreasing
    assert prioritized_list[0][1] > prioritized_list[1][1] > prioritized_list[2][1]
