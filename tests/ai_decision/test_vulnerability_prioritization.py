"""Tests for vulnerability prioritization in the AI Decision engine."""

from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.ai_decision.models import (
    DecisionRule,
    DecisionRuleCreate,
    DecisionRuleSeverity,
    DecisionRuleType,
    StrategyPhase,
    TestStrategy,
    TestStrategyCreate,
)
from sentinelprobe.ai_decision.service import DecisionEngineService
from sentinelprobe.vulnerability_scanner.models import (
    Vulnerability,
    VulnerabilitySeverity,
    VulnerabilityStatus,
)


@pytest.fixture
def mock_session():
    """Mock database session."""
    return AsyncMock(spec=AsyncSession)


@pytest.fixture
def mock_vuln_service():
    """Mock vulnerability scanner service."""
    with patch("sentinelprobe.ai_decision.service.VulnerabilityScannerService") as mock:
        service = mock.return_value
        # Setup the prioritize_target_vulnerabilities method as AsyncMock
        service.prioritize_target_vulnerabilities = AsyncMock()
        yield service


@pytest.fixture
def mock_decision_service(mock_session, mock_vuln_service):
    """Mock decision engine service with mocked repositories."""
    with (
        patch(
            "sentinelprobe.ai_decision.repository.DecisionRuleRepository"
        ) as mock_rule_repo,
        patch(
            "sentinelprobe.ai_decision.repository.TestStrategyRepository"
        ) as mock_strategy_repo,
        patch(
            "sentinelprobe.ai_decision.repository.KnowledgeRepository"
        ) as mock_knowledge_repo,
        patch(
            "sentinelprobe.ai_decision.service.VulnerabilityScannerService",
            return_value=mock_vuln_service,
        ),
    ):

        # Create service with mocked session
        service = DecisionEngineService(mock_session)

        # Replace repositories with mocks
        service.rule_repo = mock_rule_repo.return_value
        service.strategy_repo = mock_strategy_repo.return_value
        service.knowledge_repo = mock_knowledge_repo.return_value

        # Setup rule repo create_rule method to return a rule with the same ID
        service.rule_repo.create_rule = AsyncMock(
            side_effect=lambda rule_data: DecisionRule(
                id=1,
                name=rule_data.name,
                description=rule_data.description,
                rule_type=rule_data.rule_type,
                severity=rule_data.severity,
                conditions=rule_data.conditions,
                actions=rule_data.actions,
                metadata=rule_data.metadata,
                priority=rule_data.priority if hasattr(rule_data, "priority") else 0,
            )
        )

        # Setup strategy repo create_strategy method
        service.strategy_repo.create_strategy = AsyncMock(
            side_effect=lambda strategy_data: TestStrategy(
                id=1,
                job_id=strategy_data.job_id,
                name=strategy_data.name,
                description=strategy_data.description,
                phase=strategy_data.phase,
                parameters=strategy_data.parameters,
                is_active=(
                    strategy_data.is_active
                    if hasattr(strategy_data, "is_active")
                    else True
                ),
                priority=(
                    strategy_data.priority if hasattr(strategy_data, "priority") else 0
                ),
            )
        )

        yield service


@pytest.fixture
def sample_vulnerabilities():
    """Sample vulnerabilities for testing."""
    return [
        # High severity vulnerability
        (
            Vulnerability(
                id=1,
                scan_id=1,
                target_id=1,
                name="Critical SQL Injection",
                description="SQL Injection vulnerability in login form",
                severity=VulnerabilitySeverity.CRITICAL,
                cvss_score=9.8,
                status=VulnerabilityStatus.CONFIRMED,
                affected_component="authentication",
                remediation="Use parameterized queries",
                details={
                    "exploitability": 9.5,
                    "business_impact": "critical",
                },
                cve_id="CVE-2023-1234",
                port_number=443,
                protocol="https",
            ),
            0.95,  # Priority score
        ),
        # Medium severity vulnerability
        (
            Vulnerability(
                id=2,
                scan_id=1,
                target_id=1,
                name="XSS Vulnerability",
                description="Cross-site scripting in comment form",
                severity=VulnerabilitySeverity.MEDIUM,
                cvss_score=6.0,
                status=VulnerabilityStatus.CONFIRMED,
                affected_component="web",
                remediation="Sanitize user input",
                details={
                    "exploitability": 7.0,
                    "business_impact": "medium",
                },
                cve_id="CVE-2023-5678",
                port_number=80,
                protocol="http",
            ),
            0.75,  # Priority score
        ),
        # Low severity vulnerability
        (
            Vulnerability(
                id=3,
                scan_id=1,
                target_id=1,
                name="Information Disclosure",
                description="Server reveals version information",
                severity=VulnerabilitySeverity.LOW,
                cvss_score=2.5,
                status=VulnerabilityStatus.CONFIRMED,
                affected_component="web-server",
                remediation="Configure server to hide version info",
                details={
                    "exploitability": 3.0,
                    "business_impact": "low",
                },
                port_number=80,
                protocol="http",
            ),
            0.35,  # Priority score
        ),
        # Medium severity vulnerability with same type as another
        (
            Vulnerability(
                id=4,
                scan_id=1,
                target_id=1,
                name="XSS Vulnerability in Search",
                description="Cross-site scripting in search form",
                severity=VulnerabilitySeverity.MEDIUM,
                cvss_score=5.5,
                status=VulnerabilityStatus.CONFIRMED,
                affected_component="search",
                remediation="Sanitize user input",
                details={
                    "exploitability": 6.0,
                    "business_impact": "medium",
                },
                cve_id="CVE-2023-9876",
                port_number=80,
                protocol="http",
            ),
            0.65,  # Priority score
        ),
    ]


@pytest.mark.asyncio
async def test_create_vulnerability_based_rules(
    mock_decision_service, sample_vulnerabilities
):
    """Test the creation of decision rules based on vulnerabilities."""
    # Call the method
    rules = await mock_decision_service.create_vulnerability_based_rules(
        sample_vulnerabilities
    )

    # Should create two rules: one for high/critical severity vulns and one for patterns (XSS)
    assert len(rules) == 2

    # Verify the high severity rule
    high_rule = rules[0]
    assert high_rule.name == "Focus on Critical Vulnerabilities"
    assert high_rule.rule_type == DecisionRuleType.EXPLOITATION
    assert high_rule.severity == DecisionRuleSeverity.CRITICAL
    assert high_rule.conditions["vulnerability_ids"] == [1]  # Critical vuln ID
    assert "min_priority_score" in high_rule.conditions
    assert "test_priority" in high_rule.actions
    assert high_rule.actions["test_priority"] == "high"

    # Verify the pattern rule (XSS vulnerabilities)
    pattern_rule = rules[1]
    assert "XSS" in pattern_rule.name
    assert pattern_rule.rule_type == DecisionRuleType.EXPLOITATION
    assert pattern_rule.severity == DecisionRuleSeverity.MEDIUM
    assert set(pattern_rule.conditions["vulnerability_ids"]) == {2, 4}  # Both XSS vulns
    assert pattern_rule.conditions["vulnerability_type"] == "XSS"
    assert "test_priority" in pattern_rule.actions
    assert pattern_rule.actions["test_priority"] == "medium"


@pytest.mark.asyncio
async def test_analyze_vulnerability_prioritization(
    mock_decision_service, mock_vuln_service, sample_vulnerabilities
):
    """Test the analysis of vulnerabilities for prioritization."""
    # Setup mock to return our sample vulnerabilities
    mock_vuln_service.prioritize_target_vulnerabilities.return_value = (
        sample_vulnerabilities
    )

    # Call the method
    target_id = 1
    job_id = 100
    strategy = await mock_decision_service.analyze_vulnerability_prioritization(
        target_id, job_id
    )

    # Verify the method was called with correct parameters
    mock_vuln_service.prioritize_target_vulnerabilities.assert_awaited_once_with(
        target_id=target_id, include_business_impact=True
    )

    # Verify strategy was created
    assert strategy is not None
    assert strategy.job_id == job_id
    assert strategy.name == "Prioritized Vulnerability Testing"
    assert strategy.phase == StrategyPhase.EXPLOITATION

    # Verify strategy parameters
    assert "prioritized_vulnerabilities" in strategy.parameters
    assert len(strategy.parameters["prioritized_vulnerabilities"]) == len(
        sample_vulnerabilities
    )

    # Verify vulnerabilities are in correct order (by priority score)
    vuln_ids = [v["id"] for v in strategy.parameters["prioritized_vulnerabilities"]]
    assert vuln_ids[0] == 1  # Critical should be first

    # Verify strategy creation was called
    mock_decision_service.strategy_repo.create_strategy.assert_awaited_once()


@pytest.mark.asyncio
async def test_analyze_vulnerability_prioritization_no_vulnerabilities(
    mock_decision_service, mock_vuln_service
):
    """Test handling of no vulnerabilities found."""
    # Setup mock to return empty list
    mock_vuln_service.prioritize_target_vulnerabilities.return_value = []

    # Call the method
    strategy = await mock_decision_service.analyze_vulnerability_prioritization(1, 100)

    # Verify no strategy was created
    assert strategy is None

    # Verify method was still called
    mock_vuln_service.prioritize_target_vulnerabilities.assert_awaited_once()

    # Verify strategy creation was not called
    mock_decision_service.strategy_repo.create_strategy.assert_not_awaited()


@pytest.mark.asyncio
async def test_create_vulnerability_based_rules_empty_list(mock_decision_service):
    """Test handling of empty vulnerability list."""
    # Call the method with empty list
    rules = await mock_decision_service.create_vulnerability_based_rules([])

    # Verify no rules were created
    assert len(rules) == 0

    # Verify rule creation was not called
    mock_decision_service.rule_repo.create_rule.assert_not_awaited()


@pytest.mark.asyncio
async def test_create_vulnerability_based_rules_mixed_severities(mock_decision_service):
    """Test rule creation with mixed severity vulnerabilities."""
    # Create a list with only medium/low vulnerabilities
    vulns = [
        # Medium severity vulnerability 1
        (
            Vulnerability(
                id=2,
                name="SQL Injection",
                severity=VulnerabilitySeverity.MEDIUM,
                cvss_score=5.0,
                affected_component="database",
                details={"business_impact": "medium"},
            ),
            0.7,
        ),
        # Medium severity vulnerability 2 (same type)
        (
            Vulnerability(
                id=3,
                name="SQL Injection 2",
                severity=VulnerabilitySeverity.MEDIUM,
                cvss_score=5.5,
                affected_component="login",
                details={"business_impact": "medium"},
            ),
            0.65,
        ),
        # Low severity vulnerability
        (
            Vulnerability(
                id=4,
                name="Info Disclosure",
                severity=VulnerabilitySeverity.LOW,
                cvss_score=2.0,
                affected_component="server",
                details={"business_impact": "low"},
            ),
            0.3,
        ),
    ]

    # Call the method
    rules = await mock_decision_service.create_vulnerability_based_rules(vulns)

    # Should only create a pattern rule for SQL Injection, no high severity rule
    assert len(rules) == 1
    pattern_rule = rules[0]
    assert "SQL" in pattern_rule.name
    assert pattern_rule.rule_type == DecisionRuleType.EXPLOITATION
    assert pattern_rule.severity == DecisionRuleSeverity.MEDIUM
    assert set(pattern_rule.conditions["vulnerability_ids"]) == {2, 3}

    # Verify rule creation was called once
    assert mock_decision_service.rule_repo.create_rule.call_count == 1
