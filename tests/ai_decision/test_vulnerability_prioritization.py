"""Tests for vulnerability prioritization in the AI decision engine."""

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from sentinelprobe.ai_decision.models import DecisionRule, StrategyPhase, TestStrategy
from sentinelprobe.ai_decision.service import DecisionEngineService
from sentinelprobe.vulnerability_scanner.models import (
    Vulnerability,
    VulnerabilitySeverity,
    VulnerabilityStatus,
)


@pytest.fixture
def mock_prioritized_vulnerabilities():
    """Create mock prioritized vulnerabilities for testing."""
    vuln1 = Vulnerability(
        id=1,
        scan_id=1,
        target_id=100,
        name="Critical SQL Injection",
        description="Critical SQL injection vulnerability in login endpoint",
        severity=VulnerabilitySeverity.CRITICAL,
        status=VulnerabilityStatus.CONFIRMED,
        cve_id="CVE-2023-1234",
        cvss_score=9.8,
        affected_component="authentication_service",
        port_number=443,
        protocol="https",
        details={},
        remediation="Update to latest version and use parameterized queries",
    )

    vuln2 = Vulnerability(
        id=2,
        scan_id=1,
        target_id=100,
        name="Open Admin Interface",
        description="High severity exposure of admin interface",
        severity=VulnerabilitySeverity.HIGH,
        status=VulnerabilityStatus.CONFIRMED,
        cve_id=None,
        cvss_score=None,
        affected_component="admin_portal",
        port_number=8080,
        protocol="http",
        details={},
        remediation="Implement proper authentication",
    )

    # Return a list of tuples (vulnerability, priority_score)
    return [(vuln1, 9.5), (vuln2, 7.8)]


@pytest.mark.asyncio
async def test_create_vulnerability_based_rules(
    mock_db_session, mock_prioritized_vulnerabilities
):
    """Test creation of decision rules based on prioritized vulnerabilities."""
    # Setup
    session = mock_db_session
    service = DecisionEngineService(session)

    # Create rules
    rules = await service.create_vulnerability_based_rules(
        mock_prioritized_vulnerabilities
    )

    # Assertions
    assert len(rules) == 2, "Should create two rules"

    # Check first rule details
    rule1 = rules[0]
    assert (
        "Critical SQL Injection" in rule1.name
    ), "Rule name should include vulnerability name"
    assert (
        rule1.conditions["target_id"] == 100
    ), "Rule should have target ID in conditions"
    assert (
        rule1.conditions["affected_component"] == "authentication_service"
    ), "Rule should include affected component"
    assert rule1.conditions["port_number"] == 443, "Rule should include port number"
    assert rule1.conditions["protocol"] == "https", "Rule should include protocol"
    assert (
        "immediate_remediation" in rule1.actions["suggested_actions"]
    ), "Critical vuln should suggest immediate remediation"

    # Check second rule details
    rule2 = rules[1]
    assert (
        "Open Admin Interface" in rule2.name
    ), "Rule name should include vulnerability name"
    assert (
        rule2.priority > rule1.priority
    ), "Higher priority vuln should have lower priority value (higher precedence)"
    assert (
        "detailed_exploitation" in rule2.actions["suggested_actions"]
    ), "High vuln should suggest detailed exploitation"


@pytest.mark.asyncio
async def test_analyze_vulnerability_prioritization(
    monkeypatch, mock_db_session, mock_prioritized_vulnerabilities
):
    """Test creation of test strategy based on vulnerability prioritization."""
    # Setup
    session = mock_db_session
    service = DecisionEngineService(session)
    target_id = 100
    job_id = 200

    # Mock the prioritize_target_vulnerabilities method
    class MockVulnService:
        async def prioritize_target_vulnerabilities(self, **kwargs):
            return mock_prioritized_vulnerabilities

    # Apply monkeypatch
    monkeypatch.setattr(
        "sentinelprobe.ai_decision.service.VulnerabilityScannerService",
        lambda _: MockVulnService(),
    )

    # Call method
    strategy = await service.analyze_vulnerability_prioritization(target_id, job_id)

    # Assertions
    assert strategy is not None, "Should create a strategy"
    assert strategy.job_id == job_id, "Strategy should be associated with job"
    assert (
        strategy.phase == StrategyPhase.EXPLOITATION
    ), "Strategy should be for exploitation phase"
    assert strategy.priority == 50, "Strategy should have higher priority than default"

    # Check strategy parameters
    params = strategy.parameters
    assert (
        "prioritized_vulnerabilities" in params
    ), "Should include prioritized vulnerabilities"
    assert (
        len(params["prioritized_vulnerabilities"]) == 2
    ), "Should include both vulnerabilities"
    assert params["target_id"] == target_id, "Should include target ID"
    assert (
        params["strategy_approach"] == "prioritized_testing"
    ), "Should specify prioritized testing approach"

    # Check vulnerability details in parameters
    vuln1_params = next(
        v for v in params["prioritized_vulnerabilities"] if v["id"] == 1
    )
    assert vuln1_params["severity"] == "critical", "Should include severity"
    assert vuln1_params["priority_score"] == 9.5, "Should include priority score"


@pytest.mark.asyncio
async def test_api_create_optimized_test_path(
    monkeypatch, mock_db_session, mock_prioritized_vulnerabilities
):
    """Test API endpoint for creating optimized test path."""
    from fastapi.testclient import TestClient

    from sentinelprobe.api.app import app

    # Setup mocks
    class MockVulnService:
        async def prioritize_target_vulnerabilities(self, **kwargs):
            return mock_prioritized_vulnerabilities

        async def get_scan(self, scan_id):
            return {"id": scan_id, "target_id": 100}

    class MockDecisionService:
        def __init__(self, session):
            self.session = session

        async def create_vulnerability_based_rules(self, prioritized_vulns):
            # Create mock rules
            rules = []
            for i, (vuln, score) in enumerate(prioritized_vulns):
                rule = DecisionRule(
                    id=i + 1,
                    name=f"Rule for {vuln.name}",
                    description=f"Decision rule for {vuln.name}",
                    rule_type="vulnerability_scan",
                    severity=(
                        "critical"
                        if vuln.severity == VulnerabilitySeverity.CRITICAL
                        else "high"
                    ),
                    conditions={"target_id": vuln.target_id},
                    actions={"suggested_actions": ["test"]},
                    is_active=True,
                    priority=int(100 - score * 10),
                    rule_metadata={"source": "test"},
                )
                rules.append(rule)
            return rules

        async def analyze_vulnerability_prioritization(self, target_id, job_id):
            # Create mock strategy
            return TestStrategy(
                id=1,
                job_id=job_id,
                name="Test Strategy",
                description="Test strategy from prioritization",
                phase=StrategyPhase.EXPLOITATION,
                parameters={"target_id": target_id},
                is_active=True,
                priority=50,
                strategy_metadata={},
            )

    # Apply monkeypatches
    monkeypatch.setattr(
        "sentinelprobe.api.router.get_async_session", lambda: mock_db_session
    )
    monkeypatch.setattr(
        "sentinelprobe.ai_decision.api.VulnerabilityScannerService",
        lambda session: MockVulnService(),
    )
    monkeypatch.setattr(
        "sentinelprobe.ai_decision.api.DecisionEngineService", MockDecisionService
    )

    # Use test client
    client = TestClient(app)

    # Make request
    response = client.post(
        "/api/v1/ai-decision/test-path-optimization/target/100/job/200"
    )

    # Assertions
    assert response.status_code == 200, "Should return 200 OK"
    data = response.json()
    assert len(data) == 2, "Should return two rules"
    assert (
        data[0]["name"] == "Rule for Critical SQL Injection"
    ), "Should include rule for critical vulnerability"
    assert (
        data[1]["name"] == "Rule for Open Admin Interface"
    ), "Should include rule for high vulnerability"
